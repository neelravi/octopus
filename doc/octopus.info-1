This is octopus.info, produced by makeinfo version 4.5 from
octopus.texi.

INFO-DIR-SECTION Individual utilities
START-INFO-DIR-ENTRY
* octopus: (octopus).           The octopus program.
END-INFO-DIR-ENTRY

This manual is for octopus 1.3, a first principles, electronic
structure, excited states, time-dependent density functional theory
program.

   Copyright (C) 2002, 2003 Miguel A. L. Marques, Alberto Castro and
Angel Rubio

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.1 or any later version published by the Free Software
     Foundation.
   

File: octopus.info,  Node: Top,  Next: Copying,  Prev: (dir),  Up: (dir)

octopus
*******

This manual is for octopus 1.3, a first principles, electronic
structure, excited states, time-dependent density functional theory
program.

   Copyright (C) 2002, 2003 Miguel A. L. Marques, Alberto Castro and
Angel Rubio

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.1 or any later version published by the Free Software
     Foundation.
   
* Menu:

* Copying::
* Authors::
* Introduction::
* Installation::
* The parser::
* Input file options::
* External utilities::
* Examples::
* Options Index::

 --- The Detailed Node Listing ---

Introduction

* Description of octopus::
* Time dependent density functional theory::

Installation

* Quick instructions::
* Long instructions::
* Troubleshooting::

Input file options

* Generalities::
* Species Block::
* Coordinates Description::
* Mesh::
* States::
* Hamiltonian::
* Exchange and correlation::
* SCF::
* Unoccupied States::
* Time Dependent::
* Geometry optimization::
* Function output for visualization::
* Spectrum calculations::
* Varia::

Generalities

* SystemName::
* Dimensions::
* CalculationMode::
* Units::
* UnitsInput::
* UnitsOutput::
* Verbose::
* DebugLevel::

Species Block

* Species::

Coordinates Description

* PDBCoordinates::
* XYZCoordinates::
* Coordinates::
* XYZVelocities::
* Velocities::
* RandomVelocityTemp::

Mesh

* BoxShape::
* Radius::
* Lsize::
* ZLength::
* Spacing::
* DerivativesSpace::
* OrderDerivatives::
* DoubleFFTParameter::
* FFTOptimize::

States

* SpinComponents::
* NumberKPoints::
* ExcessCharge::
* ExtraStates::
* Occupations::
* ElectronicTemperature::

Hamiltonian

* NonInteractingElectrons::
* ClassicPotential::
* LocalPotentialSpace::
* RelativisticCorrection::

Exchange and correlation

* XFunctional::
* CFunctional::

SCF

* MaximumIter::
* ConvAbsDens::
* ConvRelDens::
* ConvAbsEv::
* ConvRelEv::
* GuessDensitySpin::
* LCAOStart::
* SCFinLCAO::
* EigenSolver::
* EigenSolverInitTolerance::
* EigenSolverFinalTolerance::
* EigenSolverFinalToleranceIteration::
* EigenSolverMaxIter::
* What2Mix::
* TypeOfMixing::
* Mixing::
* MixNumberSteps::

Unoccupied States

* UnoccNumberStates::
* UnoccMaximumIter::
* UnoccConv::

Time Dependent

* TDMaximumIter::
* TDTimeStep::
* TDExponentialMethod::
* TDExpOrder::
* TDLanczosTol::
* TDEvolutionMethod::
* TDLasers::
* TDGauge::
* TDDeltaStrength::
* TDPolarization::
* TDOutputMultipoles::
* TDDipoleMax::
* TDOutputCoordinates::
* TDOutputGSProjection::
* TDOutputAcceleration::
* TDOutputLaser::
* TDOutputElEnergy::
* TDOutputOccAnalysis::
* MoveIons::
* AbsorbingBoundaries::
* ABWidth::
* ABHeight::

Geometry optimization

* GOMethod::
* GOTolerance::
* GOMaxIter::
* GOStep::

Function output for visualization

* OutputKSPotential::
* OutputDensity::
* OutputWfs::
* OutputWfsNumber::
* OutputElf::
* OutputGeometry::
* OutputAxisX::
* OutputAxisY::
* OutputAxisZ::
* OutputPlaneX::
* OutputPlaneY::
* OutputPlaneZ::
* OutputDX::
* OutputNETCDF::
* OutputEvery::

Spectrum calculations

* SpecTransformNode::
* SpecDampMode::
* SpecDampFactor::
* SpecStartTime::
* SpecEndTime::
* SpecEnergyStep::
* SpecMinEnergy::
* SpecMaxEnergy::
* HSPolarization::

Varia

* PoissonSolver::
* POLStaticField::
* Displacement::

External utilities

* oct-sf::
* oct-rsf::
* oct-hs-mult::
* oct-hs-acc::
* oct-xyz-anim::
* oct-excite::
* oct-broad::
* oct-make-st::
* oct-choose-st::
* oct-center-geom::
* wf.net::

Examples

* Hello world::
* Benzene::


File: octopus.info,  Node: Copying,  Next: Authors,  Prev: Top,  Up: Top

Copying
*******

   This program is "free"; this means that everyone is free to use it
and free to redistribute it on a free basis.  What is not allowed is to
try to prevent others from further sharing any version of this program
that they might get from you.

   Specifically, we want to make sure that you have the right to give
away copies of the program, that you receive source code or else can
get it if you want it, that you can change this program or use pieces
of them in new free programs, and that you know you can do these things.

   To make sure that everyone has such rights, we have to forbid you to
deprive anyone else of these rights.  For example, if you distribute
copies of the program, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must tell them their rights.

   Also, for our own protection, we must make certain that everyone
finds out that there is no warranty for this program.  If these
programs are modified by someone else and passed on, we want their
recipients to know that what they have is not what we distributed, so
that any problems introduced by others will not reflect on our
reputation.

   The precise conditions of the license are found in the General Public
Licenses that accompany it.


File: octopus.info,  Node: Authors,  Next: Introduction,  Prev: Copying,  Up: Top

Authors, Collaborators and Acknowledgements.
********************************************

   The main developing team of this program is composed of:

   * Miguel A. L. Marques (Freie Universita"t, Berlin, Deutschland),

   * Angel Rubio, (Donostia International Physics Center and Department
     of Materials Science UPV/EHU, San Sebastia'n, Espan~a), and

   * Alberto Castro, (Universidad de Valladolid, Departamento de
     Fi'sica Teo'rica, Valladolid, Espan~a).

   `octopus' is based on a fixed-nucleus code written by George F.
Bertsch and K. Yabana to perform real-time dynamics in clusters (Phys
Rev B *54*, 4484 (1996)) and on a condensed matter real-space
plane-wave based code written by A. Rubio, X. Blase and S.G. Louie
(Phys. Rev. Lett. *77*, 247 (1996)).  The code was afterwards extended
to handle periodic systems by G.F. Bertsch, J.I. Iwata, A. Rubio, and
K. Yabana (Phys. Rev. B, *62*, 7998 (2000)). Contemporaneously there was
a major rewrite of the original cluster code to handle a vast majority
of finite systems. At this point the cluster code was named "tddft".

   This version was consequently enhanced and beautified by A. Castro
(at the time Ph.D. student of A. Rubio), originating a fairly verbose
15,000 lines of Fortran 90/77. In the year 2000, M. Marques (aka
Hyllios, aka Anto'nio de Faria, corsa'rio portugue^s), joined the A.
Rubio group in Valladolid as a postdoc. Having to use "tddft" for his
work, and being petulant enough to think he could structure the code
better than his predecessors, he started a major rewrite of the code
together with A. Castro, finishing version 0.2 of "tddft." But things
were still not perfect: due to their limited experience in Fortran 90,
and due to the inadequacy of this language for anything beyond a HELLO
WORLD program, several parts of the code were still clumsy. Also the
idea of GPLing the almost 20,000 lines arose during an alcoholic
evening. So after several weeks of fantic coding and after getting rid
of the Numerical Recipes code that still lingered around, `octopus' was
born.

   The present released version has been completely rewritten and keeps
very little relation to the old version (even input and output files)
and has been enhanced with major new flags to perform various
excited-state dynamics in finite and extended systems (one-dimensional
periodic chains). The code will be updated frequently and new versions
can be found here (http://www.tddft.org/programs/octopus).

   The main features of the present version are described in detail in
_octopus: a first principles tool for excited states electron-ion
dynamics_, Comp. Phys. Comm. *151*, 60 (2003).  Updated references as
well as results obtained with octopus will be posted regularly to the
`octopus' web page. If you find the code useful for you research we
would appreciate if you give reference to this work and previous ones.

   If you have some free time, and if you feel like taking a joy ride
with Fortran 90, just drop us an email <octopus@tddft.org>. You can
also send us patches, comments, ideas, wishes, etc. They will be
included in new releases of octopus.


File: octopus.info,  Node: Introduction,  Next: Installation,  Prev: Authors,  Up: Top

Introduction
************

   [Note to info readers: The preferred way to read this manual is in
its pdf or dvi versions, since there are quite a few equations that
will not print out well in info format. However, we have tried to make
the info format readable. For this purpose, we have chosen the
following convention: instead of removing the equations in the info
files, they will show up as the TeX commands that produce them in the
printed documentation]

* Menu:

* Description of octopus::
* Time dependent density functional theory::


File: octopus.info,  Node: Description of octopus,  Next: Time dependent density functional theory,  Prev: Introduction,  Up: Introduction

Description of `octopus'
========================

   `octopus' (1) is a program aimed at the ab initio virtual
experimentation on electron/ion dynamics in external electromagnetic
fields of arbitrary intensity, shape and frequency in a hopefully ever
increasing range of systems types. Its main characteristics are:

   * Electrons are described quantum-mechanically within the
     Density-Functional Theory (DFT) for the ground-state whereas the
     excitation spectra is computed using time-dependent form (TDDFT)
     by performing simulations in time.

   * The electron-nucleus interaction is described within the
     pseudo-potential approximation. Nuclei are described classically
     as point particles.

   * Wave-functions are expanded in a real-space grid. The kinetic
     energy operator is computed with a high-order finite difference
     method.  FFTs are used in part of the calculations.  Time and grid
     spacing are related by imposing a stable time-evolution.

   * Forces on the ions are computed through the Ehrenfest theorem.
     Extension to quantum mechanical nuclear dynamics is in progress.

   * Allows for spin-polarised calculations as well as non-collinear
     magnetism and spin-orbit effects.

   * Computes photo-electron (energy and angle resolved) and
     photo-absorption spectra for different polarised external
     electromagnetic fields. Linear response calculations are a simple
     case of this general time-evolution procedure (see below).

   * Includes non-linear electronic effects: high-harmonic generation,
     interaction with a laser pulse of arbitrary intensity. For the
     time being only time- and spatially-dependent electric fields are
     included, in the future magnetic fields will be incorporated.

   * Reads different geometry files including protein-data-base (PDB)
     for biological calculations (interaction of biomolecules with
     electromagnetic fields).

   * It allows for one and two dimesional modes by using for example
     the soft-coulomb potential or any other given as input.

   * Laser-pulse optimisation using genetic algorithms (to be done).

   * Utilities to analyse the computed spectra.

   * A very effective and easy-to-use parser to handle the input file.


   ---------- Footnotes ----------

   (1) _octopus_: Etymology: New Latin _Octopod-_, _Octopus_, from
Greek _oktOpous_.  Any of a genus (_Octopus_) of cephalopod mollusks
that have eight muscular arms equipped with two rows of suckers;
broadly, any octopod excepting the paper nautilus.  Something that
resembles an octopus especially in having many centrally directed
branches.  (Taken from the Merryam-Webster's dictionary.)


File: octopus.info,  Node: Time dependent density functional theory,  Prev: Description of octopus,  Up: Introduction

Time dependent density functional theory
========================================

   Several reviews of time-dependent density function theory (TDDFT)
and its applications have appeared recently, like the works by Gross et
al. (1), Casida (2), Dobson et al, (3) , and Burke et al (4).

   The Hohenberg-Kohn-Sham theory as described is a ground state
theory, and it is hence not meant for the calculation of electronic
excitations.  However, one can extend the ideas of static DFT. When one
asks for the evolution of the system under the influence of a
time-dependent external potential, one should search the extrema of the
quantum mechanical action

   A = \int_t0^t1 dt  <\psi(t) | i\partial_t -H(t) | \psi>

   Theorems have now been established for time-dependent DFT(5) which
are parallel to those of static DFT.  The first theorem proves a
one-to-one mapping between time-dependent potentials and time-dependent
densities; the second proves the stationary-action principle.

   The proof of the first theorem is based directly on the evolution of
the time-dependent Schro"dinger equation from a fixed initial
many-particle state \Psi(t_0)=\Psi_0 under the influence of a
time-dependent potential v(t) required to be expandable in a Taylor
series around t_0.  The initial state \Psi_0 does not need to be the
ground state or some other eigenstate of the initial potential.  As one
does not rely on the adiabatic connection as in standard
zero-temperature many-body perturbation theory the formalism is able to
handle external perturbations varying fast in time. By virtue of the
first theorem, the time-dependent density determines the external
potential uniquely up to an additive purely time-dependent function.
On the other hand, the potential determines the time-dependent
wave-function, therefore the expectation value of any quantum
mechanical operator is a unique functional of the density.

   The second theorem deals with the variational principle of the action
functional with the initial condition \Psi(t_0)=\Psi_0.  From the
previous one-to-one mapping between time-dependent potentials and
densities, the action is a functional of the density that must have a
stationary point at the correct time-dependent density.  Thus the Euler
equation corresponding to the extrema of A[\rho],

   \delta A[\rho] / \delta \rho(r) = 0,

   determines the time-dependent density, just as in the Hohenberg-Kohn
formalism the static ground state density is given by the minimum of
the total energy (\delta E[\rho]/\delta \rho(\bf r,t)=0).

   Similarly, one can define a time-dependent Kohn-Sham (KS) scheme by
introducing a non-interacting system that reproduces the exact
interacting density \rho(\bf r,t).  One gets the following
time-dependent KS-equations:

   ( 1/2 \nabla^2 + V_eff(r,t) ) \psi_i(r,t)  = i \partial_t \psi_i(r,t)

   \rho(r,t) = V_H(r,t) = \sum_i=1^N |\psi_i(r,t)|^2

   where

   V_eff(r,t) = V_H(r,t) + V_xc(r,t) + V_ext(r,t)

   is the effective time-dependent potential felt by the electrons. It
consists of the sum of the external time-dependent applied field, the
time-dependent Hartree term, plus the  xc potential (defined through
the equivalence between the interacting and fictitious non-interacting
systems). The variational principle yields

   V_xc(r,t) = \delta A_xc[\rho] / \delta \rho(r,t).

   where A_\rm xc[\rho] is the xc part of the action functional.

   The main advantage of the time-dependent KS scheme lies in its
computational simplicity compared to other quantum-chemical models such
as time-dependent Hartree-Fock or configuration interaction.

   ---------- Footnotes ----------

   (1)   Gross, E.K.U., C.A. Ullricht and U.J. Grossmann, 1994, in
_Density Functional Theory_, (NATOP ASI Series), p.194;   Gross,
E.K.U., F. J. Dobson, and M. Petersilka, 1996,   _Density Functional
Theory_ (Springer, New York).

   (2)   Casida, M.E., 1995, in _Recent Advances in Density Functional
Methods_,   Part I, ed. D.P. Chong (World Scientific, Singapore), p.155;
 Casida, M.E., 1996, in _Recent Developments and Applications of Modern
 Density Functional Theory_, ed. J.M. Seminario (Elsevier Science,
Amsterdam), p.391

   (3)   Dobson, J , G. Vignale and M.P. Das (Eds), 1997a,
_Electronic Density Functional Theory: Recent Progress and New
Directions_   (Plenum, New York)

   (4)   Burke, K., M. Petersilka and E.K.U. Gross, 2001, in   _Recent
Advances in Density Functional Methods_, edited by P.    Fantucci and
A. Bencini (World Scientific, Singapure).

   (5) Runge, E. and E. K. U. Gross, 1984, Phys. Rev. Lett. *52* 997.


File: octopus.info,  Node: Installation,  Next: The parser,  Prev: Introduction,  Up: Top

Installation
************

* Menu:

* Quick instructions::
* Long instructions::
* Troubleshooting::


File: octopus.info,  Node: Quick instructions,  Next: Long instructions,  Prev: Installation,  Up: Installation

Quick instructions
==================

   For the inpatients, here goes the quick-start:
     prompt> gzip -cd octopus<-version>.tar.gz | tar xvf -
     prompt> cd octopus-<version>
     prompt> ./configure
     prompt> make
     prompt> make install

   This will probably *not* work, so before giving up, just read the
following paragraphs.

   Also, rpm and deb binaries for linux are supplied on the web-page.


File: octopus.info,  Node: Long instructions,  Next: Troubleshooting,  Prev: Quick instructions,  Up: Installation

Long instructions
=================

   The code is written in standard Fortran 90, with some routines
written in C (and in bison, if we count the input parser). To build it
you will need both a C compiler (`gcc' works just fine), and a Fortran
90 compiler. No free-software Fortran 90 compiler is available yet, so,
if you want to chew the `octopus', you will have either to help the g95
(http://g95.sourceforge.net) project or use any of the available
comercial compilers.

   Besides the compiler, you will also need:
  1. `make':  most computers have it installed, otherwise just grab and
     install the GNU `make'.

  2. `cpp': The C preprocessor is heavily used in `octopus'.  GNU `cpp'
     is just fine, but any `cpp' that accepts the `-C' flag (preserve
     comments) should work just as well.

  3. FFTW: We have relied on this great library to perform the Fast
     Fourier Transforms (FFTs). You may grab it from here
     (http://www.fftw.org/).  You may use FFTW version 2 as well as
     FFTW version 3. `octopus' will try first to use the latter one,
     since it is significantly faster in some architectures.

  4. LAPACK/BLAS: Required. Our politics is to rely on these two
     libraries as much as possible on these libraries for the linear
     algebra operations.  If you are running Linux, there is a fair
     chance they are already installed in your system. The same goes to
     the more heavyweight machines (alphas, IBMs, SGIs, etc.).
     Otherwise, just grab the source from here (http://www.netlib.org).

  5. GSL: Finally that someone had the nice idea of making a public
     scientific library! GSL still needs to grow, but it is already
     quite useful and impressive.  `octopus' uses splines, complex
     numbers, special functions, etc. from GSL, so it is a must! If you
     don't have it already installed in your system, you can obtain GSL
     from here (http://sources.redhat.com/gsl/). You will need version
     1.0 or higher.

  6. MPI: If you want to run `octopus' in multi-tentacle (parallel)
     mode, you will need an implementation of MPI.  MPICH
     (http://www-unix.mcs.anl.gov/mpi/mpich/) works just fine in our
     Linux boxes.


   First you should obtain the code file, `octopus<-version>.tar.gz',
(this you probably have already done). The code is freely available, and
can be downloaded from `http://www.tddft.org/programs/octopus'. There
exists a `cvs' server, which you can browse at
`http://nautilus.fis.uc.pt/cgi-bin/cvsweb.cgi/marques/octopus/'.  The
sources of the cvs version (in general more unstable the the _official_
distribution) may be downloaded by anonymous cvs access:

     prompt> cvs -d :pserver:anonymous@nautilus.fis.uc.pt:/server/cvsroot
             login
     
     prompt> cvs -d :pserver:anonymous@nautilus.fis.uc.pt:/server/cvsroot
             co marques/octopus

   Uncompress and untar it (`gzip -cd octopus<-version>.tar.gz | tar
-xvf -').  In the following, `OCTOPUS-HOME' denotes the home directory
of octopus, created by the `tar' command.

   The `OCTOPUS-HOME' contains the following subdirectories:
   * `autom4te.cache, build, CVS, debian': contains files related to
     the building system or the CVS repository. May actually not be
     there.  Not of real interest for the plain user.

   * `doc': The documentation of `octopus' in _texinfo_ format.

   * `liboct': Small C library that handles the interface to GSL and
     the parsing of the input file. It also contains some assorted
     routines that we didn't want to write in boring Fortran.

   * `samples': Sample input files for `octopus'.

   * `share': Made to contain "auxiliary" files eventually used by the
     code; in practice now it contains the Troullier-Martins and
     Hartwigsen-Goedecker-Hutter pseudopotential files.

   * `share/util': Currently, the _utilities_ include a couple of IBM
     OpenDX networks (*note wf.net::), to visualize wavefunctions,
     densities, etc.

   * `src': Fortran 90 source files. Note that these have to be
     preprocessed before being fed to the Fortran compiler, so do not
     be scared by all the # directives.

   Before configuring you can (should) setup a couple of options.
Although the configure script tries to guess your system settings for
you, we recommend that you set explicitly the default Fortran 90
compiler and the compiler options.  For example, in `bash' you would
typically do:
     export F90=abf90
     export F90FLAGS="-O -YEXT_NAMES=LCS -YEXT_SFX=_"
   if you are using the Absoft Fortran 90 compiler on a linux machine.
Also, if you have some of the required libraries in some unusual
directories, these directories may be placed in the variable `LDFLAGS'
(e.g., `export LDFLAGS=$LDFLAGS:/opt/lib/').

   You can now run the configure script (`./configure').  (1) You can
use a fair amount of options to spice `octopus' to your own taste.  To
obtain a full list just type `./configure --help'. Some commonly used
options include:
   * `--prefix=PREFIX': Change the base installation dir of `octopus'
     to `PREFIX'. The executable will be installed in `PREFIX/bin', the
     libraries in `PREFIX/lib' and the documentation in `PREFIX/info'.
     `PREFIX' defaults to the home directory of the user who runs
     `configure'.

   * `--enable-fft=fftw2': Instruct the `configure' script to use the
     FFTW library, and specifically to use the FFTW version 2. You may
     also set `--enable-fft=fftw3' or even `--disable-fft'.

   * `--with-lapack=DIR': Installation directory of the LAPACK and BLAS
     libraries.

   * `--with-gsl-prefix=DIR': Installation directory of the GSL
     library. The libraries are expected to be in `DIR/lib' and the
     include files in `DIR/include'. The value of `DIR' is usually
     found by issuing the command `gsl-config --prefix'. (If the GSL
     library is installed, the program `gsl-config' should be
     somewhere.)

   * `--enable-mpi': Builds the parallel version (MPI) of `octopus'.

   * `--enable-complex': Builds a version with complex wave-functions
     for the ground-state calculations (wave-functions are always
     complex for the evolution). This is needed when spinors are needed
     -- e.g. noncollinear magnetism is going to be considered, or the
     spin-orbit coupling term will be used.

   * `--enable-debug': Builds a version that is able to emit some
     debugging information. Useful for developers, or to report bugs.
     If `octopus' has been built with this option enabled, you may set
     the variable `Verbose' to "debug" level, and set `DebugLevel'
     (*note Verbose:: and *note DebugLevel::, respectively).

   Run `make', and then `make install'. If everything went fine, you
should now be able to taste `octopus'. Depending on the options passed
to the configure script, some suffixes or prefixes could be added to
the generic name `octopus' -- i.e. `zoctopus' for the code compiled for
complex wave-functions, `zoctopus-mpi' for a parallel version of the
code compiled for complex wave-function, and so on.

   The program has been tested in the following platforms:
   * `i686*-linux-gnu': with the Absoft (http://www.absoft.com),   and
     the Intel (http://www.intel.com/software/products/compilers/)
     compiler.

   * `alphae*': both in Linux and in OSF/1 with Compaq's `fort'
     compiler.

   * `powerpc-ibm-aix4.3.3.0': with native `xlf90' compiler.

   * `cray': with native f90 compiler.
   If you manage to compile/run `octopus' on a different platform or
with a different compiler, please let us know so we can update the
list. Patches to solve compiler issues are also welcomed.

   Build the documentation in the format you prefer. Since you are
reading this, you already have it in some format. Due to the power of
`texinfo', a series of formats are available, namely `dvi', `html',
`pdf' and `info'. The `octopus.texi' source code of this document is in
the `OCTOPUS-HOME/doc' directory.

   ---------- Footnotes ----------

   (1) If you downloaded the cvs version, you will not find the
`configure' script.  In order to compile the development version you
will first have to run the GNU autotools.  This may be done by
executing the script `./autogen.sh'.  Note that you need to have
working versions of the `automake' (1.7.3), `autoconf' (2.57) and
`libtool' (1.4.3) programs (the versions we currently use are between
parentheses). Note that the `autogen.sh' script will likely fail if you
have (much) older versions of the autotools.


File: octopus.info,  Node: Troubleshooting,  Prev: Long instructions,  Up: Installation

Troubleshooting
===============

   If you are reading this it is because something went wrong. Let us
see if we can fix it ;)

   *Could not find library...*: This is probably the most common error
you can get. `octopus' uses three different libraries, `GSL', `FFTW',
and `BLAS'/`LAPACK'. We assume that you have already installed these
libraries but, for some reason, you were not able to compile the code.
So, what went wrong?
   * Did you pass the correct `--with-XXXX' (where XXXX is gsl, fftw or
     lapack in lowercase) to the configure script? If your libraries are
     installed in a non-standard directory (like `/opt/lapack'), you
     will have to pass the script the location of the library (in this
     example, you could try `./configure --with-lapack=/opt/lapack'.

   * If you are working on an alpha station, do not forget that the
     `CXML' library includes `BLAS' and `LAPACK', so it can be used by
     `octopus'. If needed, just set the correct path with
     `--with-lapack'.

   * If the configuration script can not find `FFTW', it is probable
     that you did not compile `FFTW' with the same Fortran compiler or
     with the same compiler options. The basic problem is that Fortran
     sometimes converts the function names to uppercase, at other times
     to lowercase, and it can add an "_" to them, or even two.
     Obviously all libraries and the program have to use the same
     convention, so the best is to compile everything with the same
     Fortran compiler/options. If you are a power user, you can check
     the convention used by your compiler using the command `nm
     <library>'.


   *Whatever went wrong...*: Up to now, we cannot really make a list of
commonly found problems. So if something else went wrong, please
subscribe to `octopus-users' mailing list, and ask.


File: octopus.info,  Node: The parser,  Next: Input file options,  Prev: Installation,  Up: Top

The parser
**********

   All input options should be in a file called "`inp'", in the
directory `octopus' is run from. Alternatively, if this file is not
found, standard input is read. For a fairly comprehensive example, just
look at the file `OCTOPUS_HOME/samples/inp'

   At the beginning of the program `liboct' reads the `inp' file,
parses it, and generates a list of variables that will be read by
`octopus' (note that the input is case independent).  There are two
kind of variables, scalar values (strings or numbers), and blocks (that
you may view as matrices). A scalar variable `var' can be defined by:
     var = exp
   `var' can contain any alphanumeric character plus "_", and `exp' can
be a quote delimited string, a number (integer, real, or complex), a
variable name, or a mathematical expression.  In the expressions all
arithmetic operators are supported ("a+b", "a-b", "a*b", "a/b"; for
exponentiation the C syntax "a^b" is used), and the following functions
can be used:
   * `sqrt(x)': The square root of `x'.

   * `exp(x)': The exponential of `x'.

   * `log(x)' or `ln(x)': The natural logarithm of `x'.

   * `log10(x)': Base 10 logarithm of `x'.

   * `sin(x)', `cos(x)', `tan(x)', `cot(x)',   `sec(x)', `csc(x)': The
     sinus, co-sinus, tangent, co-tangent,   secant and co-secant of
     `x'.

   * `asin(x)', `acos(x)', `atan(x)', `acot(x)',   `asec(x)',
     `acsc(x)': The inverse (arc-) sinus, co-sinus, tangent, co-tangent,
      secant and co-secant of `x'.

   * `sinh(x)', `cosh(x)', `tanh(x)', `coth(x)',   `sech(x)',
     `csch(x)': The hyperbolic sinus, co-sinus, tangent, co-tangent,
     secant and co-secant of `x'.

   * `asinh(x)', `acosh(x)', `atanh(x)', `acoth(x)',   `asech(x)',
     `acsch(x)': The inverse hyperbolic sinus, co-sinus, tangent,
     co-tangent,   secant and co-secant of `x'.
   You can also use any of the predefined variables:
   * `pi': 3.141592653589793, what else is there to say?

   * `e': The base of the natural logarithms.

   * `false' or `f' or `no': False in all its flavors. For the
     curious, `false' is defined as 0.

   * `true' or `t' or `yes': The truthful companion of `false'. For the
      curious, `true' is defined as 1.

   Blocks are defined as a collection of values, organised in row and
column format.  The syntax is the following:
     %var
       exp | exp | exp | ...
       exp | exp | exp | ...
       ...
     %
   Rows in a block are separated by a newline, while columns are
separated by the character "|" or by a tab. There may be any number of
lines and any number of columns in a block. Note also that each line
can have a different number of columns.

   If `octopus' tries to read a variable that is not defined in the
`inp' file, it automatically assigns to it a default value. All
variables read are output to the file "`out.oct'". If you are not sure
of what the program is reading, just take a look at it.  Everything
following the character "#" until the end of the line is considered a
comment and is simply cast into oblivion.


File: octopus.info,  Node: Input file options,  Next: External utilities,  Prev: The parser,  Up: Top

Input file options
******************

   `octopus' has quite a few options, that we will subdivide in
different groups.  After the name of the option, its type and default
value (when applicable) are given in parenthesis.

* Menu:

* Generalities::
* Species Block::
* Coordinates Description::
* Mesh::
* States::
* Hamiltonian::
* Exchange and correlation::
* SCF::
* Unoccupied States::
* Time Dependent::
* Geometry optimization::
* Function output for visualization::
* Spectrum calculations::
* Varia::


File: octopus.info,  Node: Generalities,  Next: Species Block,  Prev: Input file options,  Up: Input file options

Generalities
============

* Menu:

* SystemName::
* Dimensions::
* CalculationMode::
* Units::
* UnitsInput::
* UnitsOutput::
* Verbose::
* DebugLevel::


File: octopus.info,  Node: SystemName,  Next: Dimensions,  Prev: Generalities,  Up: Generalities

`SystemName' (string, 'system')
-------------------------------

   A string that identifies the current run. This parameter is used to
build the names of some files generated by `octopus'.


File: octopus.info,  Node: Dimensions,  Next: CalculationMode,  Prev: SystemName,  Up: Generalities

`Dimensions' (integer, 3)
-------------------------

   `octopus' can run in 1, 2 or 3 dimensions, depending on the value of
this variable. Note that not all options may be available in all cases.


File: octopus.info,  Node: CalculationMode,  Next: Units,  Prev: Dimensions,  Up: Generalities

`CalculationMode' (integer, 1)
------------------------------

   It defines the type of simulation to perform. Options are:
   - `gs_start' or `1': Start static calculation.

   - `gs' or `2': Resume static calculation.

   - `unocc_start' or `3': Calculate unoccuppied states.

   - `unocc' or `4': Resume calculation of unoccupied states.

   - `td_start' or `5': Start time-dependent propagation.

   - `td' or `6': Resume time-dependent propagation.

   - `pol_start' or `7': Start static polarizability calculation.

   - `pol' or `8': Resume static polarizability calculation.

   - `geom' or `10': Perform geometry minimization.

   - `phonon' or `11': Calculates the phonon spectrum of the system.

   - `opt_control' or `12': _Optimum control_ mode (experimental).

   - `recipe' or `99': Print out an octopus recipe.


File: octopus.info,  Node: Units,  Next: UnitsInput,  Prev: CalculationMode,  Up: Generalities

`Units' (string, 'a.u')
-----------------------

   Atomic units seem to be the preferred system in the atomic and
molecular physics community (despite the opinion of some of the authors
of this program). Internally, the code works in atommic units. However,
for input or output, some people like using eV for energies and AA for
lengths. This other system of units (the _convenient system_, in words
of Prof. George F. Bertsch), can also be used. See the Frequently Asked
Questions for some more details.  Valid options are:
   - `'a.u'': atomic units

   - `'eVA'': electron-volts/aangstro"m


File: octopus.info,  Node: UnitsInput,  Next: UnitsOutput,  Prev: Units,  Up: Generalities

`UnitsInput' (string, 'a.u.'):
------------------------------

   Same as `Units', but only refers to the values in the input file.
That is, if `UnitsInput = "eVA"', all physical values in the input
files will be considered to be in eV and AA.


File: octopus.info,  Node: UnitsOutput,  Next: Verbose,  Prev: UnitsInput,  Up: Generalities

`UnitsOutput' (string, 'a.u.')
------------------------------

   Same as `Units', but only refers to the values in the output files.
That is, if `UnitsOutput = "eVA"', all physical values in the output
files will be written in eV and AA.


File: octopus.info,  Node: Verbose,  Next: DebugLevel,  Prev: UnitsOutput,  Up: Generalities

`Verbose' (integer, 30)
-----------------------

   Verbosity level of the program. The higher, the more verbose
`octopus' is. Current levels are:
   - `verbose <=  0': Silent mode. No output except fatal errors.

   - `verbose >   0': Warnings only.

   - `verbose >  20': Normal program info.

   - `verbose > 999': Debug mode. Issues a message to standard error
     every time the  program enters an (important) subroutine, and
     prints the time it spend upon return.


File: octopus.info,  Node: DebugLevel,  Prev: Verbose,  Up: Generalities

`DebugLevel' (integer, 3)
-------------------------

   In debug mode (`Verbose > 999'), it restricts the output of
entry/exit subroutine information to the required level.


File: octopus.info,  Node: Species Block,  Next: Coordinates Description,  Prev: Generalities,  Up: Input file options

Species Block
=============

* Menu:

* Species::


File: octopus.info,  Node: Species,  Prev: Species Block,  Up: Species Block

`Species' (block data)
----------------------

   A specie is by definition an ion (nucleus + core electrons) described
through a pseudo-potential, or a model potential.  The format of this
block is different for 1, 2 or 3 dimensions, and can be best understood
through examples.

   * In 1D, or 2D, e.g.
            %Species
              'H'  | 1.0079 | 1 | "-1/sqrt(x^2 + 1)"
            %
     This defines a species labelled '`H'' of weight `1.0079', and
     valence charge `1'. This "valence charge" is used to calculate the
     number of electrons present in the calculation: as many as
     indicated by the valence charges of the species, plus any extra
     charge specified by the user (*note States::). Last field may be
     any user defined potetial - use `x', `r' (and `y' in the 2D case)
     for the position of the electron relative to the species center.
     For example. the potential often used in 1D calculations is the
     soft-Coulomb potential -Z/sqrt(x*x + 1).

   * In 3D, e.g.
            %Species
              'O'       | 15.9994 | 8   | "tm2"  | 1 | 1
              'H'       |  1.0079 | 1   | "hgh"  | 0 | 0
              'jelli01' | 23.2    | 8.0 |  5.0
              'point01' | 32.3    | 2.0
              'usdef'   | 1 | 8 | "1/2*r^2"
            %
     In this case, we have 5 "species" present:
        - Oxygen labelled '`O''. Next number is the atomic mass (in
          atomic mass units), and third field, the atomic number (8, in
          this case).  Afterwards, "tm2" is the flavour of the
          pseudopotential: "tm2" stands for Troullier-Martins. This
          means the pseudopotential will be read from an `O.ascii' or
          `O.vps' file, either in the working directory or in the
          `OCTOPUS-HOME/share/PP/TM2' directory.  Next two numbers are
          the maximum _l_-component of the pseudo-potential to consider
          in the calculation, and the _l_-component to consider as
          local.

        - Hydrogen defined in the same way as Oxygen. In this case,
          however, the flavour is "hgh" standing for
          Hartwigsen-Goedecker-Hutter. Last two numbers are irrelevant.

        - All species whose label starts by 'jelli' are jellium spheres.
          The other parameters are the weight, the nuclear charge, and
          the valence charge of the sphere.

        - All species whose label starts by 'point' are point charges.
          The other parameters are the weight and the nuclear charge. In
          fact, point charges are implemented as _rather small_ jellium
          spheres, with zero valence charge.

        - All species whose label starts by 'usdef' are user defined
          potentials. The second parameter is the mass, whereas the
          third parameter is the 'valence charge', used to calculate
          the number of electrons.  Finally, the potential itself is
          defined by the fourth argument.  Use any of the `x', `y', `z'
          or `r' variables to define the potential.

          Note that additional pseudopotentials can be downloaded from
          the `octopus' homepage
          (http://www.tddft.org/programs/octopus/pseudo.php).



File: octopus.info,  Node: Coordinates Description,  Next: Mesh,  Prev: Species Block,  Up: Input file options

Coordinates Description
=======================

   `octopus' successively tries to read the atomic coordinates from a
PDB file, a XYZ file, or else directly from the `inp' file.

* Menu:

* PDBCoordinates::
* XYZCoordinates::
* Coordinates::
* XYZVelocities::
* Velocities::
* RandomVelocityTemp::


File: octopus.info,  Node: PDBCoordinates,  Next: XYZCoordinates,  Prev: Coordinates Description,  Up: Coordinates Description

`PDBCoordinates' (string, 'coords.pdb')
---------------------------------------

   Tries to read the atomic coordinates from the file `PDBCoordinates'.
The PDB (Protein Data Bank (http://www.rcsb.org/pdb/)) format is quite
complicated, and it goes well beyond the scope of this manual. You can
find a comprehensive description in
`http://www.rcsb.org/pdb/docs/format/pdbguide2.2/guide2.2_frame.html'.
From the plethora of instructions defined in the PDB standard, `octopus'
only reads 2, `ATOM' and `HETATOM'. From these fields, it reads:
   - columns 13-16 : The specie; in fact `octopus' only cares about the
     first letter - 'CA' and 'CB' will both refer to Carbon - so
     elements whose chemical symbol has more than one letter can not be
     represented in this way.  So, if you want to run mercury ('Hg')
     please use one of the other two methods to input the atomic
     coordinates, `XYZCoordinates' or `Coordinates'.

   - columns 18-21 : The residue. If residue is 'QM', the atom is
     treated in Quantum Mechanics, otherwise it is simply treated as an
     external classical point charge. Its charge will be given by
     columns 61-65.

   - columns 31-54 : The Cartesian coordinates. The Fortran format is
     `'(3f8.3)''.

   - columns 61-65 : Classical charge of the atom. The Fortran format is
     `'(f6.2)''.


File: octopus.info,  Node: XYZCoordinates,  Next: Coordinates,  Prev: PDBCoordinates,  Up: Coordinates Description

`XYZCoordinates' (string, 'coords.xyz')
---------------------------------------

   If `PDBCoordinates' is not present, reads the atomic coordinates
from the XYZ file `XYZCoordinates'. The XYZ format is very simple, as
can be seem from this example for the CO molecule (in AA).
     2
     CO molecule in equilibrium
         C  -0.56415   0.0   0.0
         O   0.56415   0.0   0.0
   The first line of the file has an integer indicating the number of
atoms. The second can contain comments that are simply ignored by
`octopus'. Then there follows one line per each atom, containing the
chemical species and the Cartesian coordinates of the atom.


File: octopus.info,  Node: Coordinates,  Next: XYZVelocities,  Prev: XYZCoordinates,  Up: Coordinates Description

`Coordinates' (block data)
--------------------------

   If neither a `XYZCoordinates' nor a `PDBCoordinates' was found,
`octopus' tries to read the coordinates for the atoms from the block
`Coordinates'. The format is quite straightforward:
         %Coordinates
           'C' | -0.56415 | 0.0 | 0.0 | no
           'O' |  0.56415 | 0.0 | 0.0 | no
         %
   The first line defines a Carbon atom at coordinates (`-0.56415',
`0.0', `0.0'), that is _not_ allowed to move during dynamical
simulations. The second line has a similar meaning. This block
obviously defines a Carbon monoxide molecule, if the input units are
AA. Note that in this way it is possible to fix some of the atoms (this
is not possible when specifying the coordinates through a
`PDBCoordinates' or `XYZCoordinates' file). It is always possible to
fix _all_ atoms using the `MoveIons' directive.


File: octopus.info,  Node: XYZVelocities,  Next: Velocities,  Prev: Coordinates,  Up: Coordinates Description

`Velocities' (string, 'velocities.xyz')
---------------------------------------

   `octopus' will try to read the starting velocities of the atoms from
the XYZ file `XYZVelocities'.


File: octopus.info,  Node: Velocities,  Next: RandomVelocityTemp,  Prev: XYZVelocities,  Up: Coordinates Description

`Velocities' (block data)
-------------------------

   If `XYZVelocities' is not present, `octopus' will try to fetch the
initial atomic velocities from this block. If this block is not
present, `octopus' will reset the initial velocities to zero. The
format of this block can be illustrated by this example:
         %Velocities
           'C'  | -1.7 | 0.0 | 0.0
           'O'  |  1.7 | 0.0 | 0.0
         %
   It describes one Carbon and one Oxygen moving at the relative
velocity of `3.4', velocity units.  Note: It is important for the
velocities to maintain the ordering in which the species were defined
in the coordinates specifications.


File: octopus.info,  Node: RandomVelocityTemp,  Prev: Velocities,  Up: Coordinates Description

`RandomVelocityTemp' (double, 0)
--------------------------------

   If this variable is present, `octopus' will assign random velocities
to the atoms following a Bolzmann distribution with temperature
`RandomVelocityTemp'.


File: octopus.info,  Node: Mesh,  Next: States,  Prev: Coordinates Description,  Up: Input file options

Mesh
====

   `octopus' uses a grid in real space to solve the Kohn-Sham equations.
The grid is equally-spaced, but the spacings can be different for each
Cartesian direction. The shape of the simulation region may also be
tuned to suit the geometric configuration of the system.

* Menu:

* BoxShape::
* Radius::
* Lsize::
* ZLength::
* Spacing::
* DerivativesSpace::
* OrderDerivatives::
* DoubleFFTParameter::
* FFTOptimize::


File: octopus.info,  Node: BoxShape,  Next: Radius,  Prev: Mesh,  Up: Mesh

`BoxShape' (integer, sphere)
----------------------------

   It is the shape of the simulation box. The allowed values are:
   - `sphere' or `1': A sphere

   - `cylinder' or `2': A cylinder. The cylinder axis will be in the z
     direction

   - `minimum' or `3': Sum of spheres around each atom.

   - `parallelepiped' or `4': As the name indicates.
   For a 1D calculation, it would obviously always be a 1D "sphere".


File: octopus.info,  Node: Radius,  Next: Lsize,  Prev: BoxShape,  Up: Mesh

`Radius' (double, 20.0 a.u.)
----------------------------

   If `BoxShape != parallelepiped' defines the radius of the spheres or
of the cylinder.


File: octopus.info,  Node: Lsize,  Next: ZLength,  Prev: Radius,  Up: Mesh

`Lsize' (block data)
--------------------

   In case `BoxShape = parallelepiped', this is assumed to be a block
of the form:
         %Lsize
           sizex | sizey | sizez
         %
   where the `size*' are half of the lengths of the box in each
direction.


File: octopus.info,  Node: ZLength,  Next: Spacing,  Prev: Lsize,  Up: Mesh

`XLength' (double, 1.0 a.u.)
----------------------------

   If `BoxShape == cylinder' is half the total length of the cylinder.


File: octopus.info,  Node: Spacing,  Next: DerivativesSpace,  Prev: ZLength,  Up: Mesh

`Spacing' (double, 0.6 a.u.) or (block data)
--------------------------------------------

   If the code is compiled in 1D mode or if `BoxShape != parallelepiped'
defines the (constant) spacing between points in the grid. Otherwise, it
is assumed to be a block of the form:
         %Spacing
           spacingx | spacingy | spacingz
         %


File: octopus.info,  Node: DerivativesSpace,  Next: OrderDerivatives,  Prev: Spacing,  Up: Mesh

`DerivativesSpace' (integer, real_space)
----------------------------------------

   Defines in which space gradients and the Laplacian are calculated.
Allowed values are:
   - `real_space' or `0': Derivatives are calculated in real-space
     using finite differences. The order of the derivative can be set
     with       `OrderDerivatives'.

   - `fourier_space' or `1': Derivatives are calculated in
     reciprocal space. Obviously this case implies cyclic boundary
     conditions,       so be careful.


File: octopus.info,  Node: OrderDerivatives,  Next: DoubleFFTParameter,  Prev: DerivativesSpace,  Up: Mesh

`OrderDerivatives' (integer, 4)
-------------------------------

   If `DerivativesSpace == real_space' use a finite difference
discretisation of this order for the derivatives, that is a
`OrderDerivatives*2 + 1' formula.  See (MISSING ARTICLE) for details.


File: octopus.info,  Node: DoubleFFTParameter,  Next: FFTOptimize,  Prev: OrderDerivatives,  Up: Mesh

`DoubleFFTParameter' (real, 2.0)
--------------------------------

   For solving Poisson equation in Fourier space, and for applying the
local potential in Fourier space, an auxiliary cubic mesh is built.
This mesh will be larger than the circumscribed cube to the usual mesh
by a factor `DoubleFFTParameter'. See the section that refers to
Poisson equation, and to the local potential for details.


File: octopus.info,  Node: FFTOptimize,  Prev: DoubleFFTParameter,  Up: Mesh

`FFTOptimize' (logical, true)
-----------------------------

   Should `octopus' optimize the FFT dimension? In some cases, namely
when using the split-operator, or Suzuki-Trotter propagators, this
option should be turned off.


File: octopus.info,  Node: States,  Next: Hamiltonian,  Prev: Mesh,  Up: Input file options

States
======

* Menu:

* SpinComponents::
* NumberKPoints::
* ExcessCharge::
* ExtraStates::
* Occupations::
* ElectronicTemperature::


File: octopus.info,  Node: SpinComponents,  Next: NumberKPoints,  Prev: States,  Up: States

`SpinComponents' (integer, 1)
-----------------------------

   Defines the spin mode `octopus' will run in. Valid modes are:
   - `unpolarized' or `1': Spin-unpolarised calculation.

   - `polarized' or `2': Spin-polarised calculation (collinear spin).
     This mode will double the number of wave-functions necessary for a
     spin-unpolarised calculation.

   - `non_collinear' or `3': Non-collinear spin. This mode will double
     the number of wave-functions necessary for a spin-unpolarised
     calculation, and each of the wave-functions will be a 2-spinor.


File: octopus.info,  Node: NumberKPoints,  Next: ExcessCharge,  Prev: SpinComponents,  Up: States

`NumberKPoints' (integer, 1)
----------------------------

   If `octopus' was compiled for periodic systems, the number of _k_
points to use in the calculation. If `NumberKPoints == 1', use only the
Gamma point. (Note: current version in fact does not implement this
possibility. Setting this variable to more that 1 may lead to erroneous
results.)


File: octopus.info,  Node: ExcessCharge,  Next: ExtraStates,  Prev: NumberKPoints,  Up: States

`ExcessCharge' (double, 1)
--------------------------

   The net charge of the system. A negative value means that we are
adding electrons, while a positive value means we are taking electrons
from the system.


File: octopus.info,  Node: ExtraStates,  Next: Occupations,  Prev: ExcessCharge,  Up: States

`ExtraStates' (integer, 1)
--------------------------

   How many unoccupied states to use in the ground-state calculation.
Note that this number is unrelated to `CalculationMode == 4'.

