This is octopus.info, produced by makeinfo version 4.5 from
octopus.texi.

INFO-DIR-SECTION Individual utilities
START-INFO-DIR-ENTRY
* octopus: (octopus).           The octopus program.
END-INFO-DIR-ENTRY

This manual is for octopus 1.3, a first principles, electronic
structure, excited states, time-dependent density functional theory
program.

   Copyright (C) 2002, 2003 Miguel A. L. Marques, Alberto Castro and
Angel Rubio

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.1 or any later version published by the Free Software
     Foundation.
   

File: octopus.info,  Node: SCF,  Next: Unoccupied States,  Prev: Exchange and correlation,  Up: Input file options

SCF
---

   The self consistent procedure will stop when the first of the
convergence criteria is fulfilled.
   * `MaximumIter' (integer, 200): Maximum number of SCF iterations.
     `0' means unlimited.

   * `ConvAbsDens' (double, 1e-5): Absolute convergence of the density.
     `0' means do not use this criterion.

   * `ConvRelDens' (double, 0.0): Relative convergence of the density.
     `0' means do not use this criterion.

   * `ConvAbsEnergy' (double, 0.0): Absolute convergence of the
     eigenvalues. `0' means do not use this criterion.

   * `ConvRelEnergy' (double, 0.0): Relative convergence of the
     eigenvalues. `0' means do not use this criterion.

   There are some more variables controlling the SCF cycle:
   * `LCAOStart' (logical, true): Before starting a SCF calculation,
     performs a LCAO calculation. These should provide `octopus' with a
     good set of initial wave-functions, and help the convergence of
     the SCF cycle.  (Up to current version, only a minimal basis set
     used.)

   * `SCFinLCAO' (logical, false): Performs all the SCF cycle
     restricting the calculation to the LCAO subspace.  This may be
     useful for systems with convergence problems (first do a
     calculation within the LCAO subspace, then restart from that point
     for an unrestricted calculation).

   * `EigenSolver' (integer, 0): At each SCF cycle step, a
     diagonalisation of the Hamiltonian is performed.  This variable
     chooses the eigensolver used to diagonalise the Kohn-Sham
     Hamiltonian.  Possible values are:
        - `0': Conjugated Gradients method I.

        - `1': Conjugated Gradients method II.
     Method I should be better. Look up the source to know what the
     differences are.

     In both cases, for the first iterations of the cycle there is no
     need to perform a very precise diagonalisation. Because of this,
     we may define a varying tolerance, so that at the first iteration
     a given small tolerance is achieved, and then this tolerance is
     linearly increased until a given iteration, after which a maximum
     tolerance is always asked.  Next variables take care of this
     process. This possiblity is only available when method 0 is used.

   * `EigenSolverInitTolerance' (double, 1.0e-10): When `EigenSolver ==
     0' this is the initial tolerance for the eigenvectors.

   * `EigenSolverFinalTolerance' (double, 1.0e-14): When `EigenSolver
     == 0' this is the final tolerance for the eigenvectors.

   * `EigenSolverFinalToleranceIteration' (integer, 7): When
     `EigenSolver == 0', determines how many interactions are needed to
     go from `EigenSolverInitTolerance' to `EigenSolverFinalTolerance'.

   * `EigenSolverMaxIter' (integer, 25): When `EigenSolver == 0',
     determines the maximum number of iterations for the eigensolver --
     that is, if this number is reached, the diagonalisation is stopped
     even if the desired tolerance was not achieved.

   * `NumberCG' (integer, 3): When `EigenSolver == 1', determines the
     number of conjugated gradient steps per iteration.

   * `What2Mix' (integer, 0): Selects what should be mixed during the
     SCF cycle. Possible values are:
        - `0': Density

        - `1': Potential

   * `TypeOfMixing' (integer, 2): Selects the mixing procedure to be
     used during the SCF cycle. Possible values are:
        - `0': Linear mixing.

        - `1': Guaranteed-reduction Pulay (GR-Pulay).

        - `2': Broyden mixing.

   * `Mixing' (double, 0.3): Determines the amount of the new
     density/potential which is to be mixed with the old one. Used only
     by linear mixing and Broyden mixing.

   * `MixNumberSteps' (integer, 3): Number of steps used by Broyden
     mixing or GR-Pulay mixing to extrapolate the new density/potential.



File: octopus.info,  Node: Unoccupied States,  Next: Time Dependent,  Prev: SCF,  Up: Input file options

Unoccupied States
-----------------

   These variables are only used in `CalculationMode == 3, 4' (or in 5
and 6 if `TDOccupationalAnalysis == 1').
   * `UnoccNumberStates' (integer, 5):   How many unoccupied states to
     compute.

   * `UnoccMaximumIter' (integer, 200):   Maximum number of iterations
     while calculating the unoccupied states.    Note that these are
     _not_ SCF iterations, for the density and the   Hamiltonian are
     not updated!

   * `UnoccConv' (double, 1e-4):   Absolute convergence in the
     eigenvectors. So don't try to put it too   good or else you won't
     converge.


File: octopus.info,  Node: Time Dependent,  Next: Photo-electron spectrum,  Prev: Unoccupied States,  Up: Input file options

Time Dependent
--------------

   When `CalculationMode = 5,6', `octopus' performs the time propagation
of the electronic orbitals and - if required - of the ionic positions.
This latter task does not pose major algorithmical problems (the usual
Verlet algorithms deal with that task); however the best way to
propagate a Schro"dinger-like equation is still unclear. Due to this
fact, we provide with a rather excessive selection of possibilities for
that purpose. Before describing the set of variables necessary to
specify the way in which the time evolution is to be performed, it is
worth making a brief introduction to the problem.

   We are concerned with a set of Schro"dinger-like equations for the
electronic orbitals:

   i{\partial psi_i \over \partial t} = H(t)\psi_i(t)\,,

   \psi_i(t=0) = \psi_i^0\,.

   Being the equation linear, one may formally define a linear
"evolution" operator, which trasforms the initial vector into the
solution at time T:

   \psi_i(T) = U(T, 0)\psi_i^0

   Moreover, there is a formal exact expression for the evolution
operator:

   \psi_i(T) = T\exp\lbrace -i\!\!\int_0^{T}d\tau H(\tau)\rbrace
\psi_i^0\,.

   where Texp is the time-ordered exponential. If the Hamiltonian
conmutes with itself at different times, we can drop the time-ordering
product, and leave a simple exponential.  If the Hamiltonian is
time-independent, the solution is then simply written as:

   \psi_i(T) = \exp\lbrace -iTH\rbrace \psi_i^0\,.

   Unfortunately, this is not the case in general. We have to find an
algorithm able to cope with time-dependent Hamiltonians, such as the
self-consistent time-dependent Kohn-Sham operator.

   The first step is to perform a time-discretization: the full
propagation between 0 and T is decomposed as:

   U(T,0) = \prod_{i=0}^{N-1}U(t_i+\delta t,t_i)\,,

   where t_0=0, t_N=T, \delta t = T/N. So at each time step we are
dealing with the problem of performing the short-time propagation:

   \psi_i(t+\delta t) = U(t+\delta t, t)\psi_i(t) = T\exp\lbrace
-i\!\!\int_{t}^{t+\delta t}\!\!\!\!\!\!\!\!\!d\tau\,H(\tau)\rbrace
\psi(t)\,.

   In this way, one can monitor the evolution in the interior of [0,t].
In fact, the possibility of monitoring the evolution is generally a
requirement; this requirement imposes a natural restriction on the
maximum size of \delta t: if \omega_\rm max is the maximum frequency
that we want to discern, \delta t should be no larger than \approx
1/\omega_\rm max.  Below this \delta t_\rm max, we are free to choose
\delta t considering performance reasons: Technically, the reason for
the discretization is twofold: the time-dependence of H is alleviated,
and the norm of the exponential argument is reduced (the norm increases
linearly with \delta t).

   Since we cannot drop the time-ordering product, the desired algorithm
cannot be reduced, in principle, to the calculation of the action of
the exponential of an operator over the initial vector.  Some
algorithms tailored to approximate the evolution operator, in fact, do
not even require to peform such operator exponentials.  Most of them,
however, do rely on the calculation of one or more exponentials, such
as the ones used by `octopus'. This is why in principle we need to
specify two different issues: the "evolution method", and the
"exponential method". In other words: we need an algorithm to
approximate the evolution operator U(t+\delta t, t) - which will be
specified by variable `TDEvolutionMethod' - and, if this algorithm
requires it, we will also need an algorithm to approximate the
exponential of a matrix operator \exp\lbrace A\rbrace - which will be
specified by variable `TDExponentialMethod'.

   * `TDMaximumIter' (integer, 1500): Number of time steps in which the
     total integration time is divided; in previous notation, N.

   * `TDTimeStep' (double, 0.07 a.u.): Time-step for the propagation;
     in previous notation, \delta t.

   * `TDExponentialMethod' (integer, 1): Method used to numerically
     calculate the exponential of the Hamiltonian, a core part of the
     full algorithm used to approximate the evolution operator,
     specified through the variable `TDEvolutionMethod', described
     below.

        - `1': N-th order expansion of the exponential.

          \exp (-i\delta t H) \approx \sum_{i=0}^k {(-i\delta
          t)^i\over{i!}} H^i.

          The order k is determined by variable `TDExpOder' (see below).
          Some numerical considerations (by Jeff Giansiracusa and
          George F. Bertsch; see
          `http://www.phys.washington.edu/~bertsch/num3.ps') suggest
          the 4th order as especially suitable and stable.

        - `2': Lanczos approximation.

          Allows for larger time-steps.  However, the larger the
          time-step, the longer the computational time per time-step.
          In certain cases, if the time-step is too large, the code
          will emit a warning whenever it considers that the evolution
          may not be properly proceeding - the Lanczos process did not
          converge. The method consists in a Krylov subspace
          approximation of the action of the exponential (see M.
          Hochbruck and C. Lubich, SIAM J. Numer. Anal. *34*, 1911
          (1997) for details).  Two more variables control the
          performance of the method: the maximum dimension of this
          subspace (controlled by variable `TDExpOrder'), and the
          stopping criterium (controlled by variable `TDLanczosTol').
          The smaller the stopping criterium, the more precisely the
          exponential is calculated, but also the larger the dimension
          of the Arnoldi subspace. If the maximum dimension allowed by
          `TDExpOrder' is not enough to meet the criterium, the
          above-mentioned warning is emitted.

        - `3': Split-operator (SO).

          It is important to distinguish between applying the split
          operator method to calculate the exponential of the
          Hamiltonian at a given time - which is what this variable is
          referring to - from the split operator method as an algorithm
          to approximate the full evolution operator U(t+\delta t, t),
          and which will be described below as one of the possibilities
          of the variable `TDEvolutionMethod'.  The equation that
          describes the split operator scheme is well known:

          \exp (-i \delta t H) \approx \exp (-i \delta t/2 T) \exp (-i
          \delta t V) \exp (-i \delta t/2 T)\,.

          Note that this is a "kinetic referenced SO", since the
          kinetic term is sandwiched in the middle. This is so because
          in `octopus', the states spend most of its time in
          real-space; doing it "potential referenced" would imply 4
          FFTs instead of 2.  This split-operator technique may be used
          in combination with, for example, the exponential midpoint
          rule as a means to approximate the evolution operator.  In
          that case, the potential operator `V' that appears in the
          equation would be calculated at time t+\delta t/2, that is,
          in the middle of the time-step.  However, note that if the
          split-operator method is invoked as a means to approximate
          the evolution operator (`TDEvolutionMethod = 0'), a different
          procedure is taken - it will be described below -, and in
          fact the variable `TDExponentialMethod' has no effect at all.

        - `4': Suzuki-Trotter (ST).

          This is a higher-order SO based algorithm. See O. Sugino and
          Y. Miyamoto, Phys. Rev. B *59*, 2579 (1999). Allows for
          larger time-steps, but requires five times more time.

          The considerations made above for the SO algorithm about the
          distinction between using the method as a means to
          approximate `U(t+\delta t)' or as a means to approximate the
          exponential also apply here. Setting `TDEvolutionMethod = 1'
          enforces the use of the ST as an algorithm to approximate the
          full evolution operator, which is slightly different (see
          below).

        - `5': N-th order Chebyshev expansion.

          In principle, the Chebyshev expansion of the exponential
          represents it more accurately than the canonical expansion
          (method 1). As in the latter case, `TDExpOrder' determines
          the order of the expansion.

          There exists a closed analytical form for the coefficients of
          the exponential in terms of Chebyshev polynomials:

          \exp \left( -i\delta t H \right) = \sum_{k=0}^{\infty}
          (2-\delta_{k0})(-i)^{k} J_k(\delta t) T_k(H),

          where J_k are the Bessel functions of the first kind, and H
          has te be previously scaled to [-1,1].  See H. Tal-Ezer and
          R. Kosloff, J. Chem. Phys. *81*, 3967 (1984); R. Kosloff,
          Annu. Rev. Phys. Chem. *45*, 145 (1994); C. W. Clenshaw, MTAC
          *9*, 118 (1955).


   * `TDExpOrder' (integer, 4): For `TDExponentialMethod' equal `1' or
     `5', the order to which the exponential is expanded. For the
     Lanczos approximation, it is the maximum Lanczos-subspace
     dimension.

   * `TDLanczosTol' (real, 5e-4): An internal tolerance variable for
     the Lanczos method. The smaller, the more precisely the
     exponential is calculated, and also the bigger the dimension of
     the Krylov subspace needed to perform the algorithm. One should
     carefully make sure that this value is not too big, or else the
     evolution will be wrong.

   * `TDEvolutionMethod' (integer, 2): Method used to perform the time
     propagation. Authorised values are: [In the following \psi^n
     represents the wavefunction at time t and \psi^n+1 the
     wavefunction at time t+\delta t.]

        - `0': SPLIT OPERATOR (ST).

          This is one of the most traditional methods. It splits the
          full Hamiltonian into a kinetic and a potential part,
          performing the first in Fourier-space, and the latter in real
          space. The necessary transformations are performed with the
          FFT algorithm.

          \psi^{n+1} = \exp \lbrace - {i \over 2}\delta t T \rbrace
                  \exp \lbrace -i\delta t V^* \rbrace
          \exp \lbrace - {i \over 2}\delta t T \rbrace

          Since those three exponentials may be calculated exactly, one
          does not need to use any of the methods specified by variable
          `TDExponentialMethod' to perform them.

          You may be wondering what is the difference between using
          this ST, or setting `TDExponentialMethod' also to ST, and
          employing the exponential midpoint rule, described below. The
          key point is which Hamiltonian is split, or, more precisely,
          which potential term - since the kinetic term does not depend
          on time and is

        - `1': Suzuki-Trotter (ST).

        - `2': Enforced Time-Reversal Symmetry (ETRS).

          Better time steps. Default.

        - `3': Approximated Enforced Time-Reversal Symmetry (AETRS).

          A modification of previous method to make it faster.  It is
          based on extrapolation of the time-dependent potentials. It
          is faster by about 40%.  (See a printed version of the manual
          for details)

        - `4': Exponential Midpoint Rule (EM).

          In principle, it should  also respect the time-reversal
          symmetry.  (See a printed version of the manual for details)


     (The methods which make use of extrapolation cannot be used safely
     the first two iterations, and so method number 2 is used for those
     iterations).

     This proliferation of methods (which also affects the
     exponentiation of the Hamiltonian, see below) may look as
     excessive; The reason for it is that the propagation algorithm is
     currently a topic of active development. We hope that in the
     future the optimal scheme is clearly identified. In the mean time,
     if you don't feel like testing, use the default choices and make
     sure the time step is small enough.

   * `5': Magnus Expansion (M4).

   * `TDLasers' (block data): Each line of the block describes a laser
     pulse applied to the system.  The syntax is:
              %TDLasers
                polx | poly | polz | A0 | omega0 | envelope | tau0 | t0
              %
     where `pol' is the (complex) polarisation of the laser field, `A0'
     the amplitude, `envelope' the envelope function, `t0' the middle
     (maximum) of the pulse and `omega0' the frequency of the pulse.
     The meaning of `tau0' depends on the envelope function.  The
     possible values for `envelope' are:

        - `1': Gaussian envelope. `tau0' is the standard deviation of
          the pulse.

        - `2': Cosinoidal envelope. `tau0' is half the total length of
          the pulse.

        - `3': Ramp. In this case there is an extra parameter `tau1'.
          `tau0' is the length of the constant part of the ramp, and
          `tau1' is the raising (decaying) time. `tau1' should be an
          extra field after `t0'.

        - `10': Shape is read from a file.

     If `envelope=10', the `t0' parameter is substituted by a string
     that determines the name of the file. The format of this file
     should be three columns of real numbers: time, field and phase.
     Atomic units are assumed. The values for the laser field that the
     program will use are interpolated / extrapolated from this
     numerically defined function.

   * `TDGauge' (integer, 0): In which gauge to treat the laser. Options
     are:
        - `1': Length gauge.

        - `2': Velocity gauge.

   * `TDDeltaStrength' (double, 0.0 a.u.)  When no laser is applied, a
     delta (in time) electric field with strength `TDDeltaStrength' is
     applied. This is used to calculate the linear optical spectra.

   * `TDPolarization' (block data) The (real) polarisation of the delta
     electric field. The format of the block is:
              %TDPolarization
                polx | poly | polz
              %
     In order to calculate dichroism the polarisation has to be
     generalized to complex. Also some input/output and the
     `strength-function' utility have to be changed. It is a nice
     little project if someone is interested in getting into `octopus'.

   * `TDDipoleLmax' (integer , 1): Maximum multi-pole of the density
     output to the file `td.general/multipoles' during a time-dependent
     simulation.

   * `TDOutputMultipoles' (logical, true): If true, outputs the
     multipole moments of the density to the file
     `td.general/projections'.  This is required to, e.g., calculate
     optical absorption spectra of finite systems.

   * `TDOutputCoordinates' (logical, `MoveIons' > 0 ): If true (and if
     the atoms are allowed to move), outputs the coordinates,
     velocities, and forces of the atoms to the the file
     `td.general/coordinates'.

   * `TDOutputGSProjection' (logical, false): If true, outputs the
     projection of the time-dependent Kohn-Sham Slater determinant onto
     the ground-state to the file `td.general/gs_projection'. As the
     calculation of the projection is fairly heavy, this is only done
     every `OutputEvery' iterations.

   * `TDOutputAcceleration' (logical, false): When _true_ outputs the
     acceleration, calculated from Ehrenfest theorem, in the file
     `td.general/acceleration'. This file can then be processed by the
     utility "hs-from-acc" in order to obtain the harmonic spectrum.

   * `TDOutputLaser' (logical, true): If `true', `octopus' outputs the
     laser field to the file "`td.general/laser'".

   * `TDOutputElEnergy' (logical, false): If `true', `octopus' outputs
     the different components of the electronic energy to the file
     `td.general/el_energy'.

   * `TDOutputOccAnalysis' (logical, false): If true, outputs the
     projections of the time-dependent Kohn-Sham wave-functions onto
     the static (zero time) wave-functions to the file
     `td.general/projections.XXX'.

   * `MoveIons' (integer, 0): What kind of simulation to perform.
     Possible values are:
        - `0': Do not move the ions.

        - `3': Newtonian dynamics using Verlet.

        - `4': Newtonian dynamics using velocity Verlet.

   * `AbsorbingBoundaries' (integer, 0): To improve the quality of the
     spectra by avoiding the formation of standing density waves, one
     can make the boundaries of the simulation box absorbing. The
     possible values for this parameter are:
        - `0': No absorbing boundaries.

        - `1': A sin^2 imaginary potential is added at the boundaries.

        - `2': A mask is applied to the wave-functions at the
          boundaries.

   * `ABWidth' (real, 0.4 a.u.): Width of the region used to apply the
     absorbing boundaries.

   * `ABHeight' (real, -0.2 a.u.): When `AbsorbingBoundaries == 1', is
     the height of the imaginary potential.



File: octopus.info,  Node: Photo-electron spectrum,  Next: Geometry optimization,  Prev: Time Dependent,  Up: Input file options

Photo-electron spectrum
-----------------------

   * `CalcPES_rc' (logical, false):   If `true', store the wave
     functions in specific points in order to calculate the
     photo-electron spectrum in a point far in the box as proposed in
     A. Pohl, P.-G. Reinhard, and E. Suraud Phys. Rev. Lett. *84*, 5090
     (2000).

   * `PES_rc_points' (block data):   List of points where to calculate
     the photo-electron spectrum a la Suraud.    The exact syntax is:
              %TDPES_rc_points
                x1 | y1 | z1
              %

   * `CalcPES_mask' (logical, false)   If `true', calculate the
     photo-electron spectrum using the mask method   (M. Marques, D.
     Varsano, H. Appel, E.K.U. Gross and A. Rubio to be submitted).
     In order for this to work, masking boundaries are necessary
     (`AbsorbingBoundaries == 2').



File: octopus.info,  Node: Geometry optimization,  Next: Function output for visualization,  Prev: Photo-electron spectrum,  Up: Input file options

Geometry optimization
---------------------

   * `GOMethod' (integer, 1)   Method by which the minimization is
     performed. The only possible value is   `1' (simple steepest
     descent).

   * `GOTolerance' (real, 0.0001)   Convergence criterium to stop the
     minimization. In units of force; minimization   is stopped when
     all forces on ions are smaller.

   * `GOMaxIter' (integer, 200)   Even if previous convergence
     criterium is not satisfied, minimization will stop   after this
     number of iterations.

   * `GOStep' (double, 0.5)   Initial step for the geometry optimizer.



File: octopus.info,  Node: Function output for visualization,  Next: Spectrum calculations,  Prev: Geometry optimization,  Up: Input file options

Function output for visualization
---------------------------------

   Every given number of time iterations, or after ground-state
calculations, some of the functions that characterise the system may be
written to disk so that they may be analized. Files are written within
"static" output directory after the self-consistent field, or within
"td.x" directories, during evolution, where "x" stands for the
iteration number at which each write is done.  Note that if you wish to
plot any function (`OutputKSPotential = yes', etc.), at least one of
the output formats should be enabled (`OutputPlaneX = yes', `OutputDX =
yes', `OutputNETCDF = yes', etc.). [This is not necessary if you wish
to plot the geometry (`OutputGeometry = yes')]. Note further that the
data written by `OutputAxisX', `OutputPlaneX' etc. has always the
(side) length of the longest axis; this is independent from the  chosen
geometry. Data points which are inexistent in the actual geometry have
the value zero in those files.

   * `OutputKSPotential' (logical, false)  Prints out Kohn-Sham
     potential, separated by parts. File names would be "v0" for  the
     local part, "vc" for the classical potential (if it exists), "vh"
     for the  Hartree potential, and "vxc-x" for each of the exchange
     and correlation potentials  of a give spin channel, where "x"
     stands for the spin channel.

   * `OutputDensity' (logical, false)  Prints out the density. The
     output file is called "density-i", where "i" stands for  the spin
     channel.

   * `OutputWfs' (logical, false)  Prints out wave-functions. Which
     wavefunctions are to be printed is specified  by the variable
     `OutputWfsNumber' - see below. The output file is called
     "wf-k-p-i", where k stands for the _k_ number, p for the state, and
     i for the spin channel.

   * `OutputWfsNumber' (string, "1-1024")   Which wavefunctions to
     print, in list form, i.e., "1-5" to print the first   five states,
     "2,3" to print the second and the third state, etc.

   * `OutputELF' (logical, false)   Prints out the electron
     localization function, ELF. The output file is called   "elf-i",
     where i stands for the spin channel.

   * `OutputGeometry' (logical, false):   If true `octopus' outputs a
     XYZ file called   "geometry.xyz" containing the coordinates of the
     atoms   treated within Quantum Mechanics. If point charges were
     defined   in the PDB file (see `PDBCoordinates'), they will be
     output   in the file "geometry_classical.xyz".


   How are they printed? This is controlled by the next set of
variables:

   * `OutputAxisX' (logical, false)   The values of the function on the
     x axis are printed. The string ".y=0,z=0" is appended   to
     previous file names.

   * `OutputAxisY' (logical, false)   The values of the function on the
     y axis are printed. The string ".x=0,z=0" is appended   to
     previous file names.

   * `OutputAxisZ' (logical, false)   The values of the function on the
     z axis are printed. The string ".x=0,y=0" is appended   to
     previous file names.

   * `OutputPlaneX' (logical, false) A plane slice at x=0 is printed.
     The string ".x=0" is appended to previous file names.

   * `OutputPlaneY' (logical, false) A plane slice at y=0 is printed.
     The string ".y=0" is appended to previous file names.

   * `OutputPlaneZ' (logical, false) A plane slice at y=0 is printed.
     The string ".z=0" is appended to previous file names.

   * `OutputDX' (logical, false) For printing all the three dimensional
     information, the open source program visualization tool OpenDX
     (`http://www.opendx.org/') is used. The string ".dx" is appended
     to previous file names.  *Note wf.net::.

   * `OutputNETCDF' (logical, false) Outputs in NetCDF
     (`http://www.unidata.ucar.edu/packages/netcdf/') format. This file
     can then be read, for example, by OpenDX. The string ".ncdf" is
     appended to previous file names.


   The output is saved when the iteration number is a multiple of the
`OutputEvery' variable.

   * `OutputEvery' (integer, 1000)


File: octopus.info,  Node: Spectrum calculations,  Next: Varia,  Prev: Function output for visualization,  Up: Input file options

Spectrum calculations
---------------------

   Once `octopus' has been run, results must be analyzed somehow. The
most common thing is to Fourier-transform something to calculate
spectra. This may be done through some utilities (`strength-function',
`hs-from-mult', `hs-from-acc' which are described in section "External
utilities." Common options read by these utilities are:
   * `SpecTransformMode' (string, 'sin')   What kind of Fourier
     transform is calculated. 'sin' and 'cos' are the valid options,
     with obvious meanings.

   * `SpecDampMode' (string, 'exp')   A damping function may be applied
     to the input fuction before processing the Fourier   transform.
     This function may be an exponential or a polynomial: "exp" or
     "pol". If   this variable is not present or has any other value,
     no damping function is applied.

   * `SpecDampFactor' (real, 0.0)   If `SpecDampMode' is set to "exp",
     the damping parameter of the exponential   is fixed through this
     variable.

   * `SpecStartTime' (real, 0.0)   Processing is done for the given
     function in a time-window that starts at the   value of this
     variable.

   * `SpecEndTime' (real, -1.0)   Processing is done for the given
     function in a time-window that ends at the   value of this
     variable.

   * `SpecEnergyStep' (real, 0.05)   Sampling rate for the spectrum.

   * `SpecMinEnergy' (real, 0.0)   The Fourier transform is calculated
     for energies bigger than this value.

   * `SpecMaxEnergy' (real, 20.0)   The Fourier transform is calculated
     for energies smaller than this value.

   * `HSPolarization' (string, 'z')   For the utilities `hs-from-acc',
     and `hs-from-mult', the polarization   of the laser pulse must be
     specified. Valid values are "x", "y" and "z" for   lasers linearly
     polarized along the respective axis, or "+" or "-" for lasers
     circularly polarized. See the description of `hs-from-acc' and
     `hs-from-mult'   for more details.



File: octopus.info,  Node: Varia,  Prev: Spectrum calculations,  Up: Input file options

Varia
-----

   * `PoissonSolver' (integer, 3):   In 3D defines which method to use
     in order to solve the Poisson equation.    Allowed values are:
        - `1': Conjugated gradient method.

        - `3': FFTs with spherical cutoff.
       The value of variable `DoubleFFTParameter' is used in case `3'
     method   is used.

   * `POLStaticField' (double, 0.001 a.u.):   Magnitude of the static
     field used to calculate the static polarizability   in
     `CalculationMode = 7, 8'.

   * `Displacement' (double, 0.01 a.u.):   When calculating phonon
     properties (`CalculationMode = 11') `Displacement'   controls how
     much the atoms are to be moved in order to calculate the dynamical
     matrix.



File: octopus.info,  Node: External utilities,  Next: Examples,  Prev: The input file,  Up: Top

External utilities
******************

   A few small programs are generated along with `octopus', for the
purpose of post-processing the generated information. These utilities
should all be run from the directory where `octopus' was run, so that
it may see the `inp' file, and the directories created by it.

* Menu:

* strength-function::
* hs-from-mult::
* hs-from-acc::
* nbo2xyz::
* excitations::
* broad::
* make_st::
* choose_st::
* wf.net::


File: octopus.info,  Node: strength-function,  Next: hs-from-mult,  Prev: External utilities,  Up: External utilities

`strength-function'
===================

   This utility generates the dipole strength function of the given
system.  Its main input is the `td.general/multipoles' file. Output is
written to a file called `spectrum'. This file is made of two columns:
energy (in eV or a.u., depending on the units specified in `inp'), and
dipole strength function (in 1/eV, or 1/a.u., idem).

   In the `inp' file, the user may set the `SpecTransformMode' - this
should be set to "sin" for proper use -, the `SpecDampMode' -
recommended value is "pol", which ensures fulfilling of the N-sum rule,
the `SpecStartTime', the `SpecEndTime', the `SpecEnergyStep', the
`SpecMinEnergy' and the `SpecMaxEnergy'.


File: octopus.info,  Node: hs-from-mult,  Next: hs-from-acc,  Prev: strength-function,  Up: External utilities

`hs-from-acc'
=============

   Calculates the harmonic spectrum, out of the acceleration file. To
do.


File: octopus.info,  Node: hs-from-acc,  Next: nbo2xyz,  Prev: hs-from-mult,  Up: External utilities

`hs-from-mult'
==============

   Calculates the harmonic spectrum, out of the multipoles file. To do.


File: octopus.info,  Node: nbo2xyz,  Next: excitations,  Prev: hs-from-acc,  Up: External utilities

`nbo2xyz'
=========

   Reads out the `td.general/coordinates' file, and makes a movie in
XYZ format. To do.


File: octopus.info,  Node: excitations,  Next: broad,  Prev: nbo2xyz,  Up: External utilities

`excitations'
=============

   Calculates the excitation spectrum within linear response. This
utility can output just the difference of eigenvalues by setting
`LinEigenvalues', the excitations using M. Petersilka formula
(`LinPetersilka'), or M. Casida (`LinCasida'). This utility requires
that a calculation of unoccupied states (`CalculationMode' = 3, 4) has
been done before, and it outputs the results to the sub-directory
"linear".


File: octopus.info,  Node: broad,  Next: make_st,  Prev: excitations,  Up: External utilities

`broad'
=======

   Generates a spectrum by broadening the excitations obtained by the
`excitations' utility. The parameters of the spectrum can be set using
the variables `LinBroadening', `MinEnergy', `MaxEnergy', and
`EnergyStep'.


File: octopus.info,  Node: make_st,  Next: choose_st,  Prev: broad,  Up: External utilities

`make_st'
=========

   `make_st' reads `tmp/restart.static' and replaces some of the
Kohn-Sham states by Gaussians wave packets. The states which should be
replaced are given in the `%MakeStates' section in the `inp' file and
written to `tmp/restart.static.new'. (You probably want to copy that
file to `tmp/restart.static' and use then `CalculationMode=5' or `6'.)

     %MakeStates
       ik | ist | idim | type | sigma | x0 | k
     %

   The first values stand for

   * ik: The k point (or the spin, if `spin-components=2') of the state

   * ist: The state to be replaced

   * idim: The component of the state (if the wave functions have more
     than one component, i.e. when `spin-components=3' is used).

   * The type of the wave packet; currently only `1' (Gaussian) is
     available

   The next items depend on the type chosen.  For a Gaussian wave
packet, defined as

   psi(x) = 1/sigma sqrt(1/2pi) exp(ik(x-x0)) exp(-(x-x0)^2/(2
sigma^2)),

   they are:

   * \sigma the width of the Gaussian

   * k: the *k* vector. In 3D use `k1|k2|k3'.

   * x_0: the coordinate where the Gaussian is initially centred. In 3D
     use `x01|x02|x03'.


File: octopus.info,  Node: choose_st,  Next: wf.net,  Prev: make_st,  Up: External utilities

`choose_st'
===========

   `choose_st' is used to choose the states used for optimum control
(`CalculationMode=12'). You probably want to calculate unoccuppied
states (`CalculationMode=12') first since `choose_st' reads
`tmp/restart.static' and writes the choosen states to the `opt-control'
sub-directory. The following parameters are read from the `inp'ut file:

   * `ChooseStates' (integer, 1-4024):   The states which should be
     written.

   * `ChooseStatesFilename' (string, 'wf.initial'):   The file name to
     which the state(s) should be written.    For optimum control you
     only need 'wf.initial' and 'wf.final'.


File: octopus.info,  Node: wf.net,  Prev: choose_st,  Up: External utilities

`wf.net'
========

   This is an OpenDX network, aimed at the visualization of
wave-functions.  To be able to use it, you need to have properly
installed the OpenDX program (get it at opendx.org), as well as the
Chemistry extensions obtainable at the Cornell Theory Center
(http://www.tc.cornell.edu/Services/Vis/dx/index.asp).  Once these are
working, you may follow a small tutorial on `wf.net' by following next
steps:

   o Place in a directory the program wf.net, the (needed) auxiliary
     file wf.cfg, and the sample inp file that can all be found in
     `OCTOPUS-HOME'/util.

   o Run `octopus'. The inp file used prescribes the calculation of the
     C atom in its ground state, in spin-polarized mode. It also
     prescribes that the wave-functions should be written in "dx"
     format. At the end, these should be written in subdirectory
     "static": wf-00x-00y-1.dx, where x runs from 1 to 2 (spin quantum
     number) and y runs from 1 to 4 (wave-function index).

   o Run the OpenDX program. Click on "Run Visual Programs" on the DX
     main menu, and select the program `wf.net'. The program will be
     executed, and several windows should open. One of them should be
     called "Application Comment". It contains a small tutorial. Follow
     it from now on.



File: octopus.info,  Node: Examples,  Next: Options Index,  Prev: External utilities,  Up: Top

Examples
********

* Menu:

* Hello world::
* Benzene::


File: octopus.info,  Node: Hello world,  Next: Benzene,  Prev: Examples,  Up: Examples

Hello world
-----------

   As a first example, we will take a sodium atom.  With your favourite
text editor, create the following input "inp".
       SystemName = 'Na'
       CalculationMode = 1
       %Species
         'Na' | 22.989768 | 11 | "tm2" | 0 | 0
       %
       %Coordinates
         'Na' | 0.0 | 0.0 | 0.0 | no
       %
       Radius = 12.0
       Spacing = .6
       TypeOfMixing = 2

   This input file should be essentially self-explanatory.  Note that a
Troullier-Martins pseudopotential file ("Na.vps", or "Na.ascii") should
be accesible to the program. A sample "Na.ascii" may be found in
`OCTOPUS-HOME/share/PP/TM2'. If `octopus' was installed (`make install'
was issued after `make'), there should be no need to do anything - the
program should find it. Otherwise, you may as well place it in the
working directory.  Then run `octopus' - for example, do `octopus > out
', so that the output is stored in "out" file. If everything goes OK,
"out" should look like (1):
                         Running octopus, version 1.1
                  (build time - Fri Mar 14 14:23:49 CET 2003)
     
     Info: Calculation started on 2003/03/17 at 03:49:56
     Info: Reading pseudopotential from file:
           '/home/marques/share/octopus/PP/TM2/Na.ascii'
           Calculating atomic pseudo-eigenfunctions for specie Na....
           Done.
     Info: l =  0 component used as local potential
       Type = sphere           Radius [b] =  12.000
       Spacing [b] = ( 0.600, 0.600, 0.600)    volume/point [b^3] =  0.21600
       # inner mesh =  33401   # outer mesh =  18896
     Info: Derivatives calculated in real-space
     Info: Local Potential in Reciprocal Space.
     Info: FFTs used in a double box (for poisson | local potential)
           box size = (  81,  81,  81)
           alpha =      2.00000
     Info: Using FFTs to solve poisson equation with spherical cutoff.
     Info: Exchange and correlation
           Exchange    family    : LDA
                       functional: non-relativistic
           Correlation family    : LDA
                       functional: Perdew-Zunger
     Info: Allocating rpsi.
     Info: Random generating starting wavefunctions.
     Info: Unnormalized total charge =      0.998807
     Info: Renormalized total charge =      1.000000
     Info: Setting up Hamiltonian.
     Info: Performing LCAO calculation.
     Info: LCAO basis dimension:      1
           (not considering spin or k-points)
     Eigenvalues [H]
        #   Eigenvalue    Occupation      Error (1)
        1    -0.102098       1.000000
     Info: SCF using real wavefunctions.
     Info: Broyden mixing used. It can (i) boost your convergence,
           (ii) do nothing special, or (iii) totally screw up the run.
           Good luck!
     Info: Converged =     0
     Eigenvalues [H]
        #   Eigenvalue    Occupation      Error (1)
        1    -0.102975       1.000000      (2.8E-02)
     Info: iter =    1 abs_dens = 0.53E-03 abs_ener = 0.60E+00
     
     Info: Converged =     0
     Eigenvalues [H]
        #   Eigenvalue    Occupation      Error (1)
        1    -0.102477       1.000000      (1.4E-03)
     Info: iter =    2 abs_dens = 0.43E-03 abs_ener = 0.65E-05
     
     Info: Converged =     1
     Eigenvalues [H]
        #   Eigenvalue    Occupation      Error (1)
        1    -0.102419       1.000000      (5.1E-04)
     Info: iter =    3 abs_dens = 0.39E-04 abs_ener = 0.20E-06
     
     Info: Converged =     1
     Eigenvalues [H]
        #   Eigenvalue    Occupation      Error (1)
        1    -0.102436       1.000000      (8.5E-05)
     Info: iter =    4 abs_dens = 0.24E-04 abs_ener = 0.52E-08
     
     Info: Converged =     1
     Eigenvalues [H]
        #   Eigenvalue    Occupation      Error (1)
        1    -0.102437       1.000000      (1.5E-06)
     Info: iter =    5 abs_dens = 0.14E-05 abs_ener = 0.36E-10
     
     Info: SCF converged in    5 iterations
     Info: Deallocating rpsi.
     Info: Calculation ended on 2003/03/17 at 03:50:04
   Take now a look at the working directory. It should include the
following files:
     -rw-rw-r--    1 user  group       177 Jul 10 12:29 inp
     -rw-rw-r--    1 user  group      4186 Jul 10 12:35 out
     -rw-rw-r--    1 user  group      1626 Jul 10 12:35 out.oct
     drwxrwxr-x    2 user  group      4096 Jul 10 12:35 static
     drwxrwxr-x    2 user  group      4096 Jul 10 12:35 tmp

   Besides the initial file (`inp') and the `out' file, two new
directories appear. In `static', you will find the file `info', with
information about the static calculation (it should be hopefully
self-explanatory, otherwise please complain to the authors).  In `tmp',
you will find the `restart.static', a binary file containg restart
information about the ground-state, which is used if, for example, you
want to start a time-dependent calculation afterwards.  Finally, you
can safely ignore `out.oct': it is an output from the liboct library,
irrelevant for what concerns physics ;).

   *Exercises*:
   * Study how the total energy and eigenvalue of the sodium atom
     improve   with the mesh spacing.

   * Calculate the static polarizability of the sodium atom
     (`CalculationMode = 7').    Two new files will be generated:
     `restart.pol' that can be used to resume   the polarizability
     calculation, and `Na.pol' that contains the static polarizability
     tensor. Note that this calculation overwrites
     `tmp/restart.static', so that   what now is there is the ground
     state for the system _with_ an external static   electrical field
     applied. Delete it since it is useless.

   * Calculate a few unoccupied states (`CalculationMode = 3'). The
     eigenspectrum   will be in the file `eigenvalues'. Why don't we
     find a Rydberg series in the   eigenspectrum?

   * Repeat the previous calculation with PBE, LB94, and exact exchange.
      Don't forget to *move* the file `tmp/restart.static' when
     switching   between exchange-correlation functionals.

   * Perform a time-dependent evolution (`CalculationMode = 5'), to
     calculate   the optical spectrum of the Na atom. Use a
     `TDDeltaStrength = 0.05', polarised   in the `x' direction. The
     multipole moments of the density are output to   the file
     `td.general/multipoles'. You can process this file with the utility
      `strength-function' to obtain the optical spectrum.    If you
     have computer time to waste, re-run the time-dependent
     simulation for some other xc choices.


   ---------- Footnotes ----------

   (1) Before this output, a beautiful octopus ascii-art picture may be
printed...


File: octopus.info,  Node: Benzene,  Prev: Hello world,  Up: Examples

Benzene
-------

   Well, the sodium atom is a bit too trivial. Let's try something
harder: benzene.  you will just need the geometry for benzene to be
able to play. Here it is (in AA):
      C  0.000  1.396  0.000
      C  1.209  0.698  0.000
      C  1.209 -0.698  0.000
      C  0.000 -1.396  0.000
      C -1.209 -0.698  0.000
      C -1.209  0.698  0.000
      H  0.000  2.479  0.000
      H  2.147  1.240  0.000
      H  2.147 -1.240  0.000
      H  0.000 -2.479  0.000
      H -2.147 -1.240  0.000
      H -2.147  1.240  0.000

   Follow now the steps of the previous example. Carbon and Hydrogen
have a much harder pseudo-potential than Sodium, so you will probably
have to use a tighter mesh. It also takes much more time...

