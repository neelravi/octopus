This is octopus.info, produced by makeinfo version 4.4 from
octopus.texi.

INFO-DIR-SECTION Individual utilities
START-INFO-DIR-ENTRY
* octopus: (octopus).           The octopus program.
END-INFO-DIR-ENTRY

This manual is for octopus 1.3, a first principles, electronic
structure, excited states, time-dependent density functional theory
program.

   Copyright (C) 2002, 2003 Miguel A. L. Marques, Alberto Castro and
Angel Rubio

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.1 or any later version published by the Free Software
     Foundation.
   

File: octopus.info,  Node: Occupations,  Next: ElectronicTemperature,  Prev: ExtraStates,  Up: States

`Occupations' (block data)
--------------------------

   The occupation numbers of the orbitals can be fixed through the use
of this variable. For example:
         %Occupations
           2.0 | 2.0 | 2.0 | 2.0 | 2.0
         %
   would fix the occupations of the five states to `2.0'. There must be
as many columns as states in the calculation. If `SpinComponents == 2'
this block should contain two lines, one for each spin channel.  This
variable is very useful when dealing with highly symmetric small systems
(like an open shell atom), for it allows us to fix the occupation
numbers of degenerate states in order to help `octopus' to converge.
This is to be used in conjuction with `ExtraStates'. For example, to
calculate the carbon atom, one would do:
       ExtraStates=2
       %Occupations
           2 | 2/3 | 2/3 | 2/3
         %


File: octopus.info,  Node: ElectronicTemperature,  Prev: Occupations,  Up: States

`ElectronicTemperature' (double, 0.0)
-------------------------------------

   If `Occupations' is not set, `ElectronicTemperature' is the
temperature in the Fermi-Dirac function used to distribute the electrons
among the existing states.


File: octopus.info,  Node: Hamiltonian,  Next: Exchange and correlation,  Prev: States,  Up: Input file options

Hamiltonian
===========

* Menu:

* NonInteractingElectrons::
* ClassicPotential::
* LocalPotentialSpace::
* RelativisticCorrection::


File: octopus.info,  Node: NonInteractingElectrons,  Next: ClassicPotential,  Prev: Hamiltonian,  Up: Hamiltonian

`NonInteractingElectrons' (logical, false)
------------------------------------------

   If `true', treat the electrons as non-interacting, i.e. neglect both
Hartree and exchange-correlation contributions to the Kohn-Sham
potential.  A probable choice for one-electron problems.


File: octopus.info,  Node: ClassicPotential,  Next: LocalPotentialSpace,  Prev: NonInteractingElectrons,  Up: Hamiltonian

`ClassicPotential' (logical, false)
-----------------------------------

   If `true', add to the external potential the potential generated by
the point charges read from the PDB input (see `PBDCoordinates').


File: octopus.info,  Node: LocalPotentialSpace,  Next: RelativisticCorrection,  Prev: ClassicPotential,  Up: Hamiltonian

`LocalPotentialSpace' (integer, fourier_space)
----------------------------------------------

   If `fourier_space', generate the local part of the pseudo-potential
in Fourier space; Otherwise do it directly in real space. The auxiliary
box defined via the `DoubleFFTParameter' is used for this purpose.


File: octopus.info,  Node: RelativisticCorrection,  Prev: LocalPotentialSpace,  Up: Hamiltonian

`RelativisticCorrection' (integer, 0)
-------------------------------------

   The default value means that _no_ relativistic correction is used. To
include spin-orbit coupling turn `RelativisticCorrection' to 1 (this
will only work when using an executable compiled for complex
wave-functions.)


File: octopus.info,  Node: Exchange and correlation,  Next: SCF,  Prev: Hamiltonian,  Up: Input file options

Exchange and correlation
========================

   The exchange-correlation functional is controlled by the parameters
`XFunctional', and `CFunctional'.  The possible values are:

* Menu:

* XFunctional::
* CFunctional::


File: octopus.info,  Node: XFunctional,  Next: CFunctional,  Prev: Exchange and correlation,  Up: Exchange and correlation

`XFunctional' (string, 'LDA')
-----------------------------

   * `XFunctional == 'ZER'': No exchange.

   * `XFunctional == 'LDA'': Local density approximation.

   * `XFunctional == 'RLDA'': Relativistic LDA.

   * `XFunctional == 'PBE'':  J.P.Perdew, K.Burke and M.Ernzerhof,
     PRL *77*, 3865 (1996).

   * `XFunctional == 'RPBE'': PBE with some relativistic corrections.

   * `XFunctional == 'LB94'': van Leeuwen and Baerends functional.

   * `XFunctional == 'EXX'': Exact exchange functional in the KLI
     approximation.

   * `XFunctional == 'SIC'': Self interaction corrected LDA in the KLI
     approximation.


File: octopus.info,  Node: CFunctional,  Prev: XFunctional,  Up: Exchange and correlation

`CFunctional' (string, 'PZ81')
------------------------------

   * `CFunctional == 'ZER'': No correlation.

   * `CFunctional ==   'PZ81'':  Perdew and Zunger,       PRB *23*,
     5075 (1981).

   * `CFunctional == 'PW92'': J.P.Perdew and Y.Wang,       PRB *45*,
     13244 (1992).

   * `CFunctional == 'PBE'': J.P.Perdew, K.Burke and M.Ernzerhof,
     PRL *77*, 3865 (1996).

   * `CFunctional == 'SIC'': Self interaction corrected LDA in the KLI
     approximation.


File: octopus.info,  Node: SCF,  Next: Unoccupied States,  Prev: Exchange and correlation,  Up: Input file options

SCF
===

   The self consistent procedure will stop when the first of the
convergence criteria is fulfilled.

* Menu:

* MaximumIter::
* ConvAbsDens::
* ConvRelDens::
* ConvAbsEnergy::
* ConvRelEnergy::
* LCAOStart::
* SCFinLCAO::
* EigenSolver::
* EigenSolverInitTolerance::
* EigenSolverFinalTolerance::
* EigenSolverFinalToleranceIteration::
* EigenSolverMaxIter::
* What2Mix::
* TypeOfMixing::
* Mixing::
* MixNumberSteps::


File: octopus.info,  Node: MaximumIter,  Next: ConvAbsDens,  Prev: SCF,  Up: SCF

`MaximumIter' (integer, 200)
----------------------------

   Maximum number of SCF iterations. `0' means unlimited.


File: octopus.info,  Node: ConvAbsDens,  Next: ConvRelDens,  Prev: MaximumIter,  Up: SCF

`ConvAbsDens' (double, 1e-5)
----------------------------

   Absolute convergence of the density. `0' means do not use this
criterion.


File: octopus.info,  Node: ConvRelDens,  Next: ConvAbsEnergy,  Prev: ConvAbsDens,  Up: SCF

`ConvRelDens' (double, 0.0)
---------------------------

   Relative convergence of the density. `0' means do not use this
criterion.


File: octopus.info,  Node: ConvAbsEnergy,  Next: ConvRelEnergy,  Prev: ConvRelDens,  Up: SCF

`ConvAbsEnergy' (double, 0.0)
-----------------------------

   Absolute convergence of the eigenvalues. `0' means do not use this
criterion.


File: octopus.info,  Node: ConvRelEnergy,  Next: LCAOStart,  Prev: ConvAbsEnergy,  Up: SCF

`ConvRelEnergy' (double, 0.0)
-----------------------------

   Relative convergence of the eigenvalues. `0' means do not use this
criterion.


File: octopus.info,  Node: LCAOStart,  Next: SCFinLCAO,  Prev: ConvRelEnergy,  Up: SCF

`LCAOStart' (logical, true)
---------------------------

   Before starting a SCF calculation, performs a LCAO calculation.
These should provide `octopus' with a good set of initial
wave-functions, and help the convergence of the SCF cycle.  (Up to
current version, only a minimal basis set used.)


File: octopus.info,  Node: SCFinLCAO,  Next: EigenSolver,  Prev: LCAOStart,  Up: SCF

`SCFinLCAO' (logical, false)
----------------------------

   Performs all the SCF cycle restricting the calculation to the LCAO
subspace.  This may be useful for systems with convergence problems
(first do a calculation within the LCAO subspace, then restart from
that point for an unrestricted calculation).


File: octopus.info,  Node: EigenSolver,  Next: EigenSolverInitTolerance,  Prev: SCFinLCAO,  Up: SCF

`EigenSolver' (integer, 0):
---------------------------

   At each SCF cycle step, a diagonalisation of the Hamiltonian is
performed.  This variable chooses the eigensolver used to diagonalise
the Kohn-Sham Hamiltonian.  Possible values are:
   - `0': Conjugated Gradients method.

   - `2': Block-Lanczos method.
   Look up the source to know what the differences are.

   In both cases, for the first iterations of the cycle there is no
need to perform a very precise diagonalisation. Because of this, we may
define a varying tolerance, so that at the first iteration a given small
tolerance is achieved, and then this tolerance is linearly increased
until a given iteration, after which a maximum tolerance is always
asked.  Next variables take care of this process.


File: octopus.info,  Node: EigenSolverInitTolerance,  Next: EigenSolverFinalTolerance,  Prev: EigenSolver,  Up: SCF

`EigenSolverInitTolerance' (double, 1.0e-3)
-------------------------------------------

   This is the initial tolerance for the eigenvectors.


File: octopus.info,  Node: EigenSolverFinalTolerance,  Next: EigenSolverFinalToleranceIteration,  Prev: EigenSolverInitTolerance,  Up: SCF

`EigenSolverFinalTolerance' (double, 1.0e-5)
--------------------------------------------

   This is the final tolerance for the eigenvectors.


File: octopus.info,  Node: EigenSolverFinalToleranceIteration,  Next: EigenSolverMaxIter,  Prev: EigenSolverFinalTolerance,  Up: SCF

`EigenSolverFinalToleranceIteration' (integer, 7)
-------------------------------------------------

   Determines how many interactions are needed to go from
`EigenSolverInitTolerance' to `EigenSolverFinalTolerance'.


File: octopus.info,  Node: EigenSolverMaxIter,  Next: What2Mix,  Prev: EigenSolverFinalToleranceIteration,  Up: SCF

`EigenSolverMaxIter' (integer, 25)
----------------------------------

   It determines the maximum number of iterations for the eigensolver
(per state) -- that is, if this number is reached, the diagonalisation
is stopped even if the desired tolerance was not achieved.


File: octopus.info,  Node: What2Mix,  Next: TypeOfMixing,  Prev: EigenSolverMaxIter,  Up: SCF

`What2Mix' (integer, 0)
-----------------------

   Selects what should be mixed during the SCF cycle. Possible values
are:
   - `0': Density

   - `1': Potential


File: octopus.info,  Node: TypeOfMixing,  Next: Mixing,  Prev: What2Mix,  Up: SCF

`TypeOfMixing' (integer, 2)
---------------------------

   Selects the mixing procedure to be used during the SCF cycle.
Possible values are:
   - `0': Linear mixing.

   - `1': Guaranteed-reduction Pulay (GR-Pulay).

   - `2': Broyden mixing.


File: octopus.info,  Node: Mixing,  Next: MixNumberSteps,  Prev: TypeOfMixing,  Up: SCF

`Mixing' (double, 0.3)
----------------------

   Determines the amount of the new density/potential which is to be
mixed with the old one. Used only by linear mixing and Broyden mixing.


File: octopus.info,  Node: MixNumberSteps,  Prev: Mixing,  Up: SCF

`MixNumberSteps' (integer, 3)
-----------------------------

   Number of steps used by Broyden mixing or GR-Pulay mixing to
extrapolate the new density/potential.


File: octopus.info,  Node: Unoccupied States,  Next: Time Dependent,  Prev: SCF,  Up: Input file options

Unoccupied States
=================

   These variables are only used in `CalculationMode == 3, 4' (or in 5
and 6 if `TDOccupationalAnalysis == 1').

* Menu:

* UnoccNumberStates::
* UnoccMaximumIter::
* UnoccConv::


File: octopus.info,  Node: UnoccNumberStates,  Next: UnoccMaximumIter,  Prev: Unoccupied States,  Up: Unoccupied States

`UnoccNumberStates' (integer, 5)
--------------------------------

   How many unoccupied states to compute.


File: octopus.info,  Node: UnoccMaximumIter,  Next: UnoccConv,  Prev: UnoccNumberStates,  Up: Unoccupied States

`UnoccMaximumIter' (integer, 200)
---------------------------------

   Maximum number of iterations while calculating the unoccupied states.
Note that these are _not_ SCF iterations, for the density and the
Hamiltonian are not updated!


File: octopus.info,  Node: UnoccConv,  Prev: UnoccMaximumIter,  Up: Unoccupied States

`UnoccConv' (double, 1e-4)
--------------------------

   Absolute convergence in the eigenvectors. So don't try to put it too
good or else you won't converge.


File: octopus.info,  Node: Time Dependent,  Next: Geometry optimization,  Prev: Unoccupied States,  Up: Input file options

Time Dependent
==============

   When `CalculationMode = 5,6', `octopus' performs the time propagation
of the electronic orbitals and - if required - of the ionic positions.
This latter task does not pose major algorithmical problems (the usual
Verlet algorithms deal with that task); however the best way to
propagate a Schro"dinger-like equation is still unclear. Due to this
fact, we provide with a rather excessive selection of possibilities for
that purpose. Before describing the set of variables necessary to
specify the way in which the time evolution is to be performed, it is
worth making a brief introduction to the problem.

   We are concerned with a set of Schro"dinger-like equations for the
electronic orbitals:

   i{\partial psi_i \over \partial t} = H(t)\psi_i(t)\,,

   \psi_i(t=0) = \psi_i^0\,.

   Being the equation linear, one may formally define a linear
"evolution" operator, which trasforms the initial vector into the
solution at time T:

   \psi_i(T) = U(T, 0)\psi_i^0

   Moreover, there is a formal exact expression for the evolution
operator:

   \psi_i(T) = T\exp\lbrace -i\!\!\int_0^{T}d\tau H(\tau)\rbrace
\psi_i^0\,.

   where T\exp is the time-ordered exponential. If the Hamiltonian
conmutes with itself at different times, we can drop the time-ordering
product, and leave a simple exponential.  If the Hamiltonian is
time-independent - which makes it trivially self commuting, the
solution is then simply written as:

   \psi_i(T) = \exp\lbrace -iTH\rbrace \psi_i^0\,.

   Unfortunately, this is not the case in general. We have to find an
algorithm able to cope with time-dependent Hamiltonians, such as the
self-consistent time-dependent Kohn-Sham operator, which is built "self
consistently" from the varying electronic density.

   The first step is to perform a time-discretization: the full
propagation between 0 and T is decomposed as:

   U(T,0) = \prod_{i=0}^{N-1}U(t_i+\delta t,t_i)\,,

   where t_0=0, t_N=T, \delta t = T/N. So at each time step we are
dealing with the problem of performing the short-time propagation:

   \psi_i(t+\delta t) = U(t+\delta t, t)\psi_i(t) = T\exp\lbrace
-i\!\!\int_{t}^{t+\delta t}\!\!\!\!\!\!\!\!\!d\tau\,H(\tau)\rbrace
\psi(t)\,.

   In this way, one can monitor the evolution in the interior of [0,t].
In fact, the possibility of monitoring the evolution is generally a
requirement; this requirement imposes a natural restriction on the
maximum size of \delta t: if \omega_\rm max is the maximum frequency
that we want to discern, \delta t should be no larger than \approx
1/\omega_\rm max.  Below this \delta t_\rm max, we are free to choose
\delta t considering performance reasons: Technically, the reason for
the discretization is twofold: the time-dependence of H is alleviated,
and the norm of the exponential argument is reduced (the norm increases
linearly with \delta t).

   Since we cannot drop the time-ordering product, the desired algorithm
cannot be reduced, in principle, to the calculation of the action of
the exponential of an operator over the initial vector.  Some
algorithms tailored to approximate the evolution operator, in fact, do
not even require to peform such operator exponentials.  Most of them,
however, do rely on the calculation of one or more exponentials, such
as the ones used by `octopus'. This is why in principle we need to
specify two different issues: the "evolution method", and the
"exponential method". In other words: we need an algorithm to
approximate the evolution operator U(t+\delta t, t) - which will be
specified by variable `TDEvolutionMethod' (*note TDEvolutionMethod::) -
and, if this algorithm requires it, we will also need an algorithm to
approximate the exponential of a matrix operator \exp\lbrace A\rbrace -
which will be specified by variable `TDExponentialMethod' (*note
TDExponentialMethod::).

* Menu:

* TDMaximumIter::
* TDTimeStep::
* TDExponentialMethod::
* TDExpOrder::
* TDLanczosTol::
* TDEvolutionMethod::
* TDLasers::
* TDGauge::
* TDDeltaStrength::
* TDPolarization::
* TDDipoleMax::
* TDOutputMultipoles::
* TDOutputCoordinates::
* TDOutputGSProjection::
* TDOutputAcceleration::
* TDOutputLaser::
* TDOutputElEnergy::
* TDOutputOccAnalysis::
* MoveIons::
* AbsorbingBoundaries::
* ABWidth::
* ABHeight::


File: octopus.info,  Node: TDMaximumIter,  Next: TDTimeStep,  Prev: Time Dependent,  Up: Time Dependent

`TDMaximumIter' (integer, 1500)
-------------------------------

   Number of time steps in which the total integration time is divided;
in previous notation, N.


File: octopus.info,  Node: TDTimeStep,  Next: TDExponentialMethod,  Prev: TDMaximumIter,  Up: Time Dependent

`TDTimeStep' (double, 0.07 a.u.)
--------------------------------

   Time-step for the propagation; in previous notation, \delta t.


File: octopus.info,  Node: TDExponentialMethod,  Next: TDExpOrder,  Prev: TDTimeStep,  Up: Time Dependent

`TDExponentialMethod' (integer, 1)
----------------------------------

   Method used to numerically calculate the exponential of the
Hamiltonian, a core part of the full algorithm used to approximate the
evolution operator, specified through the variable `TDEvolutionMethod'
(*note TDEvolutionMethod::).  In the case of using the Magnus method,
described below, the action of the exponential of the Magnus operator
is also calculated through the algorithm specified by this variable.

   - `1': N-th order standard expansion of the exponential (STD).

     This method amounts to a straightforward application of the
     definition of the exponential of an operator, in terms of it
     Taylor expansion.

     \exp_{\rm STD} (-i\delta t H) = \sum_{i=0}^{k} {(-i\delta
     t)^i\over{i!}} H^i.

     The order k is determined by variable `TDExpOder' (*note
     TDExpOrder::).  Some numerical considerations (by Jeff
     Giansiracusa and George F. Bertsch; see
     `http://www.phys.washington.edu/~bertsch/num3.ps') suggest the 4th
     order as especially suitable and stable.

   - `2': Lanczos approximation (LAN).

     Allows for larger time-steps.  However, the larger the time-step,
     the longer the computational time per time-step.  In certain
     cases, if the time-step is too large, the code will emit a warning
     whenever it considers that the evolution may not be properly
     proceeding - the Lanczos process did not converge. The method
     consists in a Krylov subspace approximation of the action of the
     exponential (see M. Hochbruck and C. Lubich, SIAM J. Numer. Anal.
     *34*, 1911 (1997) for details).  Two more variables control the
     performance of the method: the maximum dimension of this subspace
     (controlled by variable `TDExpOrder'), and the stopping criterium
     (controlled by variable `TDLanczosTol').  The smaller the stopping
     criterium, the more precisely the exponential is calculated, but
     also the larger the dimension of the Arnoldi subspace. If the
     maximum dimension allowed by `TDExpOrder' is not enough to meet
     the criterium, the above-mentioned warning is emitted.

   - `3': Split-operator (SO).

     It is important to distinguish between applying the split operator
     method to calculate the exponential of the Hamiltonian at a given
     time - which is what this variable is referring to - from the
     split operator method as an algorithm to approximate the full
     evolution operator U(t+\delta t, t), and which will be described
     below as one of the possibilities of the variable
     `TDEvolutionMethod'.  The equation that describes the split
     operator scheme is well known:

     \exp_{\rm SO} (-i \delta t H) = \exp (-i \delta t/2 V) \exp (-i
     \delta t T) \exp (-i \delta t/2 V)\,.

     Note that this is a "kinetic referenced SO", since the kinetic
     term is sandwiched in the middle. This is so because in `octopus',
     the states spend most of its time in real-space; doing it
     "potential referenced" would imply 4 FFTs instead of 2.  This
     split-operator technique may be used in combination with, for
     example, the exponential midpoint rule as a means to approximate
     the evolution operator.  In that case, the potential operator `V'
     that appears in the equation would be calculated at time t+\delta
     t/2, that is, in the middle of the time-step.  However, note that
     if the split-operator method is invoked as a means to approximate
     the evolution operator (`TDEvolutionMethod = 0'), a different
     procedure is taken - it will be described below -, and in fact the
     variable `TDExponentialMethod' has no effect at all.

   - `4': Suzuki-Trotter (ST).

     This is a higher-order SO based algorithm. See O. Sugino and Y.
     Miyamoto, Phys. Rev. B *59*, 2579 (1999). Allows for larger
     time-steps, but requires five times more time than the normal SO.

     The considerations made above for the SO algorithm about the
     distinction between using the method as a means to approximate
     `U(t+\delta t)' or as a means to approximate the exponential also
     apply here. Setting `TDEvolutionMethod = 1' enforces the use of
     the ST as an algorithm to approximate the full evolution operator,
     which is slightly different (see below).

   - `5': N-th order Chebyshev expansion (CHEB).

     In principle, the Chebyshev expansion of the exponential
     represents it more accurately than the canonical or standard
     expansion.  As in the latter case, `TDExpOrder' determines the
     order of the expansion.

     There exists a closed analytical form for the coefficients of the
     exponential in terms of Chebyshev polynomials:

     \exp_{\rm CHEB} \left( -i\delta t H \right) = \sum_{k=0}^{\infty}
     (2-\delta_{k0})(-i)^{k} J_k(\delta t) T_k(H),

     where J_k are the Bessel functions of the first kind, and H has te
     be previously scaled to [-1,1].  See H. Tal-Ezer and R. Kosloff,
     J. Chem. Phys. *81*, 3967 (1984); R. Kosloff, Annu. Rev. Phys.
     Chem. *45*, 145 (1994); C. W. Clenshaw, MTAC *9*, 118 (1955).



File: octopus.info,  Node: TDExpOrder,  Next: TDLanczosTol,  Prev: TDExponentialMethod,  Up: Time Dependent

`TDExpOrder' (integer, 4)
-------------------------

   For `TDExponentialMethod' equal `1' or `5', the order to which the
exponential is expanded. For the Lanczos approximation, it is the
maximum Lanczos-subspace dimension.


File: octopus.info,  Node: TDLanczosTol,  Next: TDEvolutionMethod,  Prev: TDExpOrder,  Up: Time Dependent

`TDLanczosTol' (real, 5e-4)
---------------------------

   An internal tolerance variable for the Lanczos method. The smaller,
the more precisely the exponential is calculated, and also the bigger
the dimension of the Krylov subspace needed to perform the algorithm.
One should carefully make sure that this value is not too big, or else
the evolution will be wrong.


File: octopus.info,  Node: TDEvolutionMethod,  Next: TDLasers,  Prev: TDLanczosTol,  Up: Time Dependent

`TDEvolutionMethod' (integer, 2)
--------------------------------

   This variable determines which algorithm will be used to approximate
the evolution operator U(t+\delta t, t). That is, known \psi(\tau) and
H(\tau) for tau \le t, calculate t+\delta t. Note that in general the
Hamiltonian is not known at times in the interior of the interval
[t,t+\delta t].  This is due to the self-consistent nature of the
time-dependent Kohn-Sham problem: the Hamiltonian at a given time \tau
is built from the "solution" wavefunctions at that time.

   Some methods, however, do require the knowledge of the Hamiltonian
at some point of the interval [t,t+\delta t]. This problem is solved by
making use of extrapolation: given a number l of time steps previous to
time t, this information is used to build the Hamiltonian at arbitrary
times within [t,t+\delta t]. To be fully precise, one should then
proceed _self-consistently_: the obtained Hamiltonian at time t+\delta t
may then be used to interpolate the Hamiltonian, and repeat the
evolution algorithm with this new information. Whenever iterating the
procedure does not change the solution wave-functions, the cycle is
stopped. In practice, in `octopus' we perform a second-order
extrapolation without self-consistente check, except for the first two
iterations, where obviously the extrapolation is not reliable.

   * `0': Split Operator (SO).

     This is one of the most traditional methods. It splits the full
     Hamiltonian into a kinetic and a potential part, performing the
     first in Fourier-space, and the latter in real space. The
     necessary transformations are performed with the FFT algorithm.

     U_{\rm SO}(t+\delta t, t) = \exp \lbrace - {i \over 2}\delta t T
     \rbrace              \exp \lbrace -i\delta t V^* \rbrace
       \exp \lbrace - {i \over 2}\delta t T \rbrace

     Since those three exponentials may be calculated exactly, one does
     not need to use any of the methods specified by variable
     `TDExponentialMethod' to perform them.

     The key point is the specification of V^*. Let V(t) be divided into
     V_\rm int(t), the "internal" potential which depends
     self-consistently on the density, and V_\rm ext(t), the external
     potential that we know at all times since it is imposed to the
     system by us (e.g. a laser field): V(t)=V_\rm int(t)+V_\rm ext(t).
     Then we define to be V^* to be the sum of V_\rm ext(t+\delta t/2)
     and the internal potential built from the wavefunctions _after_
     applying the right-most kinetic term of the equation, \exp \lbrace
     -i\delta t/2 T \rbrace.

     It may the be demonstrated that the order of the error of the
     algorithm is the same that the one that we would have by making
     use of the Exponential Midpoint Rule (EM, described below), the SO
     algorithm to calculate the action of the exponential of the
     Hamiltonian, and a full self-consistent procedure.

   * `1': Suzuki-Trotter (ST).

     This is the generalization of the Suzuki-Trotter algorithm,
     described as one of the choices of the `TDExponentialMethod'
     (*note TDExponentialMethod::), to time-dependent problem. Consult
     the paper by O. Sugino and M. Miyamoto, Phys. Rev. B *59*, 2579
     (1999), for details.

     It requires of Hamiltonian extrapolations.

   * `2': Enforced Time-Reversal Symmetry (ETRS).

     The idea is to make use of the time-reversal symmetry from the
     beginning:

     \exp \left(-i\delta t/2 H_{n}\right)\psi_n = exp \left(i\delta t/2
     H_{n+1}\right) \psi_{n+1},

     and then invert to obtain:

     \psi_{n+1} = \exp \left(-i\delta t/2 H_{n+1}\right) exp
     \left(-i\delta t/2 H_{n}\right) \psi_{n}.

     But we need to know H_n+1, which can only be known exactly through
     the solution \psi_n+1. What we do is to estimate it by performing
     a single exponential: \psi^*_n+1=\exp \left( -i\delta t H_n
     \right) \psi_n, and then H_n+1 = H[\psi^*_n+1]. Thus no
     extrapolation is performed in this case.

   * `3': Approximated Enforced Time-Reversal Symmetry (AETRS).

     A modification of previous method to make it faster.  It is based
     on extrapolation of the time-dependent potentials. It is faster by
     about 40%.

     The only difference is the procedure to estimate H_n+1: in this
     case it is extrapolated trough a second-order polynomial by making
     use of the Hamiltonian at time t-2\delta t, t-\delta t and t.

   * `4': Exponential Midpoint Rule (EM).

     This is maybe the simplest method, but is is very well grounded
     theretically: it is unitary (if the exponential is performed
     correctly) and preserves time symmetry (if the self-consistency
     problem is dealt with correctly).  It consists on applying:

     U_{\rm EM} = \exp \left( -i\delta t H_{t+\delta t/2}\right)\,.

   * `5': Magnus Expansion (M4).  This is the most sophisticated
     approach. It is a fourth order scheme (feature that shares with
     the ST scheme; the other schemes are in principle second order).
     It is tailored for making use of very large time steps, or
     equivalently, dealing with problem with very high-frequency time
     dependence.  It is still in a experimental state; we are not yet
     sure of when it is advantageous.


   This proliferation of methods is certainly excessive; The reason for
it is that the propagation algorithm is currently a topic of active
development. We hope that in the future the optimal schemes are clearly
identified. In the mean time, if you don't feel like testing, use the
default choices and make sure the time step is small enough.


File: octopus.info,  Node: TDLasers,  Next: TDGauge,  Prev: TDEvolutionMethod,  Up: Time Dependent

`TDLasers' (block data)
-----------------------

   Each line of the block describes a laser pulse applied to the system.
The syntax is:
         %TDLasers
           polx | poly | polz | A0 | omega0 | envelope | tau0 | t0
         %
   where `pol' is the (complex) polarisation of the laser field, `A0'
the amplitude, `envelope' the envelope function, `t0' the middle
(maximum) of the pulse and `omega0' the frequency of the pulse. The
meaning of `tau0' depends on the envelope function.  The possible
values for `envelope' are:

   - `1': Gaussian envelope. `tau0' is the standard deviation of the
     pulse.

   - `2': Cosinoidal envelope. `tau0' is half the total length of the
     pulse.

   - `3': Ramp. In this case there is an extra parameter `tau1'. `tau0'
     is the length of the constant part of the ramp, and `tau1' is the
     raising (decaying) time. `tau1' should be an extra field after
     `t0'.

   - `10': Shape is read from a file.

   If `envelope=10', the `t0' parameter is substituted by a string that
determines the name of the file. The format of this file should be three
columns of real numbers: time, field and phase. Atomic units are
assumed. The values for the laser field that the program will use are
interpolated / extrapolated from this numerically defined function.


File: octopus.info,  Node: TDGauge,  Next: TDDeltaStrength,  Prev: TDLasers,  Up: Time Dependent

`TDGauge' (integer, 0)
----------------------

   In which gauge to treat the laser. Options are:
   - `1': Length gauge.

   - `2': Velocity gauge.


File: octopus.info,  Node: TDDeltaStrength,  Next: TDPolarization,  Prev: TDGauge,  Up: Time Dependent

`TDDeltaStrength' (double, 0.0 a.u.)
------------------------------------

   When no laser is applied, a delta (in time) electric field with
strength `TDDeltaStrength' is applied. This is used to calculate the
linear optical spectra.


File: octopus.info,  Node: TDPolarization,  Next: TDDipoleMax,  Prev: TDDeltaStrength,  Up: Time Dependent

`TDPolarization' (block data)
-----------------------------

   The (real) polarisation of the delta electric field. The format of
the block is:
         %TDPolarization
           polx | poly | polz
         %
   In order to calculate dichroism the polarisation has to be
generalized to complex. Also some input/output and the
`strength-function' utility have to be changed. It is a nice little
project if someone is interested in getting into `octopus'.


File: octopus.info,  Node: TDDipoleMax,  Next: TDOutputMultipoles,  Prev: TDPolarization,  Up: Time Dependent

`TDDipoleLmax' (integer , 1)
----------------------------

   Maximum multi-pole of the density output to the file
`td.general/multipoles' during a time-dependent simulation.


File: octopus.info,  Node: TDOutputMultipoles,  Next: TDOutputCoordinates,  Prev: TDDipoleMax,  Up: Time Dependent

`TDOutputMultipoles' (logical, true)
------------------------------------

   If true, outputs the multipole moments of the density to the file
`td.general/projections'.  This is required to, e.g., calculate optical
absorption spectra of finite systems.


File: octopus.info,  Node: TDOutputCoordinates,  Next: TDOutputGSProjection,  Prev: TDOutputMultipoles,  Up: Time Dependent

`TDOutputCoordinates' (logical, `MoveIons' > 0 )
------------------------------------------------

   If true (and if the atoms are allowed to move), outputs the
coordinates, velocities, and forces of the atoms to the the file
`td.general/coordinates'.


File: octopus.info,  Node: TDOutputGSProjection,  Next: TDOutputAcceleration,  Prev: TDOutputCoordinates,  Up: Time Dependent

`TDOutputGSProjection' (logical, false)
---------------------------------------

   If true, outputs the projection of the time-dependent Kohn-Sham
Slater determinant onto the ground-state to the file
`td.general/gs_projection'. As the calculation of the projection is
fairly heavy, this is only done every `OutputEvery' iterations.


File: octopus.info,  Node: TDOutputAcceleration,  Next: TDOutputLaser,  Prev: TDOutputGSProjection,  Up: Time Dependent

`TDOutputAcceleration' (logical, false)
---------------------------------------

   When _true_ outputs the acceleration, calculated from Ehrenfest
theorem, in the file `td.general/acceleration'. This file can then be
processed by the utility "hs-from-acc" in order to obtain the harmonic
spectrum.


File: octopus.info,  Node: TDOutputLaser,  Next: TDOutputElEnergy,  Prev: TDOutputAcceleration,  Up: Time Dependent

`TDOutputLaser' (logical, true)
-------------------------------

   If `true', `octopus' outputs the laser field to the file
"`td.general/laser'".


File: octopus.info,  Node: TDOutputElEnergy,  Next: TDOutputOccAnalysis,  Prev: TDOutputLaser,  Up: Time Dependent

`TDOutputElEnergy' (logical, false)
-----------------------------------

   If `true', `octopus' outputs the different components of the
electronic energy to the file `td.general/el_energy'.


File: octopus.info,  Node: TDOutputOccAnalysis,  Next: MoveIons,  Prev: TDOutputElEnergy,  Up: Time Dependent

`TDOutputOccAnalysis' (logical, false)
--------------------------------------

   If true, outputs the projections of the time-dependent Kohn-Sham
wave-functions onto the static (zero time) wave-functions to the file
`td.general/projections.XXX'.


File: octopus.info,  Node: MoveIons,  Next: AbsorbingBoundaries,  Prev: TDOutputOccAnalysis,  Up: Time Dependent

`MoveIons' (integer, 0)
-----------------------

   What kind of simulation to perform. Possible values are:
   - `0': Do not move the ions.

   - `3': Newtonian dynamics using Verlet.

   - `4': Newtonian dynamics using velocity Verlet.


File: octopus.info,  Node: AbsorbingBoundaries,  Next: ABWidth,  Prev: MoveIons,  Up: Time Dependent

`AbsorbingBoundaries' (integer, 0)
----------------------------------

   To improve the quality of the spectra by avoiding the formation of
standing density waves, one can make the boundaries of the simulation
box absorbing. The possible values for this parameter are:
   - `0': No absorbing boundaries.

   - `1': A sin^2 imaginary potential is added at the boundaries.

   - `2': A mask is applied to the wave-functions at the boundaries.


File: octopus.info,  Node: ABWidth,  Next: ABHeight,  Prev: AbsorbingBoundaries,  Up: Time Dependent

`ABWidth' (real, 0.4 a.u.):
---------------------------

   Width of the region used to apply the absorbing boundaries.


File: octopus.info,  Node: ABHeight,  Prev: ABWidth,  Up: Time Dependent

`ABHeight' (real, -0.2 a.u.)
----------------------------

   When `AbsorbingBoundaries == 1', is the height of the imaginary
potential.


File: octopus.info,  Node: Geometry optimization,  Next: Function output for visualization,  Prev: Time Dependent,  Up: Input file options

Geometry optimization
=====================

* Menu:

* GOMethod::
* GOTolerance::
* GOMaxIter::
* GOStep::


File: octopus.info,  Node: GOMethod,  Next: GOTolerance,  Prev: Geometry optimization,  Up: Geometry optimization

`GOMethod' (integer, 1)
-----------------------

   Method by which the minimization is performed. The only possible
value is   `1' (simple steepest descent).


File: octopus.info,  Node: GOTolerance,  Next: GOMaxIter,  Prev: GOMethod,  Up: Geometry optimization

`GOTolerance' (real, 0.0001)
----------------------------

   Convergence criterium to stop the minimization. In units of force;
minimization   is stopped when all forces on ions are smaller.


File: octopus.info,  Node: GOMaxIter,  Next: GOStep,  Prev: GOTolerance,  Up: Geometry optimization

`GOMaxIter' (integer, 200)
--------------------------

   Even if previous convergence criterium is not satisfied,
minimization will stop   after this number of iterations.


File: octopus.info,  Node: GOStep,  Prev: GOMaxIter,  Up: Geometry optimization

`GOStep' (double, 0.5)
----------------------

   Initial step for the geometry optimizer.


File: octopus.info,  Node: Function output for visualization,  Next: Spectrum calculations,  Prev: Geometry optimization,  Up: Input file options

Function output for visualization
=================================

   Every given number of time iterations, or after ground-state
calculations, some of the functions that characterise the system may be
written to disk so that they may be analized. Files are written within
"static" output directory after the self-consistent field, or within
"td.x" directories, during evolution, where "x" stands for the
iteration number at which each write is done.  Note that if you wish to
plot any function (`OutputKSPotential = yes', etc.), at least one of
the output formats should be enabled (`OutputPlaneX = yes', `OutputDX =
yes', `OutputNETCDF = yes', etc.). [This is not necessary if you wish
to plot the geometry (`OutputGeometry = yes')]. Note further that the
data written by `OutputAxisX', `OutputPlaneX' etc. has always the
(side) length of the longest axis; this is independent from the  chosen
geometry. Data points which are inexistent in the actual geometry have
the value zero in those files.

* Menu:

* OutputKSPotential::
* OutputDensity::
* OutputWfs::
* OutputWfsNumber::
* OutputElf::
* OutputGeometry::
* OutputAxisX::
* OutputAxisY::
* OutputAxisZ::
* OutputPlaneX::
* OutputPlaneY::
* OutputPlaneZ::
* OutputDX::
* OutputNETCDF::
* OutputEvery::


File: octopus.info,  Node: OutputKSPotential,  Next: OutputDensity,  Prev: Function output for visualization,  Up: Function output for visualization

`OutputKSPotential' (logical, false)
------------------------------------

   Prints out Kohn-Sham potential, separated by parts. File names would
be "v0" for the local part, "vc" for the classical potential (if it
exists), "vh" for the Hartree potential, and "vxc-x" for each of the
exchange and correlation potentials of a give spin channel, where "x"
stands for the spin channel.


File: octopus.info,  Node: OutputDensity,  Next: OutputWfs,  Prev: OutputKSPotential,  Up: Function output for visualization

`OutputDensity' (logical, false)
--------------------------------

   Prints out the density. The output file is called "density-i", where
"i" stands for the spin channel.


File: octopus.info,  Node: OutputWfs,  Next: OutputWfsNumber,  Prev: OutputDensity,  Up: Function output for visualization

`OutputWfs' (logical, false)
----------------------------

   Prints out wave-functions. Which wavefunctions are to be printed is
specified by the variable `OutputWfsNumber' - see below. The output
file is called "wf-k-p-i", where k stands for the _k_ number, p for the
state, and i for the spin channel.


File: octopus.info,  Node: OutputWfsNumber,  Next: OutputElf,  Prev: OutputWfs,  Up: Function output for visualization

`OutputWfsNumber' (string, "1-1024")
------------------------------------

   Which wavefunctions to print, in list form, i.e., "1-5" to print the
first five states, "2,3" to print the second and the third state, etc.


File: octopus.info,  Node: OutputElf,  Next: OutputGeometry,  Prev: OutputWfsNumber,  Up: Function output for visualization

`OutputELF' (logical, false)
----------------------------

   Prints out the electron localization function, ELF. The output file
is called   "elf-i", where i stands for the spin channel.


File: octopus.info,  Node: OutputGeometry,  Next: OutputAxisX,  Prev: OutputElf,  Up: Function output for visualization

`OutputGeometry' (logical, false)
---------------------------------

   If true `octopus' outputs a XYZ file called "geometry.xyz"
containing the coordinates of the atoms treated within Quantum
Mechanics. If point charges were defined in the PDB file (see
`PDBCoordinates'), they will be output in the file
"geometry_classical.xyz".


File: octopus.info,  Node: OutputAxisX,  Next: OutputAxisY,  Prev: OutputGeometry,  Up: Function output for visualization

`OutputAxisX' (logical, false)
------------------------------

   The values of the function on the x axis are printed. The string
".y=0,z=0" is appended to previous file names.


File: octopus.info,  Node: OutputAxisY,  Next: OutputAxisZ,  Prev: OutputAxisX,  Up: Function output for visualization

`OutputAxisY' (logical, false)
------------------------------

   The values of the function on the y axis are printed. The string
".x=0,z=0" is appended to previous file names.


File: octopus.info,  Node: OutputAxisZ,  Next: OutputPlaneX,  Prev: OutputAxisY,  Up: Function output for visualization

`OutputAxisZ' (logical, false)
------------------------------

   The values of the function on the z axis are printed. The string
".x=0,y=0" is appended to previous file names.


File: octopus.info,  Node: OutputPlaneX,  Next: OutputPlaneY,  Prev: OutputAxisZ,  Up: Function output for visualization

`OutputPlaneX' (logical, false)
-------------------------------

   A plane slice at x=0 is printed. The string ".x=0" is appended to
previous file names.


File: octopus.info,  Node: OutputPlaneY,  Next: OutputPlaneZ,  Prev: OutputPlaneX,  Up: Function output for visualization

`OutputPlaneY' (logical, false)
-------------------------------

   A plane slice at y=0 is printed. The string ".y=0" is appended to
previous file names.


File: octopus.info,  Node: OutputPlaneZ,  Next: OutputDX,  Prev: OutputPlaneY,  Up: Function output for visualization

`OutputPlaneZ' (logical, false)
-------------------------------

   A plane slice at y=0 is printed. The string ".z=0" is appended to
previous file names.


File: octopus.info,  Node: OutputDX,  Next: OutputNETCDF,  Prev: OutputPlaneZ,  Up: Function output for visualization

`OutputDX' (logical, false)
---------------------------

   For printing all the three dimensional information, the open source
program visualization tool OpenDX (`http://www.opendx.org/') is used.
The string ".dx" is appended to previous file names.  *Note wf.net::.


File: octopus.info,  Node: OutputNETCDF,  Next: OutputEvery,  Prev: OutputDX,  Up: Function output for visualization

`OutputNETCDF' (logical, false)
-------------------------------

   Outputs in NetCDF (`http://www.unidata.ucar.edu/packages/netcdf/')
format. This file can then be read, for example, by OpenDX. The string
".ncdf" is appended to previous file names.


File: octopus.info,  Node: OutputEvery,  Prev: OutputNETCDF,  Up: Function output for visualization

`OutputEvery' (integer, 1000)
-----------------------------

   `OutputEvery' The output is saved when the iteration number is a
multiple of the `OutputEvery' variable.


File: octopus.info,  Node: Spectrum calculations,  Next: Varia,  Prev: Function output for visualization,  Up: Input file options

Spectrum calculations
=====================

   Once `octopus' has been run, results must be analyzed somehow. The
most common thing is to Fourier-transform something to calculate
spectra. This may be done through some utilities (`strength-function',
`hs-from-mult', `hs-from-acc' which are described in section "External
utilities." Common options read by these utilities are:

* Menu:

* SpecTransformNode::
* SpecDampMode::
* SpecDampFactor::
* SpecStartTime::
* SpecEndTime::
* SpecEnergyStep::
* SpecMinEnergy::
* SpecMaxEnergy::
* HSPolarization::


File: octopus.info,  Node: SpecTransformNode,  Next: SpecDampMode,  Prev: Spectrum calculations,  Up: Spectrum calculations

`SpecTransformMode' (string, 'sin')
-----------------------------------

   What kind of Fourier transform is calculated. 'sin' and 'cos' are
the valid options, with obvious meanings.


File: octopus.info,  Node: SpecDampMode,  Next: SpecDampFactor,  Prev: SpecTransformNode,  Up: Spectrum calculations

`SpecDampMode' (string, 'exp')
------------------------------

   A damping function may be applied to the input fuction before
processing the Fourier transform. This function may be an exponential,
a third order polynomial (fit to be one at t=0, and also its
derivative,  and null at t=T), or a gaussian: "exp" or "pol" or "gau".
It amounts to applying a convolution of the signal in Fourier space,
either with a Lorentzian function (for the exponential), with a
Gaussian function (for the Gaussian), or with some other function (in
the case of the third order polynomial.  If this variable is not
present or has any other value, no damping function is applied.


File: octopus.info,  Node: SpecDampFactor,  Next: SpecStartTime,  Prev: SpecDampMode,  Up: Spectrum calculations

`SpecDampFactor' (real, 0.0)
----------------------------

   If `SpecDampMode' is set to "exp", the damping parameter of the
exponential is fixed through this variable.


File: octopus.info,  Node: SpecStartTime,  Next: SpecEndTime,  Prev: SpecDampFactor,  Up: Spectrum calculations

`SpecStartTime' (real, 0.0)
---------------------------

   Processing is done for the given function in a time-window that
starts at the value of this variable.


File: octopus.info,  Node: SpecEndTime,  Next: SpecEnergyStep,  Prev: SpecStartTime,  Up: Spectrum calculations

`SpecEndTime' (real, -1.0)
--------------------------

   Processing is done for the given function in a time-window that ends
at the value of this variable.


File: octopus.info,  Node: SpecEnergyStep,  Next: SpecMinEnergy,  Prev: SpecEndTime,  Up: Spectrum calculations

`SpecEnergyStep' (real, 0.05)
-----------------------------

   Sampling rate for the spectrum.


File: octopus.info,  Node: SpecMinEnergy,  Next: SpecMaxEnergy,  Prev: SpecEnergyStep,  Up: Spectrum calculations

`SpecMinEnergy' (real, 0.0)
---------------------------

   The Fourier transform is calculated for energies bigger than this
value.


File: octopus.info,  Node: SpecMaxEnergy,  Next: HSPolarization,  Prev: SpecMinEnergy,  Up: Spectrum calculations

`SpecMaxEnergy' (real, 20.0)
----------------------------

   The Fourier transform is calculated for energies smaller than this
value.


File: octopus.info,  Node: HSPolarization,  Prev: SpecMaxEnergy,  Up: Spectrum calculations

`HSPolarization' (string, 'z')
------------------------------

   For the utilities `hs-from-acc', and `hs-from-mult', the polarization
of the laser pulse must be specified. Valid values are "x", "y" and "z"
for lasers linearly polarized along the respective axis, or "+" or "-"
for lasers circularly polarized. See the description of `hs-from-acc'
and `hs-from-mult' for more details.


File: octopus.info,  Node: Varia,  Prev: Spectrum calculations,  Up: Input file options

Varia
=====

* Menu:

* PoissonSolver::
* POLStaticField::
* Displacement::


File: octopus.info,  Node: PoissonSolver,  Next: POLStaticField,  Prev: Varia,  Up: Varia

`PoissonSolver' (integer, 3)
----------------------------

   In 3D defines which method to use in order to solve the Poisson
equation.  Allowed values are:
   - `1': Conjugated gradient method.

   - `3': FFTs with spherical cutoff.
   The value of variable `DoubleFFTParameter' is used in case `3'
method is used.


File: octopus.info,  Node: POLStaticField,  Next: Displacement,  Prev: PoissonSolver,  Up: Varia

`POLStaticField' (double, 0.001 a.u.)
-------------------------------------

   Magnitude of the static field used to calculate the static
polarizability in `CalculationMode = 7, 8'.


File: octopus.info,  Node: Displacement,  Prev: POLStaticField,  Up: Varia

`Displacement' (double, 0.01 a.u.)
----------------------------------

   When calculating phonon properties (`CalculationMode = 11')
`Displacement' controls how much the atoms are to be moved in order to
calculate the dynamical matrix.


File: octopus.info,  Node: External utilities,  Next: Examples,  Prev: Input file options,  Up: Top

External utilities
******************

   A few small programs are generated along with `octopus', for the
purpose of post-processing the generated information. These utilities
should all be run from the directory where `octopus' was run, so that
it may see the `inp' file, and the directories created by it.

* Menu:

* oct-sf::
* oct-rsf::
* oct-hs-mult::
* oct-hs-acc::
* oct-xyz-anim::
* oct-excite::
* oct-broad::
* oct-make-st::
* oct-choose-st::
* oct-center-geom::
* wf.net::


File: octopus.info,  Node: oct-sf,  Next: oct-rsf,  Prev: External utilities,  Up: External utilities

`oct-sf'
========

   This utility generates the dipole strength function of the given
system.  Its main input is the `td.general/multipoles' file. Output is
written to a file called `spectrum'. This file is made of two columns:
energy (in eV or a.u., depending on the units specified in `inp'), and
dipole strength function (in 1/eV, or 1/a.u., idem).

   In the `inp' file, the user may set the `SpecTransformMode' - this
should be set to "sin" for proper use -, the `SpecDampMode' -
recommended value is "pol", which ensures fulfilling of the N-sum rule,
the `SpecStartTime', the `SpecEndTime', the `SpecEnergyStep', the
`SpecMinEnergy' and the `SpecMaxEnergy'.


File: octopus.info,  Node: oct-rsf,  Next: oct-hs-mult,  Prev: oct-sf,  Up: External utilities

`oct-rsf'
=========


File: octopus.info,  Node: oct-hs-mult,  Next: oct-hs-acc,  Prev: oct-rsf,  Up: External utilities

`oct-hs-mult'
=============

   Calculates the harmonic spectrum, out of the multipoles file. To do.


File: octopus.info,  Node: oct-hs-acc,  Next: oct-xyz-anim,  Prev: oct-hs-mult,  Up: External utilities

`oct-hs-acc'
============

   Calculates the harmonic spectrum, out of the acceleration file. To
do.

