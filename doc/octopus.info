This is octopus.info, produced by makeinfo version 4.7 from
octopus.texi.

   This manual is for octopus 1.99devel, a first principles, electronic
structure, excited states, time-dependent density functional theory
program.

   Copyright (C) 2002, 2003, 2004 Miguel A. L. Marques, Alberto Castro
and Angel Rubio

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.1 or any later version published by the Free Software
     Foundation.

INFO-DIR-SECTION Individual utilities
START-INFO-DIR-ENTRY
* octopus: (octopus).           The octopus program.
END-INFO-DIR-ENTRY


File: octopus.info,  Node: Top,  Next: Authors,  Prev: (dir),  Up: (dir)

octopus
*******

This manual is for octopus 1.99devel, a first principles, electronic
structure, excited states, time-dependent density functional theory
program.

   Copyright (C) 2002, 2003, 2004 Miguel A. L. Marques, Alberto Castro
and Angel Rubio

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.1 or any later version published by the Free Software
     Foundation.

* Menu:

* Authors::
* Copying::
* Introduction::
* Installation::
* The parser::
* Input file options::
* External utilities::
* Undocumented Variables::
* Examples::
* Options Index::

 --- The Detailed Node Listing ---

Introduction

* Description of octopus::
* Time dependent density functional theory::

Installation

* Quick instructions::
* Long instructions::
* Different octopus executables::
* Troubleshooting::

Input file options

* Generalities::
* Species Block::
* Coordinates Description::
* Mesh::
* States::
* Hamiltonian::
* Exchange and correlation::
* SCF::
* Unoccupied States::
* Time Dependent::
* Geometry optimization::
* Function output for visualization::
* Spectrum calculations::
* Varia::

Generalities

* SystemName::
* Dimensions::
* CalculationMode::
* Units::
* UnitsInput::
* UnitsOutput::
* Verbose::
* DebugLevel::

Species Block

* Species::

Coordinates Description

* PDBCoordinates::
* XYZCoordinates::
* Coordinates::
* XYZVelocities::
* Velocities::
* RandomVelocityTemp::

Mesh

* BoxShape::
* Radius::
* Lsize::
* XLength::
* Spacing::
* DerivativesSpace::
* OrderDerivatives::
* DoubleFFTParameter::
* FFTOptimize::

States

* SpinComponents::
* ExcessCharge::
* ExtraStates::
* Occupations::
* ElectronicTemperature::

Hamiltonian

* NonInteractingElectrons::
* ClassicPotential::
* LocalPotentialSpace::
* RelativisticCorrection::

Exchange and correlation

* XFunctional::
* CFunctional::
* OEP_level::
* SICCorrection::

SCF

* MaximumIter::
* ConvAbsDens::
* ConvRelDens::
* ConvAbsEv::
* ConvRelEv::
* GuessMagnetDensity::
* AtomsMagnetDirection::
* LCAOStart::
* SCFinLCAO::
* EigenSolver::
* EigenSolverInitTolerance::
* EigenSolverFinalTolerance::
* EigenSolverFinalToleranceIteration::
* EigenSolverMaxIter::
* What2Mix::
* TypeOfMixing::
* Mixing::
* MixNumberSteps::

Unoccupied States

* UnoccNumberStates::
* UnoccMaximumIter::
* UnoccConv::

Time Dependent

* TDMaximumIter::
* TDTimeStep::
* TDExponentialMethod::
* TDExpOrder::
* TDLanczosTol::
* TDEvolutionMethod::
* TDLasers::
* TDGauge::
* TDDeltaStrength::
* TDPolarization::
* TDOutputMultipoles::
* TDDipoleMax::
* TDOutputCoordinates::
* TDOutputGSProjection::
* TDOutputAcceleration::
* TDOutputLaser::
* TDOutputElEnergy::
* TDOutputOccAnalysis::
* MoveIons::
* AbsorbingBoundaries::
* ABWidth::
* ABHeight::

Geometry optimization

* GOMethod::
* GOTolerance::
* GOMaxIter::
* GOStep::

Function output for visualization

* OutputKSPotential::
* OutputDensity::
* OutputWfs::
* OutputWfsNumber::
* OutputElf::
* OutputGeometry::
* OutputAxisX::
* OutputAxisY::
* OutputAxisZ::
* OutputPlaneX::
* OutputPlaneY::
* OutputPlaneZ::
* OutputDX::
* OutputNETCDF::
* OutputEvery::

Spectrum calculations

* SpecTransformNode::
* SpecDampMode::
* SpecDampFactor::
* SpecStartTime::
* SpecEndTime::
* SpecEnergyStep::
* SpecMinEnergy::
* SpecMaxEnergy::
* HSPolarization::

Varia

* PoissonSolver::
* POLStaticField::
* Displacement::

External utilities

* oct-sf::
* oct-rsf::
* oct-hs-mult::
* oct-hs-acc::
* oct-xyz-anim::
* oct-excite::
* oct-broad::
* oct-make-st::
* oct-center-geom::
* wf.net::

Examples

* Hello world::
* Benzene::


File: octopus.info,  Node: Authors,  Next: Copying,  Prev: Top,  Up: Top



The main developing team of this program is composed of:

   * Miguel A. L. Marques (Donostia International Physics Center, San
     Sebastia'n, Espan~a)

   * Angel Rubio, (Donostia International Physics Center and Department
     of Materials Science UPV/EHU, San Sebastia'n, Espan~a), and

   * Alberto Castro, (alberto.castro@tddft.org, Theoretische Physik,
     Freie Universita"t Berlin, Berlin 14195, Deutschland).

   Other contributors are:
   * Micael Oliveira: mixing, and a lot of stuff.

   * Carlo Andrea Rozzi - infinite systems (almost done!)

   * Sebastien Hamel    - paralel version of oct-excite.

   `octopus' is based on a fixed-nucleus code written by George F.
Bertsch and K. Yabana to perform real-time dynamics in clusters (Phys
Rev B *54*, 4484 (1996)) and on a condensed matter real-space
plane-wave based code written by A. Rubio, X. Blase and S.G. Louie
(Phys. Rev. Lett. *77*, 247 (1996)).  The code was afterwards extended
to handle periodic systems by G.F. Bertsch, J.I. Iwata, A. Rubio, and
K. Yabana (Phys. Rev. B, *62*, 7998 (2000)). Contemporaneously there was
a major rewrite of the original cluster code to handle a vast majority
of finite systems. At this point the cluster code was named "tddft".

   This version was consequently enhanced and beautified by A. Castro
(at the time Ph.D. student of A. Rubio), originating a fairly verbose
15,000 lines of Fortran 90/77. In the year 2000, M. Marques (aka
Hyllios, aka Anto'nio de Faria, corsa'rio portugue^s), joined the A.
Rubio group in Valladolid as a postdoc. Having to use "tddft" for his
work, and being petulant enough to think he could structure the code
better than his predecessors, he started a major rewrite of the code
together with A. Castro, finishing version 0.2 of "tddft." But things
were still not perfect: due to their limited experience in Fortran 90,
and due to the inadequacy of this language for anything beyond a HELLO
WORLD program, several parts of the code were still clumsy. Also the
idea of GPLing the almost 20,000 lines arose during an alcoholic
evening. So after several weeks of fantic coding and after getting rid
of the Numerical Recipes code that still lingered around, `octopus' was
born.

   The present released version has been completely rewritten and keeps
very little relation to the old version (even input and output files)
and has been enhanced with major new flags to perform various
excited-state dynamics in finite and extended systems (one-dimensional
periodic chains). The code will be updated frequently and new versions
can be found here (http://www.tddft.org/programs/octopus).

   The main features of the present version are described in detail in
_octopus: a first principles tool for excited states electron-ion
dynamics_, Comp. Phys. Comm. *151*, 60 (2003).  Updated references as
well as results obtained with octopus will be posted regularly to the
`octopus' web page. If you find the code useful for you research we
would appreciate if you give reference to this work and previous ones.

   If you have some free time, and if you feel like taking a joy ride
with Fortran 90, just drop us an email <octopus@tddft.org>. You can
also send us patches, comments, ideas, wishes, etc. They will be
included in new releases of octopus.



File: octopus.info,  Node: Copying,  Next: Introduction,  Prev: Authors,  Up: Top

The `octopus'  Copying Conditions
*********************************

This program is "free"; this means that everyone is free to use it and
free to redistribute it on a free basis.  What is not allowed is to try
to prevent others from further sharing any version of this program that
they might get from you.

   Specifically, we want to make sure that you have the right to give
away copies of the program, that you receive source code or else can
get it if you want it, that you can change this program or use pieces
of them in new free programs, and that you know you can do these things.

   To make sure that everyone has such rights, we have to forbid you to
deprive anyone else of these rights.  For example, if you distribute
copies of the program, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must tell them their rights.

   Also, for our own protection, we must make certain that everyone
finds out that there is no warranty for this program.  If these
programs are modified by someone else and passed on, we want their
recipients to know that what they have is not what we distributed, so
that any problems introduced by others will not reflect on our
reputation.

   The precise conditions of the license are found in the General Public
Licenses that accompany it.


File: octopus.info,  Node: Introduction,  Next: Installation,  Prev: Copying,  Up: Top

1 Introduction
**************

[Note to info readers: The preferred way to read this manual is in its
pdf or dvi versions, since there are quite a few equations that will
not print out well in info format. However, we have tried to make the
info format readable. For this purpose, we have chosen the following
convention: instead of removing the equations in the info files, they
will show up as the TeX commands that produce them in the printed
documentation]

* Menu:

* Description of octopus::
* Time dependent density functional theory::


File: octopus.info,  Node: Description of octopus,  Next: Time dependent density functional theory,  Prev: Introduction,  Up: Introduction

1.1 Description of `octopus'
============================

`octopus' (1) is a program aimed at the ab initio virtual
experimentation on electron/ion dynamics in external electromagnetic
fields of arbitrary intensity, shape and frequency in a hopefully ever
increasing range of systems types. Its main characteristics are:

   * Electrons are described quantum-mechanically within the
     Density-Functional Theory (DFT) for the ground-state whereas the
     excitation spectra is computed using time-dependent form (TDDFT)
     by performing simulations in time.

   * The electron-nucleus interaction is described within the
     pseudo-potential approximation. Nuclei are described classically
     as point particles.

   * Wave-functions are expanded in a real-space grid. The kinetic
     energy operator is computed with a high-order finite difference
     method.  FFTs are used in part of the calculations.  Time and grid
     spacing are related by imposing a stable time-evolution.

   * Forces on the ions are computed through the Ehrenfest theorem.
     Extension to quantum mechanical nuclear dynamics is in progress.

   * Allows for spin-polarised calculations as well as non-collinear
     magnetism and spin-orbit effects.

   * Computes photo-electron (energy and angle resolved) and
     photo-absorption spectra for different polarised external
     electromagnetic fields. Linear response calculations are a simple
     case of this general time-evolution procedure (see below).

   * Includes non-linear electronic effects: high-harmonic generation,
     interaction with a laser pulse of arbitrary intensity. For the
     time being only time- and spatially-dependent electric fields are
     included, in the future magnetic fields will be incorporated.

   * Reads different geometry files including protein-data-base (PDB)
     for biological calculations (interaction of biomolecules with
     electromagnetic fields).

   * It allows for one and two dimesional modes by using for example
     the soft-coulomb potential or any other given as input.

   * Laser-pulse optimisation using genetic algorithms (to be done).

   * Utilities to analyse the computed spectra.

   * A very effective and easy-to-use parser to handle the input file.


   ---------- Footnotes ----------

   (1) _octopus_: Etymology: New Latin _Octopod-_, _Octopus_, from
Greek _oktOpous_.  Any of a genus (_Octopus_) of cephalopod mollusks
that have eight muscular arms equipped with two rows of suckers;
broadly, any octopod excepting the paper nautilus.  Something that
resembles an octopus especially in having many centrally directed
branches.  (Taken from the Merryam-Webster's dictionary.)


File: octopus.info,  Node: Time dependent density functional theory,  Prev: Description of octopus,  Up: Introduction

1.2 Time dependent density functional theory
============================================

Several reviews of time-dependent density function theory (TDDFT) and
its applications have appeared recently, like the works by Gross et al.
(1), Casida (2), Dobson et al, (3) , and Burke et al (4).

   The Hohenberg-Kohn-Sham theory as described is a ground state
theory, and it is hence not meant for the calculation of electronic
excitations.  However, one can extend the ideas of static DFT. When one
asks for the evolution of the system under the influence of a
time-dependent external potential, one should search the extrema of the
quantum mechanical action:


A[\Psi] = \int_{t_0}^{t_1} {\rm d}t
\langle \Psi(t) \vert {\rm i} {\partial \over \partial t} - H(t) \vert
\Psi(t) \rangle,

   Theorems have now been established for time-dependent DFT(5) which
are parallel to those of static DFT.  The first theorem proves a
one-to-one mapping between time-dependent potentials and time-dependent
densities; the second proves the stationary-action principle.

   The proof of the first theorem is based directly on the evolution of
the time-dependent Schro"dinger equation from a fixed initial
many-particle state \Psi(t_0)=\Psi_0 under the influence of a
time-dependent potential v(t) required to be expandable in a Taylor
series around t_0.  The initial state \Psi_0 does not need to be the
ground state or some other eigenstate of the initial potential.  As one
does not rely on the adiabatic connection as in standard
zero-temperature many-body perturbation theory the formalism is able to
handle external perturbations varying fast in time. By virtue of the
first theorem, the time-dependent density determines the external
potential uniquely up to an additive purely time-dependent function.
On the other hand, the potential determines the time-dependent
wave-function, therefore the expectation value of any quantum
mechanical operator is a unique functional of the density.

   The second theorem deals with the variational principle of the action
functional with the initial condition \Psi(t_0)=\Psi_0.  From the
previous one-to-one mapping between time-dependent potentials and
densities, the action is a functional of the density that must have a
stationary point at the correct time-dependent density.  Thus the Euler
equation corresponding to the extrema of A[\rho],


{\delta A[\rho] \over \delta \rho({\bf r},t)} =0,

   determines the time-dependent density, just as in the Hohenberg-Kohn
formalism the static ground state density is given by the minimum of
the total energy (\delta E[\rho]/\delta \rho(\bf r)=0).

   Similarly, one can define a time-dependent Kohn-Sham (KS) scheme by
introducing a non-interacting system that reproduces the exact
interacting density \rho(\bf r,t).  One gets the following
time-dependent KS-equations:


\left[ - {1 \over 2} \nabla^2 + V_{\rm eff}({\bf r},t)
\right] \psi_i({\bf r},t) = {\rm i}{\partial\over\partial t} \psi_i({\bf
r},t),

\rho({\bf r},t) = \sum_{i=1}^N \vert \psi_i({\bf r},t) \vert^2

   where:


V_{\rm eff}({\bf r},t)= V_{\rm H}({\bf r},t) + V_{\rm xc}({\bf r},t)+
V_{\rm ext}({\bf r},t)

   is the effective time-dependent potential felt by the electrons. It
consists of the sum of the external time-dependent applied field, the
time-dependent Hartree term, plus the  xc potential (defined through
the equivalence between the interacting and fictitious non-interacting
systems). The variational principle yields:
V_{\rm xc}({\bf r},t) =
{\delta A_{\rm xc}[\rho] \over \delta \rho({\bf r},t)},

   where A_\rm xc[\rho] is the xc part of the action functional.

   The main advantage of the time-dependent KS scheme lies in its
computational simplicity compared to other quantum-chemical models such
as time-dependent Hartree-Fock or configuration interaction.

   ---------- Footnotes ----------

   (1)   Gross, E.K.U., C.A. Ullricht and U.J. Grossmann, 1994, in
_Density Functional Theory_, (NATOP ASI Series), p.194;   Gross,
E.K.U., F. J. Dobson, and M. Petersilka, 1996,   _Density Functional
Theory_ (Springer, New York).

   (2)   Casida, M.E., 1995, in _Recent Advances in Density Functional
Methods_,   Part I, ed. D.P. Chong (World Scientific, Singapore), p.155;
 Casida, M.E., 1996, in _Recent Developments and Applications of Modern
 Density Functional Theory_, ed. J.M. Seminario (Elsevier Science,
Amsterdam), p.391

   (3)   Dobson, J , G. Vignale and M.P. Das (Eds), 1997a,
_Electronic Density Functional Theory: Recent Progress and New
Directions_   (Plenum, New York)

   (4)   Burke, K., M. Petersilka and E.K.U. Gross, 2001, in   _Recent
Advances in Density Functional Methods_, edited by P.    Fantucci and
A. Bencini (World Scientific, Singapure).

   (5) Runge, E. and E. K. U. Gross, 1984, Phys. Rev. Lett. *52* 997.


File: octopus.info,  Node: Installation,  Next: The parser,  Prev: Introduction,  Up: Top

2 Installation
**************

Maybe somebody else installed the `octopus'  for you. In that case, the
files should be under some directory that we can call `PREFIX': the
executables in `PREFIX/bin' (e.g. if `PREFIX=/usr/local', the main
`octopus' executable is then `/usr/local/bin/octopus'); the
documentation in `info' format in `PREFIX/info' (so that you may see it
by typing `info -f PREFIX/info/octopus.info' if the `info' program is
installed in your system); some sample files in
`PREFIX/share/octopus/samples'; the pseudopotential files that
`octopus'  will need in `PREFIX/share/octopus/PP', etc.

   However, you may be unlucky and that is not the case. In the
following we will try to help you with the, still rather unfriendly,
task of compiling and installing the `octopus'  .

* Menu:

* Quick instructions::
* Long instructions::
* Different octopus executables::
* Troubleshooting::


File: octopus.info,  Node: Quick instructions,  Next: Long instructions,  Prev: Installation,  Up: Installation

2.1 Quick instructions
======================

For the inpatients, here goes the quick-start:
     prompt> gzip -cd octopus<-version>.tar.gz | tar xvf -
     prompt> cd octopus-<version>
     prompt> ./configure
     prompt> make
     prompt> make install

   This will probably *not* work, so before giving up, just read the
following paragraphs.

   Also, rpm and deb binaries for linux are supplied on the web-page.


File: octopus.info,  Node: Long instructions,  Next: Different octopus executables,  Prev: Quick instructions,  Up: Installation

2.2 Long instructions
=====================

The code is written in standard Fortran 90, with some routines written
in C (and in bison, if we count the input parser). To build it you will
need both a C compiler (`gcc' works just fine), and a Fortran 90
compiler. No free-software Fortran 90 compiler is available yet, so, if
you want to chew the `octopus', you will have either to help the g95
(http://g95.sourceforge.net) or gfortran (http://gcc.gnu.org/fortran)
projects, or use any of the available comercial compilers.

   Besides the compiler, you will also need:
  1. `make':  most computers have it installed, otherwise just grab and
     install the GNU `make'.

  2. `cpp': The C preprocessor is heavily used in `octopus'.  GNU `cpp'
     is just fine, but any `cpp' that accepts the `-C' flag (preserve
     comments) should work just as well.

  3. FFTW: We have relied on this great library to perform the Fast
     Fourier Transforms (FFTs). You may grab it from here
     (http://www.fftw.org/).  You may use FFTW version 2 as well as
     FFTW version 3. `octopus' will try first to use the latter one,
     since it is significantly faster in some architectures.

  4. LAPACK/BLAS: Required. Our politics is to rely on these two
     libraries as much as possible on these libraries for the linear
     algebra operations.  If you are running Linux, there is a fair
     chance they are already installed in your system. The same goes to
     the more heavyweight machines (alphas, IBMs, SGIs, etc.).
     Otherwise, just grab the source from here (http://www.netlib.org).

  5. GSL: Finally that someone had the nice idea of making a public
     scientific library! GSL still needs to grow, but it is already
     quite useful and impressive.  `octopus' uses splines, complex
     numbers, special functions, etc. from GSL, so it is a must! If you
     don't have it already installed in your system, you can obtain GSL
     from here (http://sources.redhat.com/gsl/). You will need version
     1.0 or higher.

  6. MPI: If you want to run `octopus' in multi-tentacle (parallel)
     mode, you will need an implementation of MPI.  MPICH
     (http://www-unix.mcs.anl.gov/mpi/mpich/) works just fine in our
     Linux boxes.


   First you should obtain the code file, `octopus<-version>.tar.gz',
(this you probably have already done). The code is freely available, and
can be downloaded from `http://www.tddft.org/programs/octopus'. There
exists a `cvs' server, which you can browse at
`http://nautilus.fis.uc.pt/cgi-bin/cvsweb.cgi/marques/octopus/'.  The
sources of the cvs version (in general more unstable the the _official_
distribution) may be downloaded by anonymous cvs access:

     prompt> cvs -d :pserver:anonymous@nautilus.fis.uc.pt:/server/cvsroot
             login

     prompt> cvs -d :pserver:anonymous@nautilus.fis.uc.pt:/server/cvsroot
             co marques/octopus

   Uncompress and untar it (`gzip -cd octopus<-version>.tar.gz | tar
-xvf -').  In the following, `OCTOPUS-HOME' denotes the home directory
of octopus, created by the `tar' command.

   The `OCTOPUS-HOME' contains the following subdirectories:
   * `autom4te.cache, build, CVS, debian': contains files related to
     the building system or the CVS repository. May actually not be
     there.  Not of real interest for the plain user.

   * `doc': The documentation of `octopus' in _texinfo_ format.

   * `liboct': Small C library that handles the interface to GSL and
     the parsing of the input file. It also contains some assorted
     routines that we didn't want to write in boring Fortran.

   * `share/PP': Pseudopotentials.  In practice now it contains the
     Troullier-Martins and Hartwigsen-Goedecker-Hutter pseudopotential
     files.

   * `share/util': Currently, the _utilities_ include a couple of IBM
     OpenDX networks (*note wf.net::), to visualize wavefunctions,
     densities, etc.

   * `share/samples': A couple of sample input files.

   * `src': Fortran 90 source files. Note that these have to be
     preprocessed before being fed to the Fortran compiler, so do not
     be scared by all the # directives.

   Before configuring you can (should) setup a couple of options.
Although the configure script tries to guess your system settings for
you, we recommend that you set explicitly the default Fortran compiler
and the compiler options.  For example, in `bash' you would typically
do:
     export FC=abf90
     export FCFLAGS="-O -YEXT_NAMES=LCS -YEXT_SFX=_"
   if you are using the Absoft Fortran 90 compiler on a linux machine.
Also, if you have some of the required libraries in some unusual
directories, these directories may be placed in the variable `LDFLAGS'
(e.g., `export LDFLAGS=$LDFLAGS:/opt/lib/').

   The configuration script will try to find out which compiler you are
using.  Unfortunately, and due to the nature of the primitive language
that `octopus' is programmed in, the automatic test fails very often.
Often it is better to set the variable `FCFLAGS' by hand. These are
some of the options reported to work:
`intel ifc (PIV)'
     `-u -zero -fpp1 -nbs -i_dynamic -pc80 -pad -align  -unroll -O3 -r8
     -ip -tpp7 -xW'

`absoft (i386)'
     `-O3 -YEXT_NAMES=LCS -YEXT_SFX=_'

`absoft (opteron)'
     `-O3 -mcmodel=medium -m64 -cpu:host -YEXT_NAMES=LCS -YEXT_SFX=_'

`NAG (opteron)'
     `-colour -kind=byte -mismatch_all -abi=64 -ieee=full -O4
     -Ounroll=4'

`pgi (opteron)'
     `-fast -mcmodel=medium -O4'

`alpha'
     `-align dcommons -fast -tune host -arch host -noautomatic'

`xlf (IBM)'
     `-bmaxdata:0x80000000 -qmaxmem=-1 -qsuffix=f=f90 -Q -O5 -qstrict
     -qtune=auto -qarch=auto -qhot -qipa'

`sgi'
     `-O3 -INLINE -n32 -LANG:recursive=on'

   You can now run the configure script (`./configure').  (1) You can
use a fair amount of options to spice `octopus' to your own taste.  To
obtain a full list just type `./configure --help'. Some commonly used
options include:
   * `--prefix=PREFIX': Change the base installation dir of `octopus'
     to `PREFIX'. The executable will be installed in `PREFIX/bin', the
     libraries in `PREFIX/lib' and the documentation in `PREFIX/info'.
     `PREFIX' defaults to the home directory of the user who runs
     `configure'.  (2)

   * `--with-fft=fftw2': Instruct the `configure' script to use the FFTW
     library, and specifically to use the FFTW version 2. You may also
     set `--with-fft=fftw3' or even `--disable-fft', although this last
     option is dis-encouraged.

   * `--with-fft-lib=<lib>': Instruct the `configure' script to look
     for the FFTW library exactly in the way that it is specified in
     the `<lib>' argument, i.e `--with-fft-lib='-L/opt/lib -lfftw3''.

   * `--with-blas=<lib>': Instruct the `configure' script to look for
     the BLAS library in the way that it is specified in the `<lib>'
     argument.

   * `--with-lapack=<lib>': Instruct the `configure' script to look for
     the BLAS library in the way that it is specified in the `<lib>'
     argument.

   * `--with-gsl-prefix=DIR': Installation directory of the GSL
     library. The libraries are expected to be in `DIR/lib' and the
     include files in `DIR/include'. The value of `DIR' is usually
     found by issuing the command `gsl-config --prefix'. (If the GSL
     library is installed, the program `gsl-config' should be
     somewhere.)

   * `--with-netcdf=<lib>': NETCDF library. This is a recommended
     library, although not necessary.

   In addition to these options, several other options have to be
passed to build different executables of octopus (parallel, debugging
version, etc) - *Note Different octopus executables::.

   Run `make', and then `make install'. If everything went fine, you
should now be able to taste `octopus'. Depending on the options passed
to the configure script, some suffixes could be added to the generic
name `octopus' -- i.e. `octopus_cmplx' for the code compiled for
complex wave-functions, `octopus_cmplx_mpi' for a parallel version of
the code compiled for complex wave-function, and so on.

   Depending on the value given to the `--prefix=PREFIX' given, the
executables will reside in `PREFIX/bin', the info file with the
documentation in `PREFIX/info' (so that it may be viewed running `info
-f PREFIX/info/octopus.info'), and the auxiliary files will be copied
to `PREFIX/share/octopus'. The sample input files will be copied to
`PREFIX/share/octopus/samples'.

   The program has been tested in the following platforms:
   * `i686*-linux-gnu': with the Absoft (http://www.absoft.com),   and
     the Intel (http://www.intel.com/software/products/compilers/)
     compiler.

   * `alphae*': both in Linux and in OSF/1 with Compaq's `fort'
     compiler.

   * `powerpc-ibm-aix4.3.3.0': with native `xlf90' compiler.

   * `cray': with native f90 compiler.

   * `opteron': with NAG, PGI, and ABSOFT compilers.

   * `SGI': with native compiler.
   If you manage to compile/run `octopus' on a different platform or
with a different compiler, please let us know so we can update the
list. Patches to solve compiler issues are also welcomed.

   Build the documentation in the format you prefer. Since you are
reading this, you already have it in some format (but maybe not the
correct version).  Due to the power of `texinfo', a series of formats
are available, namely `dvi', `html', `pdf' and `info'. The
`octopus.texi' source code of this document is in the
`OCTOPUS-HOME/doc' directory.

   ---------- Footnotes ----------

   (1) If you downloaded the cvs version, you will not find the
`configure' script.  In order to compile the development version you
will first have to run the GNU autotools.  This may be done by
executing the `autoreconf' perl script (a part of the `autoconf'
distribution).  Note that you need to have working versions of the
`automake' (1.8.5), `autoconf' (2.59) and `libtool' (1.5.6) programs
(the versions we currently use are between parentheses). Note that the
`autoreconf' script will likely fail if you have (much) older versions
of the autotools.

   (2) You may fine-tune further the instalation by making use of a set
of standard options (`--exec-prefix, --bindir, --datadir,
--program-prefix', etc) that are described in the output of
`./configure --help'


File: octopus.info,  Node: Different octopus executables,  Next: Troubleshooting,  Prev: Long instructions,  Up: Installation

2.3 Different octopus executables
=================================

By performing the standard install, you will get an executable called
`octopus', and a set of utility programs called `oct-'_something_.
However, the code may be compiled differently in order to profit from
special feautures (e.g parallel executables, etc). The following is a
list of the options that have to be passed to the `configure' script in
order to obtain these different executables.

   * `--enable-complex': Builds a version with complex wave-functions
     for the ground-state calculations (wave-functions are always
     complex for the evolution). This is needed when spinors are needed
     -- e.g. noncollinear magnetism is going to be considered, or the
     spin-orbit coupling term will be used. The suffix `_cmplx' is
     appended to the `octopus' executable name.

   * `--enable-debug': Builds a version that is able to emit some
     debugging information. Useful for developers, or to report bugs.
     If `octopus' has been built with this option enabled, you may set
     the variable `Verbose' to "debug" level, and set `DebugLevel'
     (*note Verbose:: and *note DebugLevel::, respectively).  The
     suffix `_debug' is appended to the `octopus' executable name.

   * `--enable-single': Builds a version that works in single precision
     mode, rather than in the standard double precision. It will work
     faster.  Unfortunately we are not yet fully sure of the proper
     functioning of the code in this manner.  The suffix `_single' is
     appended to the `octopus' executable name.

   * `--enable-mpi': Builds the parallel version (MPI) of `octopus'.
     The suffix `_mpi' is appended to the `octopus' executable name.



File: octopus.info,  Node: Troubleshooting,  Prev: Different octopus executables,  Up: Installation

2.4 Troubleshooting
===================

If you are reading this it is because something went wrong. Let us see
if we can fix it ;)

   *Could not find library...*: This is probably the most common error
you can get. `octopus' uses three different libraries, GSL, FFTW, and
BLAS/LAPACK. We assume that you have already installed these libraries
but, for some reason, you were not able to compile the code. So, what
went wrong?
   * Did you pass the correct `--with-XXXX' (where XXXX is gsl, fftw or
     lapack in lowercase) to the configure script? If your libraries are
     installed in a non-standard directory (like `/opt/lapack'), you
     will have to pass the script the location of the library (in this
     example, you could try `./configure --with-lapack='-L/opt/lapack
     -llapack''.

   * If you are working on an alpha station, do not forget that the
     `CXML' library includes `BLAS' and `LAPACK', so it can be used by
     `octopus'. If needed, just set the correct path with
     `--with-lapack'.

   * If the configuration script can not find `FFTW', it is probable
     that you did not compile `FFTW' with the same Fortran compiler or
     with the same compiler options. The basic problem is that Fortran
     sometimes converts the function names to uppercase, at other times
     to lowercase, and it can add an "_" to them, or even two.
     Obviously all libraries and the program have to use the same
     convention, so the best is to compile everything with the same
     Fortran compiler/options. If you are a power user, you can check
     the convention used by your compiler using the command `nm
     <library>'.


   *Whatever went wrong...*: Up to now, we cannot really make a list of
commonly found problems. So if something else went wrong, please
subscribe to `octopus-users' mailing list, and ask.


File: octopus.info,  Node: The parser,  Next: Input file options,  Prev: Installation,  Up: Top

3 The parser
************

All input options should be in a file called "`inp'", in the directory
`octopus' is run from. Alternatively, if this file is not found,
standard input is read. For a fairly comprehensive example, just look
at the file `OCTOPUS_HOME/share/samples/Na2' -- if you installed the
code (you did the `make install'), this file will also be in
`PREFIX/share/octopus/samples/Na2'.

   At the beginning of the program `liboct' reads the input file,
parses it, and generates a list of variables that will be read by
`octopus' (note that the input is case independent).  There are two
kind of variables, scalar values (strings or numbers), and blocks (that
you may view as matrices). A scalar variable `var' can be defined by:
     var = exp
   `var' can contain any alphanumeric character plus "_", and `exp' can
be a quote delimited string, a number (integer, real, or complex), a
variable name, or a mathematical expression.  In the expressions all
arithmetic operators are supported ("a+b", "a-b", "a*b", "a/b"; for
exponentiation the C syntax "a^b" is used), and the following functions
can be used:
   * `sqrt(x)': The square root of `x'.

   * `exp(x)': The exponential of `x'.

   * `log(x)' or `ln(x)': The natural logarithm of `x'.

   * `log10(x)': Base 10 logarithm of `x'.

   * `sin(x)', `cos(x)', `tan(x)', `cot(x)',   `sec(x)', `csc(x)': The
     sinus, co-sinus, tangent, co-tangent,   secant and co-secant of
     `x'.

   * `asin(x)', `acos(x)', `atan(x)', `acot(x)',   `asec(x)',
     `acsc(x)': The inverse (arc-) sinus, co-sinus, tangent, co-tangent,
      secant and co-secant of `x'.

   * `sinh(x)', `cosh(x)', `tanh(x)', `coth(x)',   `sech(x)',
     `csch(x)': The hyperbolic sinus, co-sinus, tangent, co-tangent,
     secant and co-secant of `x'.

   * `asinh(x)', `acosh(x)', `atanh(x)', `acoth(x)',   `asech(x)',
     `acsch(x)': The inverse hyperbolic sinus, co-sinus, tangent,
     co-tangent,   secant and co-secant of `x'.
   You can also use any of the predefined variables:
   * `pi': 3.141592653589793, what else is there to say?

   * `e': The base of the natural logarithms.

   * `false' or `f' or `no': False in all its flavors. For the
     curious, `false' is defined as 0.

   * `true' or `t' or `yes': The truthful companion of `false'. For the
      curious, `true' is defined as 1.

   Blocks are defined as a collection of values, organised in row and
column format.  The syntax is the following:
     %var
       exp | exp | exp | ...
       exp | exp | exp | ...
       ...
     %
   Rows in a block are separated by a newline, while columns are
separated by the character "|" or by a tab. There may be any number of
lines and any number of columns in a block. Note also that each line
can have a different number of columns.

   If `octopus' tries to read a variable that is not defined in the
input file, it automatically assigns to it a default value. All
variables read are output to the file "`out.oct'". If you are not sure
of what the program is reading, just take a look at it.  Everything
following the character "#" until the end of the line is considered a
comment and is simply cast into oblivion.


File: octopus.info,  Node: Input file options,  Next: External utilities,  Prev: The parser,  Up: Top

4 Input file options
********************

`octopus' has quite a few options, that we will subdivide in different
groups.  After the name of the option, its type and default value (when
applicable) are given in parenthesis.

* Menu:

* Generalities::
* Species Block::
* Coordinates Description::
* Mesh::
* States::
* Hamiltonian::
* Exchange and correlation::
* SCF::
* Unoccupied States::
* Time Dependent::
* Geometry optimization::
* Function output for visualization::
* Spectrum calculations::
* Varia::


File: octopus.info,  Node: Generalities,  Next: Species Block,  Prev: Input file options,  Up: Input file options

4.1 Generalities
================

* Menu:

* SystemName::
* Dimensions::
* CalculationMode::
* Units::
* UnitsInput::
* UnitsOutput::
* Verbose::
* DebugLevel::


File: octopus.info,  Node: SystemName,  Next: Dimensions,  Prev: Generalities,  Up: Generalities

4.1.1 `SystemName' (string, 'system')
-------------------------------------

A string that identifies the current run. This parameter is seldomly
used, but it is sometimes useful to have in the input file.


File: octopus.info,  Node: Dimensions,  Next: CalculationMode,  Prev: SystemName,  Up: Generalities

4.1.2 `Dimensions' (integer, 3)
-------------------------------

`octopus' can run in 1, 2 or 3 dimensions, depending on the value of
this variable. Note that not all options may be available in all cases.


File: octopus.info,  Node: CalculationMode,  Next: Units,  Prev: Dimensions,  Up: Generalities

4.1.3 `CalculationMode' (integer, gs_start)
-------------------------------------------

This is a very important variable, since it defines the type of
simulation to perform. The options are:
   - `gs_start': Start static calculation.

   - `gs': Resume static calculation.

   - `unocc_start': Calculate unoccuppied states.

   - `unocc': Resume calculation of unoccupied states.

   - `td_start': Start time-dependent propagation.

   - `td': Resume time-dependent propagation.

   - `pol_start': Start static polarizability calculation.

   - `pol': Resume static polarizability calculation.

   - `geom': Perform geometry minimization.

   - `phonon': Calculates the phonon spectrum of the system.

   - `opt_control': _Optimum control_ mode (experimental).

   - `recipe': Print out an octopus recipe.


File: octopus.info,  Node: Units,  Next: UnitsInput,  Prev: CalculationMode,  Up: Generalities

4.1.4 `Units' (string, 'a.u')
-----------------------------

Atomic units seem to be the preferred system in the atomic and
molecular physics community (despite the opinion of some of the authors
of this program). Internally, the code works in atomic units. However,
for input or output, some people like using eV for energies and AA for
lengths. This other system of units (the _convenient system_, in words
of Prof. George F. Bertsch), can also be used.  Valid options are:
   - `'a.u'': atomic units

   - `'eVA'': electron-volts/aangstro"m


File: octopus.info,  Node: UnitsInput,  Next: UnitsOutput,  Prev: Units,  Up: Generalities

4.1.5 `UnitsInput' (string, 'a.u.'):
------------------------------------

Same as `Units', but only refers to the values in the input file.  That
is, if `UnitsInput = "eVA"', all physical values in the input files
will be considered to be in eV and AA.


File: octopus.info,  Node: UnitsOutput,  Next: Verbose,  Prev: UnitsInput,  Up: Generalities

4.1.6 `UnitsOutput' (string, 'a.u.')
------------------------------------

Same as `Units', but only refers to the values in the output files.
That is, if `UnitsOutput = "eVA"', all physical values in the output
files will be written in eV and AA.


File: octopus.info,  Node: Verbose,  Next: DebugLevel,  Prev: UnitsOutput,  Up: Generalities

4.1.7 `Verbose' (integer, 30)
-----------------------------

Verbosity level of the program. The higher, the more verbose `octopus'
is. Current levels are:
   - `Verbose <=  0': Silent mode. No output except fatal errors.

   - `Verbose >   0': Warnings only.

   - `Verbose >  20': Normal program info.

   - `Verbose > 999': Debug mode. Issues a message to standard error
     every time the  program enters an (important) subroutine, and
     prints the time it spend upon return. It only works for
     executables that have been compiled with debugging capabilities
     (the configure script was given the `--enable-debug' option).


File: octopus.info,  Node: DebugLevel,  Prev: Verbose,  Up: Generalities

4.1.8 `DebugLevel' (integer, 3)
-------------------------------

In debug mode (`Verbose > 999'), it restricts the output of entry/exit
subroutine information to the required level.


File: octopus.info,  Node: Species Block,  Next: Coordinates Description,  Prev: Generalities,  Up: Input file options

4.2 Species Block
=================

* Menu:

* Species::


File: octopus.info,  Node: Species,  Prev: Species Block,  Up: Species Block

4.2.1 `Species' (block data)
----------------------------

A specie is by definition either an "ion" (nucleus + core electrons)
described through a pseudo-potential, or an user-defined, model
potential.  The format of this block is different for 1, 2 or 3
dimensions, and can be best understood through examples.

   * In 1D, or 2D, e.g.
            %Species
              'H'  | 1.0079 | 1 | "-1/sqrt(x^2 + 1)"
            %
     This defines a species labelled '`H'' of weight `1.0079', and
     valence charge `1'. This "valence charge" is used to calculate the
     number of electrons present in the calculation: as many as
     indicated by the valence charges of the species, plus any extra
     charge specified by the user (*note States::). The last field may
     be any user defined potetial - use `x', `r' (and `y' in the 2D
     case) for the position of the electron relative to the species
     center.  For example, the potential often used in 1D calculation is
     the soft-Coulomb potential -Z/\sqrtx^2 + 1. The previous example
     would then be an appropriate description of a Hydrogen nucleus for
     one-dimensional calculations.

   * In 3D, e.g.
            %Species
              'O'       | 15.9994 | 8   | "tm2"  | 1 | 1
              'H'       |  1.0079 | 1   | "hgh"  | 0 | 0
              'jelli01' | 23.2    | 8.0 |  5.0
              'point01' | 32.3    | 2.0
              'usdef'   | 1       | 8   | "1/2*r^2"
            %
     In this case, we have 5 "species" present, which exemplify the
     five kinds that may be present:
        - Oxygen labelled '`O''. Next number is the atomic mass (in
          atomic mass units), and third field, the atomic number (8, in
          this case).  Afterwards, "tm2" is the flavour of the
          pseudopotential: "tm2" stands for Troullier-Martins. This
          means the pseudopotential will be read from an `O.ascii' or
          `O.vps' file, either in the working directory or in the
          `OCTOPUS-HOME/share/PP/TM2' directory.  Next two numbers are
          the maximum _l_-component of the pseudo-potential to consider
          in the calculation, and the _l_-component to consider as
          local.

        - Hydrogen defined in the same way as Oxygen. In this case,
          however, the flavour is "hgh" standing for
          Hartwigsen-Goedecker-Hutter. Last two numbers are irrelevant,
          since they do are not necessary to define the HGH
          pseudopotentials.

        - All species whose label starts by 'jelli' are jellium spheres.
          The other parameters are the weight, the nuclear charge, and
          the valence charge of the sphere.

        - All species whose label starts by 'point' are point charges.
          The other parameters are the weight and the nuclear charge. In
          fact, point charges are implemented as _rather small_ jellium
          spheres, with zero valence charge.

        - All species whose label starts by 'usdef' are user defined
          potentials. The second parameter is the mass, whereas the
          third parameter is the 'valence charge', used to calculate
          the number of electrons.  Finally, the potential itself is
          defined by the fourth argument.  Use any of the `x', `y', `z'
          or `r' variables to define the potential.

     Note that some common pseudopotentials are distributed with the
     code in the directory `OCTOPUS-HOME/share/PP/'. To use these
     pseudopotentials you are not required to define them explicitly in
     the `Species' block, as defaults are provided by the program (you
     can override these defaults in any case).  Additional
     pseudopotentials can be downloaded from the `octopus' homepage
     (http://www.tddft.org/programs/octopus/pseudo.php).



File: octopus.info,  Node: Coordinates Description,  Next: Mesh,  Prev: Species Block,  Up: Input file options

4.3 Coordinates Description
===========================

`octopus' successively tries to read the atomic coordinates from a PDB
file, a XYZ file, or else directly from the input file.

* Menu:

* PDBCoordinates::
* XYZCoordinates::
* Coordinates::
* XYZVelocities::
* Velocities::
* RandomVelocityTemp::


File: octopus.info,  Node: PDBCoordinates,  Next: XYZCoordinates,  Prev: Coordinates Description,  Up: Coordinates Description

4.3.1 `PDBCoordinates' (string, 'coords.pdb')
---------------------------------------------

Tries to read the atomic coordinates from the file specified by the
variable `PDBCoordinates'.  The PDB (Protein Data Bank
(http://www.rcsb.org/pdb/)) format is quite complicated, and it goes
well beyond the scope of this manual. You can find a comprehensive
description in
`http://www.rcsb.org/pdb/docs/format/pdbguide2.2/guide2.2_frame.html'.
From the plethora of instructions defined in the PDB standard, `octopus'
only reads two, `ATOM' and `HETATOM'. From these fields, it reads:
   - columns 13-16 : The specie; in fact `octopus' only cares about the
     first letter - 'CA' and 'CB' will both refer to Carbon - so
     elements whose chemical symbol has more than one letter can not be
     represented in this way.  So, if you want to run mercury ('Hg')
     please use one of the other two methods to input the atomic
     coordinates, `XYZCoordinates' or `Coordinates'.

   - columns 18-21 : The residue. If residue is 'QM', the atom is
     treated in Quantum Mechanics, otherwise it is simply treated as an
     external classical point charge. Its charge will be given by
     columns 61-65.

   - columns 31-54 : The Cartesian coordinates. The Fortran format is
     `'(3f8.3)''.

   - columns 61-65 : Classical charge of the atom. The Fortran format is
     `'(f6.2)''.


File: octopus.info,  Node: XYZCoordinates,  Next: Coordinates,  Prev: PDBCoordinates,  Up: Coordinates Description

4.3.2 `XYZCoordinates' (string, 'coords.xyz')
---------------------------------------------

If `PDBCoordinates' is not present, reads the atomic coordinates from
the XYZ file specified by the variable `XYZCoordinates'. The XYZ format
is very simple, as can be seem from this example for the CO molecule
(in AA).
     2
     CO molecule in equilibrium
         C  -0.56415   0.0   0.0
         O   0.56415   0.0   0.0
   The first line of the file has an integer indicating the number of
atoms. The second can contain comments that are simply ignored by
`octopus'. Then there follows one line per each atom, containing the
chemical species and the Cartesian coordinates of the atom.


File: octopus.info,  Node: Coordinates,  Next: XYZVelocities,  Prev: XYZCoordinates,  Up: Coordinates Description

4.3.3 `Coordinates' (block data)
--------------------------------

If neither a `XYZCoordinates' nor a `PDBCoordinates' was found,
`octopus' tries to read the coordinates for the atoms from the block
`Coordinates'. The format is quite straightforward:
         %Coordinates
           'C' | -0.56415 | 0.0 | 0.0 | no
           'O' |  0.56415 | 0.0 | 0.0 | no
         %
   The first line defines a Carbon atom at coordinates (`-0.56415',
`0.0', `0.0'), that is _not_ allowed to move during dynamical
simulations. The second line has a similar meaning. This block
obviously defines a Carbon monoxide molecule, if the input units are
AA. Note that in this way it is possible to fix some of the atoms (this
is not possible when specifying the coordinates through a
`PDBCoordinates' or `XYZCoordinates' file). It is always possible to
fix _all_ atoms using the `MoveIons' directive.


File: octopus.info,  Node: XYZVelocities,  Next: Velocities,  Prev: Coordinates,  Up: Coordinates Description

4.3.4 `XYZVelocities' (string, 'velocities.xyz')
------------------------------------------------

`octopus' will try to read the starting velocities of the atoms from
the XYZ file specified by the variable `XYZVelocities'
('velocities.xyz' by default).  Note that you do not need to specify
initial velocities if you are not going to perform ion dynamics; if you
are going to allow the ions to move but the velocities are not
specified, they are considered to be null.


File: octopus.info,  Node: Velocities,  Next: RandomVelocityTemp,  Prev: XYZVelocities,  Up: Coordinates Description

4.3.5 `Velocities' (block data)
-------------------------------

If `XYZVelocities' is not present, `octopus' will try to fetch the
initial atomic velocities from this block. If this block is not
present, `octopus' will reset the initial velocities to zero. The
format of this block can be illustrated by this example:
         %Velocities
           'C'  | -1.7 | 0.0 | 0.0
           'O'  |  1.7 | 0.0 | 0.0
         %
   It describes one Carbon and one Oxygen moving at the relative
velocity of `3.4', velocity units.  Note: It is important for the
velocities to maintain the ordering in which the species were defined
in the coordinates specifications.


File: octopus.info,  Node: RandomVelocityTemp,  Prev: Velocities,  Up: Coordinates Description

4.3.6 `RandomVelocityTemp' (double, 0)
--------------------------------------

If this variable is present, `octopus' will assign random velocities to
the atoms following a Bolzmann distribution with temperature
`RandomVelocityTemp'.


File: octopus.info,  Node: Mesh,  Next: States,  Prev: Coordinates Description,  Up: Input file options

4.4 Mesh
========

`octopus' uses a grid in real space to solve the Kohn-Sham equations.
The grid is equally-spaced, but the spacings can be different for each
Cartesian direction. The shape of the simulation region may also be
tuned to suit the geometric configuration of the system.

* Menu:

* BoxShape::
* Radius::
* Lsize::
* XLength::
* Spacing::
* DerivativesSpace::
* OrderDerivatives::
* DoubleFFTParameter::
* FFTOptimize::


File: octopus.info,  Node: BoxShape,  Next: Radius,  Prev: Mesh,  Up: Mesh

4.4.1 `BoxShape' (integer, minimum)
-----------------------------------

It is the shape of the simulation box. The allowed values are:
   - `sphere': A sphere

   - `cylinder': A cylinder. The cylinder axis will be in the z
     direction

   - `minimum': Sum of spheres around each atom.

   - `parallelepiped': As the name indicates.
   For a one-dimensional calculation, it would obviously always be a 1D
"sphere".


File: octopus.info,  Node: Radius,  Next: Lsize,  Prev: BoxShape,  Up: Mesh

4.4.2 `Radius' (double, 20.0 a.u.)
----------------------------------

If `BoxShape != parallelepiped' defines the radius of the spheres or of
the cylinder.


File: octopus.info,  Node: Lsize,  Next: XLength,  Prev: Radius,  Up: Mesh

4.4.3 `Lsize' (block data)
--------------------------

In case `BoxShape = parallelepiped', this is assumed to be a block of
the form:
         %Lsize
           sizex | sizey | sizez
         %
   where the `size*' are half of the lengths of the box in each
direction.


File: octopus.info,  Node: XLength,  Next: Spacing,  Prev: Lsize,  Up: Mesh

4.4.4 `XLength' (double, 1.0 a.u.)
----------------------------------

If `BoxShape == cylinder', it is half the total length of the cylinder.


File: octopus.info,  Node: Spacing,  Next: DerivativesSpace,  Prev: XLength,  Up: Mesh

4.4.5 `Spacing' (double, 0.6 a.u.) or (block data)
--------------------------------------------------

If the code is compiled in 1D mode or if `BoxShape != parallelepiped'
defines the (constant) spacing between points in the grid. Otherwise, it
is assumed to be a block of the form:
         %Spacing
           spacingx | spacingy | spacingz
         %


File: octopus.info,  Node: DerivativesSpace,  Next: OrderDerivatives,  Prev: Spacing,  Up: Mesh

4.4.6 `DerivativesSpace' (integer, real_space)
----------------------------------------------

Defines in which space gradients and the Laplacian are calculated.
Allowed values are:
   - `real_space': Derivatives are calculated in real-space       using
     finite differences. The order of the derivative can be set with
       `OrderDerivatives'.

   - `fourier_space': Derivatives are calculated in       reciprocal
     space. Obviously this case implies cyclic boundary conditions,
      so be careful.


File: octopus.info,  Node: OrderDerivatives,  Next: DoubleFFTParameter,  Prev: DerivativesSpace,  Up: Mesh

4.4.7 `OrderDerivatives' (integer, 4)
-------------------------------------

If `DerivativesSpace == real_space' use a finite difference
discretisation of this order for the derivatives, that is a
`OrderDerivatives*2 + 1' formula.  See [_octopus: a first principles
tool for excited states electron-ion dynamics_, Comp. Phys. Comm.
*151*, 60 (2003)] for details.


File: octopus.info,  Node: DoubleFFTParameter,  Next: FFTOptimize,  Prev: OrderDerivatives,  Up: Mesh

4.4.8 `DoubleFFTParameter' (real, 2.0)
--------------------------------------

For solving Poisson equation in Fourier space, and for applying the
local potential in Fourier space, an auxiliary cubic mesh is built.
This mesh will be larger than the circumscribed cube to the usual mesh
by a factor `DoubleFFTParameter'. See the section that refers to
Poisson equation, and to the local potential for details [The default
value of two is typically good].


File: octopus.info,  Node: FFTOptimize,  Prev: DoubleFFTParameter,  Up: Mesh

4.4.9 `FFTOptimize' (logical, true)
-----------------------------------

Should `octopus' optimize the FFT dimension?  This means that the cubic
mesh to which FFTs are applied is not taken to be as small as possible:
some points may be added to each direction in order to get a "good
number" for the performance of the FFT algorithm.  In some cases,
namely when using the split-operator, or Suzuki-Trotter propagators,
this option should be turned off.


File: octopus.info,  Node: States,  Next: Hamiltonian,  Prev: Mesh,  Up: Input file options

4.5 States
==========

* Menu:

* SpinComponents::
* ExcessCharge::
* ExtraStates::
* Occupations::
* ElectronicTemperature::


File: octopus.info,  Node: SpinComponents,  Next: ExcessCharge,  Prev: States,  Up: States

4.5.1 `SpinComponents' (integer, 1)
-----------------------------------

Defines the spin mode `octopus' will run in. Valid modes are:
   - `unpolarized': Spin-unpolarised calculation. That is, the code
     will attempt to put two-electrons per orbital.

   - `polarized': Spin-polarised calculation (collinear spin). This mode
     will double the number of wave-functions necessary for a
     spin-unpolarised calculation.

   - `non_collinear': Non-collinear spin. This mode will double the
     number of wave-functions necessary for a spin-unpolarised
     calculation, and each of the wave-functions will be a two-spinor.
     This effectively allows the spin-density to arrange
     non-collinearly - i.e. the magnetization vector is allowed to take
     different directions in different points.


File: octopus.info,  Node: ExcessCharge,  Next: ExtraStates,  Prev: SpinComponents,  Up: States

4.5.2 `ExcessCharge' (double, 1)
--------------------------------

The net charge of the system. A negative value means that we are adding
electrons, while a positive value means we are taking electrons from
the system.


File: octopus.info,  Node: ExtraStates,  Next: Occupations,  Prev: ExcessCharge,  Up: States

4.5.3 `ExtraStates' (integer, 0)
--------------------------------

The number of states is in principle calculated considering the minimum
numbers of states necessary to hold the electrons present in the system.
The number of electrons is in turn calculated considering the nature of
the species supplied in the `Species' block (*note Species::), and the
value of the `ExcessCharge' variable - see *Note ExcessCharge::.
However, one may command `octopus'  to put more states, which is
necessary if one wants to use fractional occupational numbers, either
fixed from the origin through the `Occupations' block (*note
Occupations::) or by prescribing an artifactal electronic temperature
(*note ElectronicTemperature::).

   Note that this number is unrelated to `CalculationMode == 4'.


File: octopus.info,  Node: Occupations,  Next: ElectronicTemperature,  Prev: ExtraStates,  Up: States

4.5.4 `Occupations' (block data)
--------------------------------

The occupation numbers of the orbitals can be fixed through the use of
this variable. For example:
         %Occupations
           2.0 | 2.0 | 2.0 | 2.0 | 2.0
         %
   would fix the occupations of the five states to `2.0'. There must be
as many columns as states in the calculation. If `SpinComponents ==
polarized' this block should contain two lines, one for each spin
channel.  This variable is very useful when dealing with highly
symmetric small systems (like an open shell atom), for it allows us to
fix the occupation numbers of degenerate states in order to help
`octopus' to converge. This is to be used in conjuction with
`ExtraStates'. For example, to calculate the carbon atom, one would do:
       ExtraStates=2
       %Occupations
           2 | 2/3 | 2/3 | 2/3
         %


File: octopus.info,  Node: ElectronicTemperature,  Prev: Occupations,  Up: States

4.5.5 `ElectronicTemperature' (double, 0.0)
-------------------------------------------

If `Occupations' is not set, `ElectronicTemperature' is the temperature
in the Fermi-Dirac function used to distribute the electrons among the
existing states.


File: octopus.info,  Node: Hamiltonian,  Next: Exchange and correlation,  Prev: States,  Up: Input file options

4.6 Hamiltonian
===============

* Menu:

* NonInteractingElectrons::
* ClassicPotential::
* LocalPotentialSpace::
* RelativisticCorrection::


File: octopus.info,  Node: NonInteractingElectrons,  Next: ClassicPotential,  Prev: Hamiltonian,  Up: Hamiltonian

4.6.1 `NonInteractingElectrons' (logical, false)
------------------------------------------------

If `true', treat the electrons as non-interacting, i.e. neglect both
Hartree and exchange-correlation contributions to the Kohn-Sham
potential.  A probable choice for one-electron problems.


File: octopus.info,  Node: ClassicPotential,  Next: LocalPotentialSpace,  Prev: NonInteractingElectrons,  Up: Hamiltonian

4.6.2 `ClassicPotential' (logical, false)
-----------------------------------------

If `true', add to the external potential the potential generated by the
point charges read from the PDB input (see `PBDCoordinates').


File: octopus.info,  Node: LocalPotentialSpace,  Next: RelativisticCorrection,  Prev: ClassicPotential,  Up: Hamiltonian

4.6.3 `LocalPotentialSpace' (integer, fourier_space)
----------------------------------------------------

If `fourier_space', generate the local part of the pseudo-potential in
Fourier space; Otherwise do it directly in real space. The auxiliary
box defined via the `DoubleFFTParameter' is used for this purpose.


File: octopus.info,  Node: RelativisticCorrection,  Prev: LocalPotentialSpace,  Up: Hamiltonian

4.6.4 `RelativisticCorrection' (integer, no)
--------------------------------------------

The default value means that _no_ relativistic correction is used. To
include spin-orbit coupling turn `RelativisticCorrection' to
`spin_orbit' or `1' (this will only work when using an executable
compiled for complex wave-functions, and if `SpinComponents' has been
set to `non_collinear', which ensures the use of spinors).


File: octopus.info,  Node: Exchange and correlation,  Next: SCF,  Prev: Hamiltonian,  Up: Input file options

4.7 Exchange and correlation
============================

The exchange-correlation functional is controlled by the parameters
`XFunctional', and `CFunctional'.  The possible values are:

* Menu:

* XFunctional::
* CFunctional::
* OEP_level::
* SICCorrection::


File: octopus.info,  Node: XFunctional,  Next: CFunctional,  Prev: Exchange and correlation,  Up: Exchange and correlation

4.7.1 `XFunctional' (integer, lda_x)
------------------------------------

   * `XFunctional == lda_x':

   * `XFunctional == gga_x_pbe':

   * `XFunctional == gga_xc_lb':

   * `XFunctional == mgga_x_tpss':

   * `XFunctional == oep_x':


File: octopus.info,  Node: CFunctional,  Next: OEP_level,  Prev: XFunctional,  Up: Exchange and correlation

4.7.2 `CFunctional' (integer, lda_c_pz)
---------------------------------------

   * `CFunctional == lda_c_wigner':

   * `CFunctional == lda_c_rpa':

   * `CFunctional == lda_c_hl':

   * `CFunctional == lda_c_gl':

   * `CFunctional == lda_c_xalpha':

   * `CFunctional == lda_c_vw':

   * `CFunctional == lda_c_pz':

   * `CFunctional == lda_c_ob_pz':

   * `CFunctional == lda_c_pw':

   * `CFunctional == lda_c_ob_pw':

   * `CFunctional == lda_c_lyp':

   * `CFunctional == lda_c_amgb':

   * `CFunctional == gga_c_pbe':

   * `CFunctional == mgga_c_tpss':


File: octopus.info,  Node: OEP_level,  Next: SICCorrection,  Prev: CFunctional,  Up: Exchange and correlation

4.7.3 `OEP_level' (integer, oep_none)
-------------------------------------

   * `OEP_level = oep_none'

   * `OEP_level = oep_slater'

   * `OEP_level = oep_kli'

   * `OEP_level = oep_ceda'

   * `OEP_level = oep_full'


File: octopus.info,  Node: SICCorrection,  Prev: OEP_level,  Up: Exchange and correlation

4.7.4 `SICCorrection' (integer, 0)
----------------------------------


File: octopus.info,  Node: SCF,  Next: Unoccupied States,  Prev: Exchange and correlation,  Up: Input file options

4.8 SCF
=======

The ground-state electronic density in a Kohn-Sham (KS) based
electronic structure code such as `octopus'  is obtained after a
self-consistent process that attempts to solve the KS equations.  In
essence, the problem is the following: at a given iteration step, one
departs from an approximated solution - some KS eigenfunctions
\psi^inp_j, eigenvalues \epsilon^inp_j and density \rho^inp, which
determines a KS "input" Hamiltonian. By diagonalizing this Hamiltonian,
one obtains the corresponding "output" eigenfunctions, eigenvalues, and
density.  This cycle is considered to be closed, and the solution
achieved, when some convergence criterion is fulfilled.  In our case,
we have allowed for four different criteria, to be defined below.  The
self consistent procedure will stop when the first of the convergence
criteria is fulfilled, or either when a a maximum number of iterations
has been performed.

* Menu:

* MaximumIter::
* ConvAbsDens::
* ConvRelDens::
* ConvAbsEv::
* ConvRelEv::
* GuessMagnetDensity::
* AtomsMagnetDirection::
* LCAOStart::
* SCFinLCAO::
* EigenSolver::
* EigenSolverInitTolerance::
* EigenSolverFinalTolerance::
* EigenSolverFinalToleranceIteration::
* EigenSolverMaxIter::
* What2Mix::
* TypeOfMixing::
* Mixing::
* MixNumberSteps::


File: octopus.info,  Node: MaximumIter,  Next: ConvAbsDens,  Prev: SCF,  Up: SCF

4.8.1 `MaximumIter' (integer, 200)
----------------------------------

Maximum number of SCF iterations. The code will stop even if convergence
has not been achieved. `0' means unlimited.


File: octopus.info,  Node: ConvAbsDens,  Next: ConvRelDens,  Prev: MaximumIter,  Up: SCF

4.8.2 `ConvAbsDens' (double, 1e-5)
----------------------------------

Absolute convergence of the density:


\epsilon = \int {\rm d}^3r (\rho^{out}(\bf r) -\rho^{inp}(\bf r))^2

   A zero value means do not use this criterion.


File: octopus.info,  Node: ConvRelDens,  Next: ConvAbsEv,  Prev: ConvAbsDens,  Up: SCF

4.8.3 `ConvRelDens' (double, 0)
-------------------------------

Relative convergence of the density:


\epsilon = {1\over N} \int {\rm d}^3r (\rho^{out}(\bf r) -\rho^{inp}(\bf r))^2

   N is the total number of electrons in the problem.  A zero value
means do not use this criterion.


File: octopus.info,  Node: ConvAbsEv,  Next: ConvRelEv,  Prev: ConvRelDens,  Up: SCF

4.8.4 `ConvAbsEv' (double, 0)
-----------------------------

Absolute convergence of the eigenvalues:


\epsilon = \sum_{j=1}^{N_{occ}} \vert \epsilon_j^{out}-\epsilon_j^{inp}\vert\,.

   A zero value means do not use this criterion.


File: octopus.info,  Node: ConvRelEv,  Next: GuessMagnetDensity,  Prev: ConvAbsEv,  Up: SCF

4.8.5 `ConvRelEnergy' (double, 0)
---------------------------------

Relative convergence of the eigenvalues:


\epsilon = {1 \over N} \sum_{j=1}^{N_{occ}} \vert \epsilon_j^{out}-\epsilon_j^{inp}\vert\,.

   N is the total number of electrons. A zero value means do not use
this criterion.


File: octopus.info,  Node: GuessMagnetDensity,  Next: AtomsMagnetDirection,  Prev: ConvRelEv,  Up: SCF

4.8.6 `GuessMagnetDensity' (integer, polarized)
-----------------------------------------------

The guess density for the SCF cycle is just the sum of all the atomic
densities.  When performing spin-polarized or non-collinear spin
calculations this option sets the guess magnetization density.
Possible values are:
   - `paramagnetic':  Magnetization density is zero.

   - `ferromagnetic': Magnetization density is the sum of the atomic
     magnetization densities.

   - `random': Each atomic magnetization density is randomly rotated.

   - `user_defined': The atomic magnetization densities are rotated so
     that the magnetization                                vector has
     the same direction as a vector provided by the user.
   When the `user_defined' option is used the `AtomsMagnetDirection'
block has to be set.

   For anti-ferromagnetic configurations the `user_defined' option
should be used.

   Note that if the `paramagnetic' option is used the final
ground-state will also be paramagnetic, but the same is not true for
the other options.


File: octopus.info,  Node: AtomsMagnetDirection,  Next: LCAOStart,  Prev: GuessMagnetDensity,  Up: SCF

4.8.7 `AtomsMagnetDirection' (block data)
-----------------------------------------

This option is only used when `GuessMagnetDensity' is set to
`user_defined'. It provides a direction for each atoms magnetization
vector when building the guess density. In order to do that the user
should specifie the coordinates of a vector that has the desired
direction. The norm of the vector is ignored. Note that it is necessaty
to maintain the ordering in which the species were defined in the
coordinates specifications.

   For spin-polarized calculations the vectors should have only one
component and for non-collinear spin calculations they should have
three components.


File: octopus.info,  Node: LCAOStart,  Next: SCFinLCAO,  Prev: AtomsMagnetDirection,  Up: SCF

4.8.8 `LCAOStart' (logical, true)
---------------------------------

Before starting a SCF calculation, performs a LCAO calculation. These
should provide `octopus' with a good set of initial wave-functions, and
help the convergence of the SCF cycle.  (Up to current version, only a
minimal basis set used.)


File: octopus.info,  Node: SCFinLCAO,  Next: EigenSolver,  Prev: LCAOStart,  Up: SCF

4.8.9 `SCFinLCAO' (logical, false)
----------------------------------

Performs all the SCF cycle restricting the calculation to the LCAO
subspace.  This may be useful for systems with convergence problems
(first do a calculation within the LCAO subspace, then restart from
that point for an unrestricted calculation).


File: octopus.info,  Node: EigenSolver,  Next: EigenSolverInitTolerance,  Prev: SCFinLCAO,  Up: SCF

4.8.10 `EigenSolver' (integer, cg):
-----------------------------------

At each SCF cycle step, a diagonalisation of the Hamiltonian is
performed.  This variable chooses the eigensolver used to diagonalise
the Kohn-Sham Hamiltonian.  Possible values are:
   - `cg': Conjugated Gradients method.

   - `lanczos': Block-Lanczos method.
   Look up the source to know what the differences are.

   In both cases, for the first iterations of the cycle there is no
need to perform a very precise diagonalisation. Because of this, we may
define a varying tolerance, so that at the first iteration a given small
tolerance is achieved, and then this tolerance is linearly increased
until a given iteration, after which a maximum tolerance is always
asked.  Next variables take care of this process.


File: octopus.info,  Node: EigenSolverInitTolerance,  Next: EigenSolverFinalTolerance,  Prev: EigenSolver,  Up: SCF

4.8.11 `EigenSolverInitTolerance' (double, 1.0e-10)
---------------------------------------------------

This is the initial tolerance for the eigenvectors.


File: octopus.info,  Node: EigenSolverFinalTolerance,  Next: EigenSolverFinalToleranceIteration,  Prev: EigenSolverInitTolerance,  Up: SCF

4.8.12 `EigenSolverFinalTolerance' (double, 1.0e-14)
----------------------------------------------------

This is the final tolerance for the eigenvectors.


File: octopus.info,  Node: EigenSolverFinalToleranceIteration,  Next: EigenSolverMaxIter,  Prev: EigenSolverFinalTolerance,  Up: SCF

4.8.13 `EigenSolverFinalToleranceIteration' (integer, 7)
--------------------------------------------------------

Determines how many interactions are needed to go from
`EigenSolverInitTolerance' to `EigenSolverFinalTolerance'.


File: octopus.info,  Node: EigenSolverMaxIter,  Next: What2Mix,  Prev: EigenSolverFinalToleranceIteration,  Up: SCF

4.8.14 `EigenSolverMaxIter' (integer, 25)
-----------------------------------------

It determines the maximum number of iterations for the eigensolver (per
state) -- that is, if this number is reached, the diagonalisation is
stopped even if the desired tolerance was not achieved.


File: octopus.info,  Node: What2Mix,  Next: TypeOfMixing,  Prev: EigenSolverMaxIter,  Up: SCF

4.8.15 `What2Mix' (integer, density)
------------------------------------

Selects what should be mixed during the SCF cycle. Possible values are:
   - `density': Density

   - `potential': Potential


File: octopus.info,  Node: TypeOfMixing,  Next: Mixing,  Prev: What2Mix,  Up: SCF

4.8.16 `TypeOfMixing' (integer, broyden)
----------------------------------------

Selects the mixing procedure to be used during the SCF cycle. Possible
values are:
   - `linear': Linear mixing.

   - `gr_pulay': Guaranteed-reduction Pulay (GR-Pulay).

   - `broyden': Broyden mixing.


File: octopus.info,  Node: Mixing,  Next: MixNumberSteps,  Prev: TypeOfMixing,  Up: SCF

4.8.17 `Mixing' (double, 0.3)
-----------------------------

Determines the amount of the new density/potential which is to be mixed
with the old one. Used only by linear mixing and Broyden mixing.


File: octopus.info,  Node: MixNumberSteps,  Prev: Mixing,  Up: SCF

4.8.18 `MixNumberSteps' (integer, 3)
------------------------------------

Number of steps used by Broyden mixing or GR-Pulay mixing to
extrapolate the new density/potential.


File: octopus.info,  Node: Unoccupied States,  Next: Time Dependent,  Prev: SCF,  Up: Input file options

4.9 Unoccupied States
=====================

These variables are only used in `CalculationMode == unocc,
unocc_start'. The purpose of these run modes is to calculate higher
lying Kohn-Sham orbitals. For that purpose, it reads the restart
information from a converged previous ground-state calculation, and
builds the corresponding Hamiltonian. Then, it calculates the
eigenvalues and eigenfunctions that are requested by the user.

   Note: These variables are also used in `CalculationMode = td' or
`td_start' if `TDOccupationalAnalysis == 1').

* Menu:

* UnoccNumberStates::
* UnoccMaximumIter::
* UnoccConv::


File: octopus.info,  Node: UnoccNumberStates,  Next: UnoccMaximumIter,  Prev: Unoccupied States,  Up: Unoccupied States

4.9.1 `UnoccNumberStates' (integer, 5)
--------------------------------------

How many unoccupied states to compute.


File: octopus.info,  Node: UnoccMaximumIter,  Next: UnoccConv,  Prev: UnoccNumberStates,  Up: Unoccupied States

4.9.2 `UnoccMaximumIter' (integer, 200)
---------------------------------------

Maximum number of iterations while calculating the unoccupied states.
Note that these are _not_ SCF iterations, for the density and the
Hamiltonian are not updated! These iterations correspond to the
iterative _diagonalization_ of the Hamiltonian.


File: octopus.info,  Node: UnoccConv,  Prev: UnoccMaximumIter,  Up: Unoccupied States

4.9.3 `UnoccConv' (double, 1e-4)
--------------------------------

Absolute convergence in the eigenvectors. So don't try to put it too
good or else you won't converge.


File: octopus.info,  Node: Time Dependent,  Next: Geometry optimization,  Prev: Unoccupied States,  Up: Input file options

4.10 Time Dependent
===================

When `CalculationMode = (td | td_start)', the code performs the time
propagation of the electronic orbitals and - if required - of the ionic
positions. This latter task does not pose major algorithmical problems
(the usual Verlet algorithms deal with that task); however the best way
to propagate a Schro"dinger-like equation is still unclear. Due to this
fact, we provide with a rather excessive selection of possibilities for
that purpose. Before describing the set of variables necessary to
specify the way in which the time evolution is to be performed, it is
worth making a brief introduction to the problem.

   We are concerned with a set of Schro"dinger-like equations for the
electronic orbitals:

   i{\partial psi_i \over \partial t} = H(t)\psi_i(t)\,,

   \psi_i(t=0) = \psi_i^0\,.

   Being the equation linear, one may formally define a linear
"evolution" operator, which trasforms the initial vector into the
solution at time T:

   \psi_i(T) = U(T, 0)\psi_i^0

   Moreover, there is a formal exact expression for the evolution
operator:

   \psi_i(T) = T\exp\lbrace -i\!\!\int_0^{T}d\tau H(\tau)\rbrace
\psi_i^0\,.

   where T\exp is the time-ordered exponential. If the Hamiltonian
conmutes with itself at different times, we can drop the time-ordering
product, and leave a simple exponential.  If the Hamiltonian is
time-independent - which makes it trivially self commuting, the
solution is then simply written as:

   \psi_i(T) = \exp\lbrace -iTH\rbrace \psi_i^0\,.

   Unfortunately, this is not the case in general. We have to find an
algorithm able to cope with time-dependent Hamiltonians, such as the
self-consistent time-dependent Kohn-Sham operator, which is built "self
consistently" from the varying electronic density.

   The first step is to perform a time-discretization: the full
propagation between 0 and T is decomposed as:

   U(T,0) = \prod_{i=0}^{N-1}U(t_i+\delta t,t_i)\,,

   where t_0=0, t_N=T, \delta t = T/N. So at each time step we are
dealing with the problem of performing the short-time propagation:

   \psi_i(t+\delta t) = U(t+\delta t, t)\psi_i(t) = T\exp\lbrace
-i\!\!\int_{t}^{t+\delta t}\!\!\!\!\!\!\!\!\!d\tau\,H(\tau)\rbrace
\psi(t)\,.

   In this way, one can monitor the evolution in the interior of [0,t].
In fact, the possibility of monitoring the evolution is generally a
requirement; this requirement imposes a natural restriction on the
maximum size of \delta t: if \omega_\rm max is the maximum frequency
that we want to discern, \delta t should be no larger than \approx
1/\omega_\rm max.  Below this \delta t_\rm max, we are free to choose
\delta t considering performance reasons: Technically, the reason for
the discretization is twofold: the time-dependence of H is alleviated,
and the norm of the exponential argument is reduced (the norm increases
linearly with \delta t).

   Since we cannot drop the time-ordering product, the desired algorithm
cannot be reduced, in principle, to the calculation of the action of
the exponential of an operator over the initial vector.  Some
algorithms tailored to approximate the evolution operator, in fact, do
not even require to peform such operator exponentials.  Most of them,
however, do rely on the calculation of one or more exponentials, such
as the ones used by `octopus'. This is why in principle we need to
specify two different issues: the "evolution method", and the
"exponential method". In other words: we need an algorithm to
approximate the evolution operator U(t+\delta t, t) - which will be
specified by variable `TDEvolutionMethod' (*note TDEvolutionMethod::) -
and, if this algorithm requires it, we will also need an algorithm to
approximate the exponential of a matrix operator \exp\lbrace A\rbrace -
which will be specified by variable `TDExponentialMethod' (*note
TDExponentialMethod::).

* Menu:

* TDMaximumIter::
* TDTimeStep::
* TDExponentialMethod::
* TDExpOrder::
* TDLanczosTol::
* TDEvolutionMethod::
* TDLasers::
* TDGauge::
* TDDeltaStrength::
* TDPolarization::
* TDOutputMultipoles::
* TDDipoleMax::
* TDOutputCoordinates::
* TDOutputGSProjection::
* TDOutputAcceleration::
* TDOutputLaser::
* TDOutputElEnergy::
* TDOutputOccAnalysis::
* MoveIons::
* AbsorbingBoundaries::
* ABWidth::
* ABHeight::


File: octopus.info,  Node: TDMaximumIter,  Next: TDTimeStep,  Prev: Time Dependent,  Up: Time Dependent

4.10.1 `TDMaximumIter' (integer, 1500)
--------------------------------------

Number of time steps in which the total integration time is divided; in
previous notation, N.


File: octopus.info,  Node: TDTimeStep,  Next: TDExponentialMethod,  Prev: TDMaximumIter,  Up: Time Dependent

4.10.2 `TDTimeStep' (double, 0.07 a.u.)
---------------------------------------

Time-step for the propagation; in previous notation, \delta t.


File: octopus.info,  Node: TDExponentialMethod,  Next: TDExpOrder,  Prev: TDTimeStep,  Up: Time Dependent

4.10.3 `TDExponentialMethod' (integer, standard)
------------------------------------------------

Method used to numerically calculate the exponential of the Hamiltonian,
a core part of the full algorithm used to approximate the evolution
operator, specified through the variable `TDEvolutionMethod' (*note
TDEvolutionMethod::).  In the case of using the Magnus method,
described below, the action of the exponential of the Magnus operator
is also calculated through the algorithm specified by this variable.

   - `split': Split-operator (SO).

     It is important to distinguish between applying the split operator
     method to calculate the exponential of the Hamiltonian at a given
     time - which is what this variable is referring to - from the
     split operator method as an algorithm to approximate the full
     evolution operator U(t+\delta t, t), and which will be described
     below as one of the possibilities of the variable
     `TDEvolutionMethod'.  The equation that describes the split
     operator scheme is well known:

     \exp_{\rm SO} (-i \delta t H) = \exp (-i \delta t/2 V) \exp (-i
     \delta t T) \exp (-i \delta t/2 V)\,.

     Note that this is a "kinetic referenced SO", since the kinetic
     term is sandwiched in the middle. This is so because in `octopus',
     the states spend most of its time in real-space; doing it
     "potential referenced" would imply 4 FFTs instead of 2.  This
     split-operator technique may be used in combination with, for
     example, the exponential midpoint rule as a means to approximate
     the evolution operator.  In that case, the potential operator `V'
     that appears in the equation would be calculated at time t+\delta
     t/2, that is, in the middle of the time-step.  However, note that
     if the split-operator method is invoked as a means to approximate
     the evolution operator (`TDEvolutionMethod = 0'), a different
     procedure is taken - it will be described below -, and in fact the
     variable `TDExponentialMethod' has no effect at all.

   - `suzuki-trotter': Suzuki-Trotter (ST).

     This is a higher-order SO based algorithm. See O. Sugino and Y.
     Miyamoto, Phys. Rev. B *59*, 2579 (1999). Allows for larger
     time-steps, but requires five times more time than the normal SO.

     The considerations made above for the SO algorithm about the
     distinction between using the method as a means to approximate
     `U(t+\delta t)' or as a means to approximate the exponential also
     apply here. Setting `TDEvolutionMethod = 1' enforces the use of
     the ST as an algorithm to approximate the full evolution operator,
     which is slightly different (see below).

   - `lanczos': Lanczos approximation (LAN).

     Allows for larger time-steps.  However, the larger the time-step,
     the longer the computational time per time-step.  In certain
     cases, if the time-step is too large, the code will emit a warning
     whenever it considers that the evolution may not be properly
     proceeding - the Lanczos process did not converge. The method
     consists in a Krylov subspace approximation of the action of the
     exponential (see M. Hochbruck and C. Lubich, SIAM J. Numer. Anal.
     *34*, 1911 (1997) for details).  Two more variables control the
     performance of the method: the maximum dimension of this subspace
     (controlled by variable `TDExpOrder'), and the stopping criterium
     (controlled by variable `TDLanczosTol').  The smaller the stopping
     criterium, the more precisely the exponential is calculated, but
     also the larger the dimension of the Arnoldi subspace. If the
     maximum dimension allowed by `TDExpOrder' is not enough to meet
     the criterium, the above-mentioned warning is emitted.

   - `standard': N-th order standard expansion of the exponential (STD).

     This method amounts to a straightforward application of the
     definition of the exponential of an operator, in terms of it
     Taylor expansion.

     \exp_{\rm STD} (-i\delta t H) = \sum_{i=0}^{k} {(-i\delta
     t)^i\over{i!}} H^i.

     The order k is determined by variable `TDExpOder' (*note
     TDExpOrder::).  Some numerical considerations (by Jeff
     Giansiracusa and George F. Bertsch; see
     `http://www.phys.washington.edu/~bertsch/num3.ps') suggest the 4th
     order as especially suitable and stable.

   - `chebyshev': N-th order Chebyshev expansion (CHEB).

     In principle, the Chebyshev expansion of the exponential
     represents it more accurately than the canonical or standard
     expansion.  As in the latter case, `TDExpOrder' determines the
     order of the expansion.

     There exists a closed analytical form for the coefficients of the
     exponential in terms of Chebyshev polynomials:

     \exp_{\rm CHEB} \left( -i\delta t H \right) = \sum_{k=0}^{\infty}
     (2-\delta_{k0})(-i)^{k} J_k(\delta t) T_k(H),

     where J_k are the Bessel functions of the first kind, and H has te
     be previously scaled to [-1,1].  See H. Tal-Ezer and R. Kosloff,
     J. Chem. Phys. *81*, 3967 (1984); R. Kosloff, Annu. Rev. Phys.
     Chem. *45*, 145 (1994); C. W. Clenshaw, MTAC *9*, 118 (1955).



File: octopus.info,  Node: TDExpOrder,  Next: TDLanczosTol,  Prev: TDExponentialMethod,  Up: Time Dependent

4.10.4 `TDExpOrder' (integer, 4)
--------------------------------

For `TDExponentialMethod' equal `standard' or `chebyshev', the order to
which the exponential is expanded. For the Lanczos approximation, it is
the maximum Lanczos-subspace dimension.


File: octopus.info,  Node: TDLanczosTol,  Next: TDEvolutionMethod,  Prev: TDExpOrder,  Up: Time Dependent

4.10.5 `TDLanczosTol' (real, 5e-4)
----------------------------------

An internal tolerance variable for the Lanczos method. The smaller, the
more precisely the exponential is calculated, and also the bigger the
dimension of the Krylov subspace needed to perform the algorithm. One
should carefully make sure that this value is not too big, or else the
evolution will be wrong.


File: octopus.info,  Node: TDEvolutionMethod,  Next: TDLasers,  Prev: TDLanczosTol,  Up: Time Dependent

4.10.6 `TDEvolutionMethod' (integer, etrs)
------------------------------------------

This variable determines which algorithm will be used to approximate
the evolution operator U(t+\delta t, t). That is, known \psi(\tau) and
H(\tau) for tau \le t, calculate t+\delta t. Note that in general the
Hamiltonian is not known at times in the interior of the interval
[t,t+\delta t].  This is due to the self-consistent nature of the
time-dependent Kohn-Sham problem: the Hamiltonian at a given time \tau
is built from the "solution" wavefunctions at that time.

   Some methods, however, do require the knowledge of the Hamiltonian
at some point of the interval [t,t+\delta t]. This problem is solved by
making use of extrapolation: given a number l of time steps previous to
time t, this information is used to build the Hamiltonian at arbitrary
times within [t,t+\delta t]. To be fully precise, one should then
proceed _self-consistently_: the obtained Hamiltonian at time t+\delta t
may then be used to interpolate the Hamiltonian, and repeat the
evolution algorithm with this new information. Whenever iterating the
procedure does not change the solution wave-functions, the cycle is
stopped. In practice, in `octopus' we perform a second-order
extrapolation without self-consistente check, except for the first two
iterations, where obviously the extrapolation is not reliable.

   * `split': Split Operator (SO).

     This is one of the most traditional methods. It splits the full
     Hamiltonian into a kinetic and a potential part, performing the
     first in Fourier-space, and the latter in real space. The
     necessary transformations are performed with the FFT algorithm.

     U_{\rm SO}(t+\delta t, t) = \exp \lbrace - {i \over 2}\delta t T
     \rbrace              \exp \lbrace -i\delta t V^* \rbrace
       \exp \lbrace - {i \over 2}\delta t T \rbrace

     Since those three exponentials may be calculated exactly, one does
     not need to use any of the methods specified by variable
     `TDExponentialMethod' to perform them.

     The key point is the specification of V^*. Let V(t) be divided into
     V_\rm int(t), the "internal" potential which depends
     self-consistently on the density, and V_\rm ext(t), the external
     potential that we know at all times since it is imposed to the
     system by us (e.g. a laser field): V(t)=V_\rm int(t)+V_\rm ext(t).
     Then we define to be V^* to be the sum of V_\rm ext(t+\delta t/2)
     and the internal potential built from the wavefunctions _after_
     applying the right-most kinetic term of the equation, \exp \lbrace
     -i\delta t/2 T \rbrace.

     It may the be demonstrated that the order of the error of the
     algorithm is the same that the one that we would have by making
     use of the Exponential Midpoint Rule (EM, described below), the SO
     algorithm to calculate the action of the exponential of the
     Hamiltonian, and a full self-consistent procedure.

   * `suzuki-trotter' Suzuki-Trotter (ST).

     This is the generalization of the Suzuki-Trotter algorithm,
     described as one of the choices of the `TDExponentialMethod'
     (*note TDExponentialMethod::), to time-dependent problem. Consult
     the paper by O. Sugino and M. Miyamoto, Phys. Rev. B *59*, 2579
     (1999), for details.

     It requires of Hamiltonian extrapolations.

   * `etrs': Enforced Time-Reversal Symmetry (ETRS).

     The idea is to make use of the time-reversal symmetry from the
     beginning:

     \exp \left(-i\delta t/2 H_{n}\right)\psi_n = exp \left(i\delta t/2
     H_{n+1}\right) \psi_{n+1},

     and then invert to obtain:

     \psi_{n+1} = \exp \left(-i\delta t/2 H_{n+1}\right) exp
     \left(-i\delta t/2 H_{n}\right) \psi_{n}.

     But we need to know H_n+1, which can only be known exactly through
     the solution \psi_n+1. What we do is to estimate it by performing
     a single exponential: \psi^*_n+1=\exp \left( -i\delta t H_n
     \right) \psi_n, and then H_n+1 = H[\psi^*_n+1]. Thus no
     extrapolation is performed in this case.

   * `aetrs': Approximated Enforced Time-Reversal Symmetry (AETRS).

     A modification of previous method to make it faster.  It is based
     on extrapolation of the time-dependent potentials. It is faster by
     about 40%.

     The only difference is the procedure to estimate H_n+1: in this
     case it is extrapolated trough a second-order polynomial by making
     use of the Hamiltonian at time t-2\delta t, t-\delta t and t.

   * `exp_mid': Exponential Midpoint Rule (EM).

     This is maybe the simplest method, but is is very well grounded
     theretically: it is unitary (if the exponential is performed
     correctly) and preserves time symmetry (if the self-consistency
     problem is dealt with correctly).  It is defined as:

     U_{\rm EM}(t+\delta t, t) = \exp \left( -i\delta t H_{t+\delta
     t/2}\right)\,.

   * `magnus': Magnus Expansion (M4).  This is the most sophisticated
     approach. It is a fourth order scheme (feature that shares with
     the ST scheme; the other schemes are in principle second order).
     It is tailored for making use of very large time steps, or
     equivalently, dealing with problem with very high-frequency time
     dependence.  It is still in a experimental state; we are not yet
     sure of when it is advantageous.


   This proliferation of methods is certainly excessive; The reason for
it is that the propagation algorithm is currently a topic of active
development. We hope that in the future the optimal schemes are clearly
identified. In the mean time, if you don't feel like testing, use the
default choices and make sure the time step is small enough.


File: octopus.info,  Node: TDLasers,  Next: TDGauge,  Prev: TDEvolutionMethod,  Up: Time Dependent

4.10.7 `TDLasers' (block data)
------------------------------

Each line of the block describes a laser pulse applied to the system.
The syntax is:
         %TDLasers
           polx | poly | polz | A0 | omega0 | envelope | tau0 | t0
         %
   where `pol' is the (complex) polarisation of the laser field, `A0'
the amplitude, `envelope' the envelope function, `t0' the middle
(maximum) of the pulse and `omega0' the frequency of the pulse. The
meaning of `tau0' depends on the envelope function.  The possible
values for `envelope' are:

   - `1': Gaussian envelope. `tau0' is the standard deviation of the
     pulse.

   - `2': Cosinoidal envelope. `tau0' is half the total length of the
     pulse.

   - `3': Ramp. In this case there is an extra parameter `tau1'. `tau0'
     is the length of the constant part of the ramp, and `tau1' is the
     raising (decaying) time. `tau1' should be an extra field after
     `t0'.

   - `10': Shape is read from a file.

   If `envelope=10', the `t0' parameter is substituted by a string that
determines the name of the file. The format of this file should be three
columns of real numbers: time, field and phase. Atomic units are
assumed. The values for the laser field that the program will use are
interpolated / extrapolated from this numerically defined function.


File: octopus.info,  Node: TDGauge,  Next: TDDeltaStrength,  Prev: TDLasers,  Up: Time Dependent

4.10.8 `TDGauge' (integer, length)
----------------------------------

In which gauge to treat the laser. Options are:
   - `length': Length gauge.

   - `velocity': Velocity gauge.


File: octopus.info,  Node: TDDeltaStrength,  Next: TDPolarization,  Prev: TDGauge,  Up: Time Dependent

4.10.9 `TDDeltaStrength' (double, 0.0 a.u.)
-------------------------------------------

When no laser is applied, a delta (in time) electric field with
strength `TDDeltaStrength' is applied. This is used to calculate the
linear optical spectra.


File: octopus.info,  Node: TDPolarization,  Next: TDOutputMultipoles,  Prev: TDDeltaStrength,  Up: Time Dependent

4.10.10 `TDPolarization' (block data)
-------------------------------------

The (real) polarisation of the delta electric field. The format of the
block is:
         %TDPolarization
           polx | poly | polz
         %
   In order to calculate dichroism the polarisation has to be
generalized to complex. Also some input/output and the
`strength-function' utility have to be changed. It is a nice little
project if someone is interested in getting into `octopus'.


File: octopus.info,  Node: TDOutputMultipoles,  Next: TDDipoleMax,  Prev: TDPolarization,  Up: Time Dependent

4.10.11 `TDOutputMultipoles' (logical, true)
--------------------------------------------

If true, outputs the multipole moments of the density to the file
`td.general/multipoles'.  This is required to, e.g., calculate optical
absorption spectra of finite systems.


File: octopus.info,  Node: TDDipoleMax,  Next: TDOutputCoordinates,  Prev: TDOutputMultipoles,  Up: Time Dependent

4.10.12 `TDDipoleLmax' (integer , 1)
------------------------------------

Maximum multi-pole of the density output to the file
`td.general/multipoles' during a time-dependent simulation.


File: octopus.info,  Node: TDOutputCoordinates,  Next: TDOutputGSProjection,  Prev: TDDipoleMax,  Up: Time Dependent

4.10.13 `TDOutputCoordinates' (logical, `MoveIons' > 0 )
--------------------------------------------------------

If true (and if the atoms are allowed to move), outputs the
coordinates, velocities, and forces of the atoms to the the file
`td.general/coordinates'.


File: octopus.info,  Node: TDOutputGSProjection,  Next: TDOutputAcceleration,  Prev: TDOutputCoordinates,  Up: Time Dependent

4.10.14 `TDOutputGSProjection' (logical, false)
-----------------------------------------------

If true, outputs the projection of the time-dependent Kohn-Sham Slater
determinant onto the ground-state to the file
`td.general/gs_projection'. As the calculation of the projection is
fairly heavy, this is only done every `OutputEvery' iterations.


File: octopus.info,  Node: TDOutputAcceleration,  Next: TDOutputLaser,  Prev: TDOutputGSProjection,  Up: Time Dependent

4.10.15 `TDOutputAcceleration' (logical, false)
-----------------------------------------------

When _true_ outputs the acceleration, calculated from Ehrenfest theorem,
in the file `td.general/acceleration'. This file can then be processed
by the utility "hs-from-acc" in order to obtain the harmonic spectrum.


File: octopus.info,  Node: TDOutputLaser,  Next: TDOutputElEnergy,  Prev: TDOutputAcceleration,  Up: Time Dependent

4.10.16 `TDOutputLaser' (logical, true)
---------------------------------------

If `true', `octopus' outputs the laser field to the file
"`td.general/laser'".


File: octopus.info,  Node: TDOutputElEnergy,  Next: TDOutputOccAnalysis,  Prev: TDOutputLaser,  Up: Time Dependent

4.10.17 `TDOutputElEnergy' (logical, false)
-------------------------------------------

If `true', `octopus' outputs the different components of the electronic
energy to the file `td.general/el_energy'.


File: octopus.info,  Node: TDOutputOccAnalysis,  Next: MoveIons,  Prev: TDOutputElEnergy,  Up: Time Dependent

4.10.18 `TDOutputOccAnalysis' (logical, false)
----------------------------------------------

If true, outputs the projections of the time-dependent Kohn-Sham
wave-functions onto the static (zero time) wave-functions to the file
`td.general/projections.XXX'.


File: octopus.info,  Node: MoveIons,  Next: AbsorbingBoundaries,  Prev: TDOutputOccAnalysis,  Up: Time Dependent

4.10.19 `MoveIons' (integer, no)
--------------------------------

What kind of simulation to perform. Possible values are:
   - `no': Do not move the ions.

   - `verlet': Newtonian dynamics using Verlet.

   - `vel_verlet': Newtonian dynamics using velocity Verlet.


File: octopus.info,  Node: AbsorbingBoundaries,  Next: ABWidth,  Prev: MoveIons,  Up: Time Dependent

4.10.20 `AbsorbingBoundaries' (integer, no)
-------------------------------------------

To improve the quality of the spectra by avoiding the formation of
standing density waves, one can make the boundaries of the simulation
box absorbing. The possible values for this parameter are:
   - `no': No absorbing boundaries.

   - `sin2': A sin^2 imaginary potential is added at the boundaries.

   - `mask': A mask is applied to the wave-functions at the boundaries.


File: octopus.info,  Node: ABWidth,  Next: ABHeight,  Prev: AbsorbingBoundaries,  Up: Time Dependent

4.10.21 `ABWidth' (real, 0.4 a.u.):
-----------------------------------

Width of the region used to apply the absorbing boundaries.


File: octopus.info,  Node: ABHeight,  Prev: ABWidth,  Up: Time Dependent

4.10.22 `ABHeight' (real, -0.2 a.u.)
------------------------------------

When `AbsorbingBoundaries == sin2', is the height of the imaginary
potential.


File: octopus.info,  Node: Geometry optimization,  Next: Function output for visualization,  Prev: Time Dependent,  Up: Input file options

4.11 Geometry optimization
==========================

* Menu:

* GOMethod::
* GOTolerance::
* GOMaxIter::
* GOStep::


File: octopus.info,  Node: GOMethod,  Next: GOTolerance,  Prev: Geometry optimization,  Up: Geometry optimization

4.11.1 `GOMethod' (integer, steep)
----------------------------------

Method by which the minimization is performed. The only possible value
is   `steep' (simple steepest descent).


File: octopus.info,  Node: GOTolerance,  Next: GOMaxIter,  Prev: GOMethod,  Up: Geometry optimization

4.11.2 `GOTolerance' (real, 0.0001)
-----------------------------------

Convergence criterium to stop the minimization. In units of force;
minimization   is stopped when all forces on ions are smaller.


File: octopus.info,  Node: GOMaxIter,  Next: GOStep,  Prev: GOTolerance,  Up: Geometry optimization

4.11.3 `GOMaxIter' (integer, 200)
---------------------------------

Even if previous convergence criterium is not satisfied, minimization
will stop   after this number of iterations.


File: octopus.info,  Node: GOStep,  Prev: GOMaxIter,  Up: Geometry optimization

4.11.4 `GOStep' (double, 0.5)
-----------------------------

Initial step for the geometry optimizer.


File: octopus.info,  Node: Function output for visualization,  Next: Spectrum calculations,  Prev: Geometry optimization,  Up: Input file options

4.12 Function output for visualization
======================================

Every given number of time iterations, or after ground-state
calculations, some of the functions that characterise the system may be
written to disk so that they may be analized. Files are written within
"static" output directory after the self-consistent field, or within
"td.x" directories, during evolution, where "x" stands for the
iteration number at which each write is done.  Note that if you wish to
plot any function (`OutputKSPotential = yes', etc.), at least one of
the output formats should be enabled (`OutputPlaneX = yes', `OutputDX =
yes', `OutputNETCDF = yes', etc.). [This is not necessary if you wish
to plot the geometry (`OutputGeometry = yes')]. Note further that the
data written by `OutputAxisX', `OutputPlaneX' etc. has always the
(side) length of the longest axis; this is independent from the  chosen
geometry. Data points which are inexistent in the actual geometry have
the value zero in those files.

* Menu:

* OutputKSPotential::
* OutputDensity::
* OutputWfs::
* OutputWfsNumber::
* OutputElf::
* OutputGeometry::
* OutputAxisX::
* OutputAxisY::
* OutputAxisZ::
* OutputPlaneX::
* OutputPlaneY::
* OutputPlaneZ::
* OutputDX::
* OutputNETCDF::
* OutputEvery::


File: octopus.info,  Node: OutputKSPotential,  Next: OutputDensity,  Prev: Function output for visualization,  Up: Function output for visualization

4.12.1 `OutputKSPotential' (logical, false)
-------------------------------------------

Prints out Kohn-Sham potential, separated by parts. File names would be
"v0" for the local part, "vc" for the classical potential (if it
exists), "vh" for the Hartree potential, and "vxc-x" for each of the
exchange and correlation potentials of a give spin channel, where "x"
stands for the spin channel.


File: octopus.info,  Node: OutputDensity,  Next: OutputWfs,  Prev: OutputKSPotential,  Up: Function output for visualization

4.12.2 `OutputDensity' (logical, false)
---------------------------------------

Prints out the density. The output file is called "density-i", where
"i" stands for the spin channel.


File: octopus.info,  Node: OutputWfs,  Next: OutputWfsNumber,  Prev: OutputDensity,  Up: Function output for visualization

4.12.3 `OutputWfs' (logical, false)
-----------------------------------

Prints out wave-functions. Which wavefunctions are to be printed is
specified by the variable `OutputWfsNumber' - see below. The output
file is called "wf-k-p-i", where k stands for the _k_ number, p for the
state, and i for the spin channel.


File: octopus.info,  Node: OutputWfsNumber,  Next: OutputElf,  Prev: OutputWfs,  Up: Function output for visualization

4.12.4 `OutputWfsNumber' (string, "1-1024")
-------------------------------------------

Which wavefunctions to print, in list form, i.e., "1-5" to print the
first five states, "2,3" to print the second and the third state, etc.


File: octopus.info,  Node: OutputElf,  Next: OutputGeometry,  Prev: OutputWfsNumber,  Up: Function output for visualization

4.12.5 `OutputELF' (logical, false)
-----------------------------------

Prints out the electron localization function, ELF. The output file is
called   "elf-i", where i stands for the spin channel.


File: octopus.info,  Node: OutputGeometry,  Next: OutputAxisX,  Prev: OutputElf,  Up: Function output for visualization

4.12.6 `OutputGeometry' (logical, false)
----------------------------------------

If true `octopus' outputs a XYZ file called "geometry.xyz" containing
the coordinates of the atoms treated within Quantum Mechanics. If point
charges were defined in the PDB file (see `PDBCoordinates'), they will
be output in the file "geometry_classical.xyz".


File: octopus.info,  Node: OutputAxisX,  Next: OutputAxisY,  Prev: OutputGeometry,  Up: Function output for visualization

4.12.7 `OutputAxisX' (logical, false)
-------------------------------------

The values of the function on the x axis are printed. The string
".y=0,z=0" is appended to previous file names.


File: octopus.info,  Node: OutputAxisY,  Next: OutputAxisZ,  Prev: OutputAxisX,  Up: Function output for visualization

4.12.8 `OutputAxisY' (logical, false)
-------------------------------------

The values of the function on the y axis are printed. The string
".x=0,z=0" is appended to previous file names.


File: octopus.info,  Node: OutputAxisZ,  Next: OutputPlaneX,  Prev: OutputAxisY,  Up: Function output for visualization

4.12.9 `OutputAxisZ' (logical, false)
-------------------------------------

The values of the function on the z axis are printed. The string
".x=0,y=0" is appended to previous file names.


File: octopus.info,  Node: OutputPlaneX,  Next: OutputPlaneY,  Prev: OutputAxisZ,  Up: Function output for visualization

4.12.10 `OutputPlaneX' (logical, false)
---------------------------------------

A plane slice at x=0 is printed. The string ".x=0" is appended to
previous file names.


File: octopus.info,  Node: OutputPlaneY,  Next: OutputPlaneZ,  Prev: OutputPlaneX,  Up: Function output for visualization

4.12.11 `OutputPlaneY' (logical, false)
---------------------------------------

A plane slice at y=0 is printed. The string ".y=0" is appended to
previous file names.


File: octopus.info,  Node: OutputPlaneZ,  Next: OutputDX,  Prev: OutputPlaneY,  Up: Function output for visualization

4.12.12 `OutputPlaneZ' (logical, false)
---------------------------------------

A plane slice at y=0 is printed. The string ".z=0" is appended to
previous file names.


File: octopus.info,  Node: OutputDX,  Next: OutputNETCDF,  Prev: OutputPlaneZ,  Up: Function output for visualization

4.12.13 `OutputDX' (logical, false)
-----------------------------------

For printing all the three dimensional information, the open source
program visualization tool OpenDX (`http://www.opendx.org/') is used.
The string ".dx" is appended to previous file names.  *Note wf.net::.


File: octopus.info,  Node: OutputNETCDF,  Next: OutputEvery,  Prev: OutputDX,  Up: Function output for visualization

4.12.14 `OutputNETCDF' (logical, false)
---------------------------------------

Outputs in NetCDF (`http://www.unidata.ucar.edu/packages/netcdf/')
format. This file can then be read, for example, by OpenDX. The string
".ncdf" is appended to previous file names.


File: octopus.info,  Node: OutputEvery,  Prev: OutputNETCDF,  Up: Function output for visualization

4.12.15 `OutputEvery' (integer, 1000)
-------------------------------------

`OutputEvery' The output is saved when the iteration number is a
multiple of the `OutputEvery' variable.


File: octopus.info,  Node: Spectrum calculations,  Next: Varia,  Prev: Function output for visualization,  Up: Input file options

4.13 Spectrum calculations
==========================

Once `octopus' has been run, results must be analyzed somehow. The most
common thing is to Fourier-transform something to calculate spectra.
This may be done through some utilities (`strength-function',
`hs-from-mult', `hs-from-acc' which are described in section "External
utilities." Common options read by these utilities are:

* Menu:

* SpecTransformNode::
* SpecDampMode::
* SpecDampFactor::
* SpecStartTime::
* SpecEndTime::
* SpecEnergyStep::
* SpecMinEnergy::
* SpecMaxEnergy::
* HSPolarization::


File: octopus.info,  Node: SpecTransformNode,  Next: SpecDampMode,  Prev: Spectrum calculations,  Up: Spectrum calculations

4.13.1 `SpecTransformMode' (string, 'sin')
------------------------------------------

What kind of Fourier transform is calculated. 'sin' and 'cos' are the
valid options, with obvious meanings.


File: octopus.info,  Node: SpecDampMode,  Next: SpecDampFactor,  Prev: SpecTransformNode,  Up: Spectrum calculations

4.13.2 `SpecDampMode' (string, 'exp')
-------------------------------------

A damping function may be applied to the input fuction before
processing the Fourier transform. This function may be an exponential,
a third order polynomial (fit to be one at t=0, and also its
derivative,  and null at t=T), or a gaussian: "exp" or "pol" or "gau".
It amounts to applying a convolution of the signal in Fourier space,
either with a Lorentzian function (for the exponential), with a
Gaussian function (for the Gaussian), or with some other function (in
the case of the third order polynomial.  If this variable is not
present or has any other value, no damping function is applied.


File: octopus.info,  Node: SpecDampFactor,  Next: SpecStartTime,  Prev: SpecDampMode,  Up: Spectrum calculations

4.13.3 `SpecDampFactor' (real, 0.0)
-----------------------------------

If `SpecDampMode' is set to "exp", the damping parameter of the
exponential is fixed through this variable.


File: octopus.info,  Node: SpecStartTime,  Next: SpecEndTime,  Prev: SpecDampFactor,  Up: Spectrum calculations

4.13.4 `SpecStartTime' (real, 0.0)
----------------------------------

Processing is done for the given function in a time-window that starts
at the value of this variable.


File: octopus.info,  Node: SpecEndTime,  Next: SpecEnergyStep,  Prev: SpecStartTime,  Up: Spectrum calculations

4.13.5 `SpecEndTime' (real, -1.0)
---------------------------------

Processing is done for the given function in a time-window that ends at
the value of this variable.


File: octopus.info,  Node: SpecEnergyStep,  Next: SpecMinEnergy,  Prev: SpecEndTime,  Up: Spectrum calculations

4.13.6 `SpecEnergyStep' (real, 0.05)
------------------------------------

Sampling rate for the spectrum.


File: octopus.info,  Node: SpecMinEnergy,  Next: SpecMaxEnergy,  Prev: SpecEnergyStep,  Up: Spectrum calculations

4.13.7 `SpecMinEnergy' (real, 0.0)
----------------------------------

The Fourier transform is calculated for energies bigger than this value.


File: octopus.info,  Node: SpecMaxEnergy,  Next: HSPolarization,  Prev: SpecMinEnergy,  Up: Spectrum calculations

4.13.8 `SpecMaxEnergy' (real, 20.0)
-----------------------------------

The Fourier transform is calculated for energies smaller than this
value.


File: octopus.info,  Node: HSPolarization,  Prev: SpecMaxEnergy,  Up: Spectrum calculations

4.13.9 `HSPolarization' (string, 'z')
-------------------------------------

For the utilities `hs-from-acc', and `hs-from-mult', the polarization
of the laser pulse must be specified. Valid values are "x", "y" and "z"
for lasers linearly polarized along the respective axis, or "+" or "-"
for lasers circularly polarized. See the description of `hs-from-acc'
and `hs-from-mult' for more details.


File: octopus.info,  Node: Varia,  Prev: Spectrum calculations,  Up: Input file options

4.14 Varia
==========

* Menu:

* PoissonSolver::
* POLStaticField::
* Displacement::


File: octopus.info,  Node: PoissonSolver,  Next: POLStaticField,  Prev: Varia,  Up: Varia

4.14.1 `PoissonSolver' (integer, 3)
-----------------------------------

In 3D defines which method to use in order to solve the Poisson
equation.  Allowed values are:
   - `cg' or `0': Conjugated gradient method.

   - `fft' or `3': FFTs with spherical cutoff.
   The value of variable `DoubleFFTParameter' is used in case `3'
method is used.


File: octopus.info,  Node: POLStaticField,  Next: Displacement,  Prev: PoissonSolver,  Up: Varia

4.14.2 `POLStaticField' (double, 0.001 a.u.)
--------------------------------------------

Magnitude of the static field used to calculate the static
polarizability in `CalculationMode = 7, 8'.


File: octopus.info,  Node: Displacement,  Prev: POLStaticField,  Up: Varia

4.14.3 `Displacement' (double, 0.01 a.u.)
-----------------------------------------

When calculating phonon properties (`CalculationMode = 11')
`Displacement' controls how much the atoms are to be moved in order to
calculate the dynamical matrix.


File: octopus.info,  Node: External utilities,  Next: Undocumented Variables,  Prev: Input file options,  Up: Top

5 External utilities
********************

A few small programs are generated along with `octopus', for the
purpose of post-processing the generated information. These utilities
should all be run from the directory where `octopus' was run, so that
it may see the input file, and the directories created by it.

* Menu:

* oct-sf::
* oct-rsf::
* oct-hs-mult::
* oct-hs-acc::
* oct-xyz-anim::
* oct-excite::
* oct-broad::
* oct-make-st::
* oct-center-geom::
* wf.net::


File: octopus.info,  Node: oct-sf,  Next: oct-rsf,  Prev: External utilities,  Up: External utilities

5.1 `oct-sf'
============

This utility generates the dipole strength function of the given system.
Its main input is the `td.general/multipoles' file. Output is written
to a file called `spectrum'. This file is made of two columns: energy
(in eV or a.u., depending on the units specified in the input file),
and dipole strength function (in 1/eV, or 1/a.u., idem).

   In the input file, the user may set the `SpecTransformMode' - this
should be set to "sin" for proper use -, the `SpecDampMode' -
recommended value is "pol", which ensures fulfilling of the N-sum rule,
the `SpecStartTime', the `SpecEndTime', the `SpecEnergyStep', the
`SpecMinEnergy' and the `SpecMaxEnergy'.


File: octopus.info,  Node: oct-rsf,  Next: oct-hs-mult,  Prev: oct-sf,  Up: External utilities

5.2 `oct-rsf'
=============


File: octopus.info,  Node: oct-hs-mult,  Next: oct-hs-acc,  Prev: oct-rsf,  Up: External utilities

5.3 `oct-hs-mult'
=================

Calculates the harmonic spectrum, out of the multipoles file. To do.


File: octopus.info,  Node: oct-hs-acc,  Next: oct-xyz-anim,  Prev: oct-hs-mult,  Up: External utilities

5.4 `oct-hs-acc'
================

Calculates the harmonic spectrum, out of the acceleration file. To do.


File: octopus.info,  Node: oct-xyz-anim,  Next: oct-excite,  Prev: oct-hs-acc,  Up: External utilities

5.5 `oct-xyz-anim'
==================

Reads out the `td.general/coordinates' file, and makes a movie in XYZ
format. To do.


File: octopus.info,  Node: oct-excite,  Next: oct-broad,  Prev: oct-xyz-anim,  Up: External utilities

5.6 `oct-excite'
================

Calculates the excitation spectrum within linear response. This utility
can output just the difference of eigenvalues by setting
`LinEigenvalues', the excitations using M. Petersilka formula
(`LinPetersilka'), or M. Casida (`LinCasida'). This utility requires
that a calculation of unoccupied states (`CalculationMode' = unocc) has
been done before, and it outputs the results to the sub-directory
"linear". The states entering the calculation can be chosen with the
variable `ExciteStates' (*note OutputWfsNumber::)


File: octopus.info,  Node: oct-broad,  Next: oct-make-st,  Prev: oct-excite,  Up: External utilities

5.7 `oct-broad'
===============

Generates a spectrum by broadening the excitations obtained by the
`oct-excite' utility. The parameters of the spectrum can be set using
the variables `LinBroadening', `LinMinEnergy', `LinMaxEnergy', and
`LinEnergyStep'.


File: octopus.info,  Node: oct-make-st,  Next: oct-center-geom,  Prev: oct-broad,  Up: External utilities

5.8 `oct-make-st'
=================

`make_st' reads `tmp/restart.static' and replaces some of the Kohn-Sham
states by Gaussians wave packets. The states which should be replaced
are given in the `%MakeStates' section in the input file and written to
`tmp/restart.static.new'. (You probably want to copy that file to
`tmp/restart.static' and use then `CalculationMode=5' or `6'.)

     %MakeStates
       ik | ist | idim | type | sigma | x0 | k
     %

   The first values stand for

   * ik: The k point (or the spin, if `spin-components=2') of the state

   * ist: The state to be replaced

   * idim: The component of the state (if the wave functions have more
     than one component, i.e. when `spin-components=3' is used).

   * The type of the wave packet; currently only `1' (Gaussian) is
     available

   The next items depend on the type chosen.  For a Gaussian wave
packet, defined as

   psi(x) = 1/sigma sqrt(1/2pi) exp(ik(x-x0)) exp(-(x-x0)^2/(2
sigma^2)),

   they are:

   * \sigma the width of the Gaussian

   * k: the *k* vector. In 3D use `k1|k2|k3'.

   * x_0: the coordinate where the Gaussian is initially centred. In 3D
     use `x01|x02|x03'.


File: octopus.info,  Node: oct-center-geom,  Next: wf.net,  Prev: oct-make-st,  Up: External utilities

5.9 `oct-center-geom'
=====================

This utility centers and aligns the coordinates of the molecule. It
reads the file specified in the input file (either by the `Coordinates'
block, or by the `XYZCoordinates' or `PDBCoordinates' variables), and
outputs the adjusted coordinates to the file `adjusted.xyz'. The
following parameters are read from the `inp'ut file:

   * `MainAxis' (block data): A vector of three reals defining the axis
     to which the molecule should be align. If not present, the default
     value will be
              %MainAxis
                1 | 0 | 1
              %

   * `AxisType' (int, inertia): This variable describes how to
     calculate the "main" axis of the molecule. Possible values are:
        - `inertia' or `1': Axis of inertia;

        - `pseudo'  or `2': Axis of inertia calculated as if all atoms
          had mass 1;

        - `large'   or `2': The longest axis of the molecule.



File: octopus.info,  Node: wf.net,  Prev: oct-center-geom,  Up: External utilities

5.10 `wf.net'
=============

This is an OpenDX network, aimed at the visualization of wave-functions.
To be able to use it, you need to have properly installed the OpenDX
program (get it at opendx.org), as well as the Chemistry extensions
obtainable at the Cornell Theory Center
(http://www.tc.cornell.edu/Services/Vis/dx/index.asp).  Once these are
working, you may follow a small tutorial on `wf.net' by following next
steps:

   o Place in a directory the program wf.net, the (needed) auxiliary
     file wf.cfg, and the sample inp file that can all be found in
     `OCTOPUS-HOME'/util.

   o Run `octopus'. The inp file used prescribes the calculation of the
     C atom in its ground state, in spin-polarized mode. It also
     prescribes that the wave-functions should be written in "dx"
     format. At the end, these should be written in subdirectory
     "static": wf-00x-00y-1.dx, where x runs from 1 to 2 (spin quantum
     number) and y runs from 1 to 4 (wave-function index).

   o Run the OpenDX program. Click on "Run Visual Programs" on the DX
     main menu, and select the program `wf.net'. The program will be
     executed, and several windows should open. One of them should be
     called "Application Comment". It contains a small tutorial. Follow
     it from now on.



File: octopus.info,  Node: Undocumented Variables,  Next: Examples,  Prev: External utilities,  Up: Top

6 Undocumented Variables
************************

If you want to use these variables you will have to go to the code to
find out what they do. If you do it, please take the time to write a
short description and send a patch of the manual to us ;) BTW, some of
this variables describe things that may not work, or are under
developments, so don't blame us...
   o   AnimationSampling

   o   AxisType

   o   BoundaryZeroDerivative

   o   CenterOfInversion

   o   CurrentDFT

   o   GuessDensityAtomsMagnet

   o   KineticCutoff

   o   LB94_beta

   o   LB94_modified

   o   LB94_threshold

   o   OEP_level

   o   OEP_mixing

   o   OptControlAlpha

   o   OptControlEps

   o   OptControlInitLaser

   o   OptControlMaxIter

   o   OutputDuringSCF

   o   OutputELF_FS

   o   OutputWfsSqMod

   o   PeriodicDimensions

   o   RestartFileFormat

   o   ShifKPoints

   o   StaticMagneticField

   o   TDDeltaStrengthMode

   o   TDOutputSpin

   o   VlocalCutoff

   o   FromScratch


File: octopus.info,  Node: Examples,  Next: Options Index,  Prev: Undocumented Variables,  Up: Top

7 Examples
**********

* Menu:

* Hello world::
* Benzene::


File: octopus.info,  Node: Hello world,  Next: Benzene,  Prev: Examples,  Up: Examples

7.0.1 Hello world
-----------------

As a first example, we will take a sodium atom.  With your favourite
text editor, create the following input "inp".
       SystemName = 'Na'
       CalculationMode = 1
       %Species
         'Na' | 22.989768 | 11 | "tm2" | 0 | 0
       %
       %Coordinates
         'Na' | 0.0 | 0.0 | 0.0 | no
       %
       Radius = 12.0
       Spacing = .6
       TypeOfMixing = 2

   This input file should be essentially self-explanatory.  Note that a
Troullier-Martins pseudopotential file ("Na.vps", or "Na.ascii") should
be accesible to the program. A sample "Na.ascii" may be found in
`OCTOPUS-HOME/share/PP/TM2'. If `octopus' was installed (`make install'
was issued after `make'), there should be no need to do anything - the
program should find it. Otherwise, you may as well place it in the
working directory.  Then run `octopus' - for example, do `octopus > out
', so that the output is stored in "out" file. If everything goes OK,
"out" should look like (1):
                         Running octopus, version 1.1
                  (build time - Fri Mar 14 14:23:49 CET 2003)

     Info: Calculation started on 2003/03/17 at 03:49:56
     Info: Reading pseudopotential from file:
           '/home/marques/share/octopus/PP/TM2/Na.ascii'
           Calculating atomic pseudo-eigenfunctions for specie Na....
           Done.
     Info: l =  0 component used as local potential
       Type = sphere           Radius [b] =  12.000
       Spacing [b] = ( 0.600, 0.600, 0.600)    volume/point [b^3] =  0.21600
       # inner mesh =  33401   # outer mesh =  18896
     Info: Derivatives calculated in real-space
     Info: Local Potential in Reciprocal Space.
     Info: FFTs used in a double box (for poisson | local potential)
           box size = (  81,  81,  81)
           alpha =      2.00000
     Info: Using FFTs to solve poisson equation with spherical cutoff.
     Info: Exchange and correlation
           Exchange    family    : LDA
                       functional: non-relativistic
           Correlation family    : LDA
                       functional: Perdew-Zunger
     Info: Allocating rpsi.
     Info: Random generating starting wavefunctions.
     Info: Unnormalized total charge =      0.998807
     Info: Renormalized total charge =      1.000000
     Info: Setting up Hamiltonian.
     Info: Performing LCAO calculation.
     Info: LCAO basis dimension:      1
           (not considering spin or k-points)
     Eigenvalues [H]
        #   Eigenvalue    Occupation      Error (1)
        1    -0.102098       1.000000
     Info: SCF using real wavefunctions.
     Info: Broyden mixing used. It can (i) boost your convergence,
           (ii) do nothing special, or (iii) totally screw up the run.
           Good luck!
     Info: Converged =     0
     Eigenvalues [H]
        #   Eigenvalue    Occupation      Error (1)
        1    -0.102975       1.000000      (2.8E-02)
     Info: iter =    1 abs_dens = 0.53E-03 abs_ener = 0.60E+00

     Info: Converged =     0
     Eigenvalues [H]
        #   Eigenvalue    Occupation      Error (1)
        1    -0.102477       1.000000      (1.4E-03)
     Info: iter =    2 abs_dens = 0.43E-03 abs_ener = 0.65E-05

     Info: Converged =     1
     Eigenvalues [H]
        #   Eigenvalue    Occupation      Error (1)
        1    -0.102419       1.000000      (5.1E-04)
     Info: iter =    3 abs_dens = 0.39E-04 abs_ener = 0.20E-06

     Info: Converged =     1
     Eigenvalues [H]
        #   Eigenvalue    Occupation      Error (1)
        1    -0.102436       1.000000      (8.5E-05)
     Info: iter =    4 abs_dens = 0.24E-04 abs_ener = 0.52E-08

     Info: Converged =     1
     Eigenvalues [H]
        #   Eigenvalue    Occupation      Error (1)
        1    -0.102437       1.000000      (1.5E-06)
     Info: iter =    5 abs_dens = 0.14E-05 abs_ener = 0.36E-10

     Info: SCF converged in    5 iterations
     Info: Deallocating rpsi.
     Info: Calculation ended on 2003/03/17 at 03:50:04
   Take now a look at the working directory. It should include the
following files:
     -rw-rw-r--    1 user  group       177 Jul 10 12:29 inp
     -rw-rw-r--    1 user  group      4186 Jul 10 12:35 out
     -rw-rw-r--    1 user  group      1626 Jul 10 12:35 out.oct
     drwxrwxr-x    2 user  group      4096 Jul 10 12:35 static
     drwxrwxr-x    2 user  group      4096 Jul 10 12:35 tmp

   Besides the initial file (`inp') and the `out' file, two new
directories appear. In `static', you will find the file `info', with
information about the static calculation (it should be hopefully
self-explanatory, otherwise please complain to the authors).  In `tmp',
you will find the `restart.static', a binary file containg restart
information about the ground-state, which is used if, for example, you
want to start a time-dependent calculation afterwards.  Finally, you
can safely ignore `out.oct': it is an output from the liboct library,
irrelevant for what concerns physics ;).

   *Exercises*:
   * Study how the total energy and eigenvalue of the sodium atom
     improve   with the mesh spacing.

   * Calculate the static polarizability of the sodium atom
     (`CalculationMode = 7').    Two new files will be generated:
     `restart.pol' that can be used to resume   the polarizability
     calculation, and `Na.pol' that contains the static polarizability
     tensor. Note that this calculation overwrites
     `tmp/restart.static', so that   what now is there is the ground
     state for the system _with_ an external static   electrical field
     applied. Delete it since it is useless.

   * Calculate a few unoccupied states (`CalculationMode = 3'). The
     eigenspectrum   will be in the file `eigenvalues'. Why don't we
     find a Rydberg series in the   eigenspectrum?

   * Repeat the previous calculation with PBE, LB94, and exact exchange.
      Don't forget to *move* the file `tmp/restart.static' when
     switching   between exchange-correlation functionals.

   * Perform a time-dependent evolution (`CalculationMode = 5'), to
     calculate   the optical spectrum of the Na atom. Use a
     `TDDeltaStrength = 0.05', polarised   in the `x' direction. The
     multipole moments of the density are output to   the file
     `td.general/multipoles'. You can process this file with the utility
      `strength-function' to obtain the optical spectrum.    If you
     have computer time to waste, re-run the time-dependent
     simulation for some other xc choices.


   ---------- Footnotes ----------

   (1) Before this output, a beautiful octopus ascii-art picture may be
printed...


File: octopus.info,  Node: Benzene,  Prev: Hello world,  Up: Examples

7.0.2 Benzene
-------------

Well, the sodium atom is a bit too trivial. Let's try something harder:
benzene.  you will just need the geometry for benzene to be able to
play. Here it is (in AA):
      C  0.000  1.396  0.000
      C  1.209  0.698  0.000
      C  1.209 -0.698  0.000
      C  0.000 -1.396  0.000
      C -1.209 -0.698  0.000
      C -1.209  0.698  0.000
      H  0.000  2.479  0.000
      H  2.147  1.240  0.000
      H  2.147 -1.240  0.000
      H  0.000 -2.479  0.000
      H -2.147 -1.240  0.000
      H -2.147  1.240  0.000

   Follow now the steps of the previous example. Carbon and Hydrogen
have a much harder pseudo-potential than Sodium, so you will probably
have to use a tighter mesh. It also takes much more time...


File: octopus.info,  Node: Options Index,  Prev: Examples,  Up: Top

Options Index
*************

 [index ]
* Menu:

* ABHeight:                              ABHeight.             (line  6)
* AbsorbingBoundaries:                   AbsorbingBoundaries.  (line  6)
* ABWidth:                               ABWidth.              (line  6)
* AtomsMagnetDirection:                  AtomsMagnetDirection. (line  6)
* AxisType:                              oct-center-geom.      (line 19)
* BoxShape:                              BoxShape.             (line  6)
* CalculationMode:                       CalculationMode.      (line  6)
* CFunctional:                           CFunctional.          (line  6)
* ClassicPotential:                      ClassicPotential.     (line  6)
* ConvAbsDens:                           ConvAbsDens.          (line  6)
* ConvAbsEv:                             ConvAbsEv.            (line  6)
* ConvRelDens:                           ConvRelDens.          (line  6)
* ConvRelEnergy:                         ConvRelEv.            (line  6)
* Coordinates:                           Coordinates.          (line  6)
* DebugLevel:                            DebugLevel.           (line  6)
* DerivativesSpace:                      DerivativesSpace.     (line  6)
* Dimensions:                            Dimensions.           (line  6)
* Displacement:                          Displacement.         (line  6)
* DoubleFFTParameter:                    DoubleFFTParameter.   (line  6)
* EigenSolver:                           EigenSolver.          (line  6)
* EigenSolverFinalTolerance:             EigenSolverFinalTolerance.
                                                               (line  6)
* EigenSolverFinalToleranceIteration:    EigenSolverFinalToleranceIteration.
                                                               (line  6)
* EigenSolverInitTolerance:              EigenSolverInitTolerance.
                                                               (line  6)
* EigenSolverMaxIter:                    EigenSolverMaxIter.   (line  6)
* ElectronicTemperature:                 ElectronicTemperature.
                                                               (line  6)
* ExcessCharge:                          ExcessCharge.         (line  6)
* ExtraStates:                           ExtraStates.          (line  6)
* FFTOptimize:                           FFTOptimize.          (line  6)
* GOMaxIter:                             GOMaxIter.            (line  6)
* GOMethod:                              GOMethod.             (line  6)
* GOStep:                                GOStep.               (line  6)
* GOTolerance:                           GOTolerance.          (line  6)
* GuessMagnetDensity:                    GuessMagnetDensity.   (line  6)
* HSPolarization:                        HSPolarization.       (line  6)
* LCAOStart:                             LCAOStart.            (line  6)
* LocalPotentialSpace:                   LocalPotentialSpace.  (line  6)
* Lsize:                                 Lsize.                (line  6)
* MainAxis:                              oct-center-geom.      (line 12)
* MakeStates:                            oct-make-st.          (line 12)
* MaximumIter:                           MaximumIter.          (line  6)
* Mixing:                                Mixing.               (line  6)
* MixNumberSteps:                        MixNumberSteps.       (line  6)
* MoveIons:                              MoveIons.             (line  6)
* NonInteractingElectrons:               NonInteractingElectrons.
                                                               (line  6)
* Occupations:                           Occupations.          (line  6)
* OEP_level:                             OEP_level.            (line  6)
* OrderDerivatives:                      OrderDerivatives.     (line  6)
* OutputAxisX:                           OutputAxisX.          (line  6)
* OutputAxisY:                           OutputAxisY.          (line  6)
* OutputAxisZ:                           OutputAxisZ.          (line  6)
* OutputDensity:                         OutputDensity.        (line  6)
* OutputDX:                              OutputDX.             (line  6)
* OutputELF:                             OutputElf.            (line  6)
* OutputGeometry:                        OutputGeometry.       (line  6)
* OutputKSPotential:                     OutputKSPotential.    (line  6)
* OutputNETCDF:                          OutputNETCDF.         (line  6)
* OutputPlaneX:                          OutputPlaneX.         (line  6)
* OutputPlaneY:                          OutputPlaneY.         (line  6)
* OutputPlaneZ:                          OutputPlaneZ.         (line  6)
* OutputWfs:                             OutputWfs.            (line  6)
* OutputWfsNumber:                       OutputWfsNumber.      (line  6)
* PDBCoordinates:                        PDBCoordinates.       (line  6)
* PoissonSolver:                         PoissonSolver.        (line  6)
* POLStaticField:                        POLStaticField.       (line  6)
* Radius:                                Radius.               (line  6)
* RandomVelocityTemp:                    RandomVelocityTemp.   (line  6)
* RelativisticCorrection:                RelativisticCorrection.
                                                               (line  6)
* SCFinLCAO:                             SCFinLCAO.            (line  6)
* SICCorrection:                         SICCorrection.        (line  6)
* Spacing:                               Spacing.              (line  6)
* SpecDampFactor:                        SpecDampFactor.       (line  6)
* SpecDampMode:                          SpecDampMode.         (line  6)
* SpecEndTime:                           SpecEndTime.          (line  6)
* SpecEnergyStep:                        SpecEnergyStep.       (line  6)
* Species:                               Species.              (line  6)
* SpecMaxEnergy:                         SpecMaxEnergy.        (line  6)
* SpecMinEnergy:                         SpecMinEnergy.        (line  6)
* SpecStartTime:                         SpecStartTime.        (line  6)
* SpecTransformMode:                     SpecTransformNode.    (line  6)
* SpinComponents:                        SpinComponents.       (line  6)
* SystemName:                            SystemName.           (line  6)
* TDDeltaStrength:                       TDDeltaStrength.      (line  6)
* TDDipoleLmax:                          TDDipoleMax.          (line  6)
* TDEvolutionMethod:                     TDEvolutionMethod.    (line  6)
* TDExponentialMethod:                   TDExponentialMethod.  (line  6)
* TDExpOrder:                            TDExpOrder.           (line  6)
* TDGauge:                               TDGauge.              (line  6)
* TDLanczosTol:                          TDLanczosTol.         (line  6)
* TDLasers:                              TDLasers.             (line  6)
* TDMaximumIter:                         TDMaximumIter.        (line  6)
* TDOutputAcceleration:                  TDOutputAcceleration. (line  6)
* TDOutputCoordinates:                   TDOutputCoordinates.  (line  6)
* TDOutputElEnergy:                      TDOutputElEnergy.     (line  6)
* TDOutputGSProjection:                  TDOutputGSProjection. (line  6)
* TDOutputLaser:                         TDOutputLaser.        (line  6)
* TDOutputMultipoles:                    TDOutputMultipoles.   (line  6)
* TDOutputOccAnalysis:                   TDOutputOccAnalysis.  (line  6)
* TDPolarization:                        TDPolarization.       (line  6)
* TDTimeStep:                            TDTimeStep.           (line  6)
* TypeOfMixing:                          TypeOfMixing.         (line  6)
* Units:                                 Units.                (line  6)
* UnitsInput:                            UnitsInput.           (line  6)
* UnitsOutput:                           UnitsOutput.          (line  6)
* UnoccConv:                             UnoccConv.            (line  6)
* UnoccMaximumIter:                      UnoccMaximumIter.     (line  6)
* UnoccNumberStates:                     UnoccNumberStates.    (line  6)
* Velocities:                            Velocities.           (line  6)
* Verbose:                               Verbose.              (line  6)
* What2Mix:                              What2Mix.             (line  6)
* XFunctional:                           XFunctional.          (line  6)
* XLength:                               XLength.              (line  6)
* XYZCoordinates:                        XYZCoordinates.       (line  6)
* XYZVelocities:                         XYZVelocities.        (line  6)



Tag Table:
Node: Top667
Node: Authors4377
Node: Copying7737
Node: Introduction9196
Node: Description of octopus9830
Ref: Description of octopus-Footnote-112279
Node: Time dependent density functional theory12672
Ref: Time dependent density functional theory-Footnote-116657
Ref: Time dependent density functional theory-Footnote-216889
Ref: Time dependent density functional theory-Footnote-317191
Ref: Time dependent density functional theory-Footnote-417347
Ref: Time dependent density functional theory-Footnote-517531
Node: Installation17602
Node: Quick instructions18596
Node: Long instructions19131
Ref: Long instructions-Footnote-128770
Ref: Long instructions-Footnote-229328
Node: Different octopus executables29540
Node: Troubleshooting31404
Node: The parser33350
Node: Input file options36624
Node: Generalities37241
Node: SystemName37521
Node: Dimensions37828
Node: CalculationMode38138
Node: Units39045
Node: UnitsInput39688
Node: UnitsOutput40037
Node: Verbose40382
Node: DebugLevel41117
Node: Species Block41376
Node: Species41557
Node: Coordinates Description45435
Node: PDBCoordinates45854
Node: XYZCoordinates47364
Node: Coordinates48166
Node: XYZVelocities49164
Node: Velocities49748
Node: RandomVelocityTemp50526
Node: Mesh50859
Node: BoxShape51401
Node: Radius51899
Node: Lsize52136
Node: XLength52485
Node: Spacing52708
Node: DerivativesSpace53154
Node: OrderDerivatives53763
Node: DoubleFFTParameter54237
Node: FFTOptimize54797
Node: States55331
Node: SpinComponents55553
Node: ExcessCharge56453
Node: ExtraStates56773
Node: Occupations57655
Node: ElectronicTemperature58621
Node: Hamiltonian58956
Node: NonInteractingElectrons59214
Node: ClassicPotential59621
Node: LocalPotentialSpace59966
Node: RelativisticCorrection60405
Node: Exchange and correlation60922
Node: XFunctional61296
Node: CFunctional61661
Node: OEP_level62337
Node: SICCorrection62673
Node: SCF62837
Node: MaximumIter64240
Node: ConvAbsDens64513
Node: ConvRelDens64834
Node: ConvAbsEv65210
Node: ConvRelEv65533
Node: GuessMagnetDensity65919
Node: AtomsMagnetDirection67089
Node: LCAOStart67865
Node: SCFinLCAO68270
Node: EigenSolver68678
Node: EigenSolverInitTolerance69573
Node: EigenSolverFinalTolerance69850
Node: EigenSolverFinalToleranceIteration70150
Node: EigenSolverMaxIter70516
Node: What2Mix70918
Node: TypeOfMixing71216
Node: Mixing71588
Node: MixNumberSteps71878
Node: Unoccupied States72124
Node: UnoccNumberStates72846
Node: UnoccMaximumIter73088
Node: UnoccConv73533
Node: Time Dependent73792
Node: TDMaximumIter78205
Node: TDTimeStep78486
Node: TDExponentialMethod78743
Node: TDExpOrder84042
Node: TDLanczosTol84405
Node: TDEvolutionMethod84894
Node: TDLasers90694
Node: TDGauge92114
Node: TDDeltaStrength92397
Node: TDPolarization92750
Node: TDOutputMultipoles93337
Node: TDDipoleMax93717
Node: TDOutputCoordinates94024
Node: TDOutputGSProjection94411
Node: TDOutputAcceleration94887
Node: TDOutputLaser95323
Node: TDOutputElEnergy95603
Node: TDOutputOccAnalysis95926
Node: MoveIons96300
Node: AbsorbingBoundaries96685
Node: ABWidth97254
Node: ABHeight97492
Node: Geometry optimization97722
Node: GOMethod97983
Node: GOTolerance98283
Node: GOMaxIter98592
Node: GOStep98880
Node: Function output for visualization99066
Node: OutputKSPotential100486
Node: OutputDensity101033
Node: OutputWfs101345
Node: OutputWfsNumber101788
Node: OutputElf102140
Node: OutputGeometry102467
Node: OutputAxisX102935
Node: OutputAxisY103250
Node: OutputAxisZ103562
Node: OutputPlaneX103875
Node: OutputPlaneY104168
Node: OutputPlaneZ104462
Node: OutputDX104752
Node: OutputNETCDF105155
Node: OutputEvery105539
Node: Spectrum calculations105825
Node: SpecTransformNode106520
Node: SpecDampMode106843
Node: SpecDampFactor107638
Node: SpecStartTime107936
Node: SpecEndTime108225
Node: SpecEnergyStep108510
Node: SpecMinEnergy108733
Node: SpecMaxEnergy108995
Node: HSPolarization109260
Node: Varia109753
Node: PoissonSolver109931
Node: POLStaticField110369
Node: Displacement110664
Node: External utilities110991
Node: oct-sf111576
Node: oct-rsf112360
Node: oct-hs-mult112487
Node: oct-hs-acc112696
Node: oct-xyz-anim112910
Node: oct-excite113141
Node: oct-broad113799
Node: oct-make-st114158
Node: oct-center-geom115438
Node: wf.net116484
Node: Undocumented Variables117865
Node: Examples118963
Node: Hello world119126
Ref: Hello world-Footnote-1125749
Node: Benzene125833
Node: Options Index126650

End Tag Table
