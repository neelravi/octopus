This is octopus.info, produced by makeinfo version 4.7 from
octopus.texi.

   This manual is for octopus 1.99devel, a first principles, electronic
structure, excited states, time-dependent density functional theory
program.

   Copyright (C) 2002, 2003, 2004 Miguel A. L. Marques, Alberto Castro
and Angel Rubio

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.1 or any later version published by the Free Software
     Foundation.

INFO-DIR-SECTION Individual utilities
START-INFO-DIR-ENTRY
* octopus: (octopus).           The octopus program.
END-INFO-DIR-ENTRY


File: octopus.info,  Node: Top,  Next: Authors,  Prev: (dir),  Up: (dir)

octopus
*******

This manual is for octopus 1.99devel, a first principles, electronic
structure, excited states, time-dependent density functional theory
program.

   Copyright (C) 2002, 2003, 2004 Miguel A. L. Marques, Alberto Castro
and Angel Rubio

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.1 or any later version published by the Free Software
     Foundation.

* Menu:

* Authors::                     The authors of the thing, and the collaborators.
* Copying::                     The licence.
* Installation::                How to install the program.
* The parser::                  The input file syntax.
* Input Variables::             The options to put in the input file.
* Undocumented Variables::      The variables that we did not have time to document.
* Examples::                    Some examples.
* Options Index::               An index with all the options.










 --- The Detailed Node Listing ---

Installation

* Quick instructions::
* Long instructions::
* Different octopus executables::
* Troubleshooting::

Input Variables

* Generalities::
* Hamiltonian::
* Spectrum Calculations::
* States::
* System::
* Time Dependent::
* Unoccupied States::

Generalities

* Debug::
* IO::
* Parallel::
* Units::

Hamiltonian

* Poisson::
* Casida::
* General::
* Curvilinear::
* Derivatives::
* Simulation Box::
* EigenSolver::
* Mixing::

Poisson

* Multigrid::

Curvilinear

* Gygi::

System

* Coordinates::
* Species::
* Velocities::

Examples

* Hello world::
* Benzene::


File: octopus.info,  Node: Authors,  Next: Copying,  Prev: Top,  Up: Top

1 Authors
*********



The main developing team of this program is composed of:

   * Miguel A. L. Marques (Donostia International Physics Center, San
     Sebastia'n, Espan~a)

   * Angel Rubio, (Donostia International Physics Center and Department
     of Materials Science UPV/EHU, San Sebastia'n, Espan~a), and

   * Alberto Castro, (alberto.castro@tddft.org, Theoretische Physik,
     Freie Universita"t Berlin, Berlin 14195, Deutschland).

   Other contributors are:
   * Micael Oliveira: mixing, and a lot of stuff.

   * Carlo Andrea Rozzi - infinite systems (almost done!)

   * Sebastien Hamel    - paralel version of oct-excite.

   `octopus' is based on a fixed-nucleus code written by George F.
Bertsch and K. Yabana to perform real-time dynamics in clusters (Phys
Rev B *54*, 4484 (1996)) and on a condensed matter real-space
plane-wave based code written by A. Rubio, X. Blase and S.G. Louie
(Phys. Rev. Lett. *77*, 247 (1996)).  The code was afterwards extended
to handle periodic systems by G.F. Bertsch, J.I. Iwata, A. Rubio, and
K. Yabana (Phys. Rev. B, *62*, 7998 (2000)). Contemporaneously there was
a major rewrite of the original cluster code to handle a vast majority
of finite systems. At this point the cluster code was named "tddft".

   This version was consequently enhanced and beautified by A. Castro
(at the time Ph.D. student of A. Rubio), originating a fairly verbose
15,000 lines of Fortran 90/77. In the year 2000, M. Marques (aka
Hyllios, aka Anto'nio de Faria, corsa'rio portugue^s), joined the A.
Rubio group in Valladolid as a postdoc. Having to use "tddft" for his
work, and being petulant enough to think he could structure the code
better than his predecessors, he started a major rewrite of the code
together with A. Castro, finishing version 0.2 of "tddft." But things
were still not perfect: due to their limited experience in Fortran 90,
and due to the inadequacy of this language for anything beyond a HELLO
WORLD program, several parts of the code were still clumsy. Also the
idea of GPLing the almost 20,000 lines arose during an alcoholic
evening. So after several weeks of fantic coding and after getting rid
of the Numerical Recipes code that still lingered around, `octopus' was
born.

   The present released version has been completely rewritten and keeps
very little relation to the old version (even input and output files)
and has been enhanced with major new flags to perform various
excited-state dynamics in finite and extended systems (one-dimensional
periodic chains). The code will be updated frequently and new versions
can be found here (http://www.tddft.org/programs/octopus).

   The main features of the present version are described in detail in
_octopus: a first principles tool for excited states electron-ion
dynamics_, Comp. Phys. Comm. *151*, 60 (2003).  Updated references as
well as results obtained with octopus will be posted regularly to the
`octopus' web page. If you find the code useful for you research we
would appreciate if you give reference to this work and previous ones.

   If you have some free time, and if you feel like taking a joy ride
with Fortran 90, just drop us an email <octopus@tddft.org>. You can
also send us patches, comments, ideas, wishes, etc. They will be
included in new releases of octopus.



File: octopus.info,  Node: Copying,  Next: Installation,  Prev: Authors,  Up: Top

2 Copying
*********

The `octopus'  Copying Conditions
*********************************

This program is "free"; this means that everyone is free to use it and
free to redistribute it on a free basis.  What is not allowed is to try
to prevent others from further sharing any version of this program that
they might get from you.

   Specifically, we want to make sure that you have the right to give
away copies of the program, that you receive source code or else can
get it if you want it, that you can change this program or use pieces
of them in new free programs, and that you know you can do these things.

   To make sure that everyone has such rights, we have to forbid you to
deprive anyone else of these rights.  For example, if you distribute
copies of the program, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must tell them their rights.

   Also, for our own protection, we must make certain that everyone
finds out that there is no warranty for this program.  If these
programs are modified by someone else and passed on, we want their
recipients to know that what they have is not what we distributed, so
that any problems introduced by others will not reflect on our
reputation.

   The precise conditions of the license are found in the General Public
Licenses that accompany it.


File: octopus.info,  Node: Installation,  Next: The parser,  Prev: Copying,  Up: Top

3 Installation
**************

Maybe somebody else installed the `octopus'  for you. In that case, the
files should be under some directory that we can call `PREFIX': the
executables in `PREFIX/bin' (e.g. if `PREFIX=/usr/local', the main
`octopus' executable is then `/usr/local/bin/octopus'); the
documentation in `info' format in `PREFIX/info' (so that you may see it
by typing `info -f PREFIX/info/octopus.info' if the `info' program is
installed in your system); some sample files in
`PREFIX/share/octopus/samples'; the pseudopotential files that
`octopus'  will need in `PREFIX/share/octopus/PP', etc.

   However, you may be unlucky and that is not the case. In the
following we will try to help you with the, still rather unfriendly,
task of compiling and installing the `octopus'  .

* Menu:

* Quick instructions::
* Long instructions::
* Different octopus executables::
* Troubleshooting::


File: octopus.info,  Node: Quick instructions,  Next: Long instructions,  Prev: Installation,  Up: Installation

3.1 Quick instructions
======================

For the inpatients, here goes the quick-start:
     prompt> gzip -cd octopus<-version>.tar.gz | tar xvf -
     prompt> cd octopus-<version>
     prompt> ./configure
     prompt> make
     prompt> make install

   This will probably *not* work, so before giving up, just read the
following paragraphs.

   Also, rpm and deb binaries for linux are supplied on the web-page.


File: octopus.info,  Node: Long instructions,  Next: Different octopus executables,  Prev: Quick instructions,  Up: Installation

3.2 Long instructions
=====================

The code is written in standard Fortran 90, with some routines written
in C (and in bison, if we count the input parser). To build it you will
need both a C compiler (`gcc' works just fine), and a Fortran 90
compiler. No free-software Fortran 90 compiler is available yet, so, if
you want to chew the `octopus', you will have either to help the g95
(http://g95.sourceforge.net) or gfortran (http://gcc.gnu.org/fortran)
projects, or use any of the available comercial compilers.

   Besides the compiler, you will also need:
  1. `make':  most computers have it installed, otherwise just grab and
     install the GNU `make'.

  2. `cpp': The C preprocessor is heavily used in `octopus'.  GNU `cpp'
     is just fine, but any `cpp' that accepts the `-C' flag (preserve
     comments) should work just as well.

  3. FFTW: We have relied on this great library to perform the Fast
     Fourier Transforms (FFTs). You may grab it from here
     (http://www.fftw.org/).  You may use FFTW version 2 as well as
     FFTW version 3. `octopus' will try first to use the latter one,
     since it is significantly faster in some architectures.

  4. LAPACK/BLAS: Required. Our politics is to rely on these two
     libraries as much as possible on these libraries for the linear
     algebra operations.  If you are running Linux, there is a fair
     chance they are already installed in your system. The same goes to
     the more heavyweight machines (alphas, IBMs, SGIs, etc.).
     Otherwise, just grab the source from here (http://www.netlib.org).

  5. GSL: Finally that someone had the nice idea of making a public
     scientific library! GSL still needs to grow, but it is already
     quite useful and impressive.  `octopus' uses splines, complex
     numbers, special functions, etc. from GSL, so it is a must! If you
     don't have it already installed in your system, you can obtain GSL
     from here (http://sources.redhat.com/gsl/). You will need version
     1.0 or higher.

  6. MPI: If you want to run `octopus' in multi-tentacle (parallel)
     mode, you will need an implementation of MPI.  MPICH
     (http://www-unix.mcs.anl.gov/mpi/mpich/) works just fine in our
     Linux boxes.


   First you should obtain the code file, `octopus<-version>.tar.gz',
(this you probably have already done). The code is freely available, and
can be downloaded from `http://www.tddft.org/programs/octopus'. There
exists a `cvs' server, which you can browse at
`http://nautilus.fis.uc.pt/cgi-bin/cvsweb.cgi/marques/octopus/'.  The
sources of the cvs version (in general more unstable the the _official_
distribution) may be downloaded by anonymous cvs access:

     prompt> cvs -d :pserver:anonymous@nautilus.fis.uc.pt:/server/cvsroot
             login

     prompt> cvs -d :pserver:anonymous@nautilus.fis.uc.pt:/server/cvsroot
             co marques/octopus

   Uncompress and untar it (`gzip -cd octopus<-version>.tar.gz | tar
-xvf -').  In the following, `OCTOPUS-HOME' denotes the home directory
of octopus, created by the `tar' command.

   The `OCTOPUS-HOME' contains the following subdirectories:
   * `autom4te.cache, build, CVS, debian': contains files related to
     the building system or the CVS repository. May actually not be
     there.  Not of real interest for the plain user.

   * `doc': The documentation of `octopus' in _texinfo_ format.

   * `liboct': Small C library that handles the interface to GSL and
     the parsing of the input file. It also contains some assorted
     routines that we didn't want to write in boring Fortran.

   * `share/PP': Pseudopotentials.  In practice now it contains the
     Troullier-Martins and Hartwigsen-Goedecker-Hutter pseudopotential
     files.

   * `share/util': Currently, the _utilities_ include a couple of IBM
     OpenDX networks (`wf.net'), to visualize wavefunctions, densities,
     etc.

   * `share/samples': A couple of sample input files.

   * `src': Fortran 90 source files. Note that these have to be
     preprocessed before being fed to the Fortran compiler, so do not
     be scared by all the # directives.

   Before configuring you can (should) setup a couple of options.
Although the configure script tries to guess your system settings for
you, we recommend that you set explicitly the default Fortran compiler
and the compiler options.  For example, in `bash' you would typically
do:
     export FC=abf90
     export FCFLAGS="-O -YEXT_NAMES=LCS -YEXT_SFX=_"
   if you are using the Absoft Fortran 90 compiler on a linux machine.
Also, if you have some of the required libraries in some unusual
directories, these directories may be placed in the variable `LDFLAGS'
(e.g., `export LDFLAGS=$LDFLAGS:/opt/lib/').

   The configuration script will try to find out which compiler you are
using.  Unfortunately, and due to the nature of the primitive language
that `octopus' is programmed in, the automatic test fails very often.
Often it is better to set the variable `FCFLAGS' by hand. These are
some of the options reported to work:
`intel ifc (PIV)'
     `-u -zero -fpp1 -nbs -i_dynamic -pc80 -pad -align  -unroll -O3 -r8
     -ip -tpp7 -xW'

`absoft (i386)'
     `-O3 -YEXT_NAMES=LCS -YEXT_SFX=_'

`absoft (opteron)'
     `-O3 -mcmodel=medium -m64 -cpu:host -YEXT_NAMES=LCS -YEXT_SFX=_'

`NAG (opteron)'
     `-colour -kind=byte -mismatch_all -abi=64 -ieee=full -O4
     -Ounroll=4'

`pgi (opteron)'
     `-fast -mcmodel=medium -O4'

`alpha'
     `-align dcommons -fast -tune host -arch host -noautomatic'

`xlf (IBM)'
     `-bmaxdata:0x80000000 -qmaxmem=-1 -qsuffix=f=f90 -Q -O5 -qstrict
     -qtune=auto -qarch=auto -qhot -qipa'

`sgi'
     `-O3 -INLINE -n32 -LANG:recursive=on'

   You can now run the configure script (`./configure').  (1) You can
use a fair amount of options to spice `octopus' to your own taste.  To
obtain a full list just type `./configure --help'. Some commonly used
options include:
   * `--prefix=PREFIX': Change the base installation dir of `octopus'
     to `PREFIX'. The executable will be installed in `PREFIX/bin', the
     libraries in `PREFIX/lib' and the documentation in `PREFIX/info'.
     `PREFIX' defaults to the home directory of the user who runs
     `configure'.  (2)

   * `--with-fft=fftw2': Instruct the `configure' script to use the FFTW
     library, and specifically to use the FFTW version 2. You may also
     set `--with-fft=fftw3' or even `--disable-fft', although this last
     option is dis-encouraged.

   * `--with-fft-lib=<lib>': Instruct the `configure' script to look
     for the FFTW library exactly in the way that it is specified in
     the `<lib>' argument, i.e `--with-fft-lib='-L/opt/lib -lfftw3''.

   * `--with-blas=<lib>': Instruct the `configure' script to look for
     the BLAS library in the way that it is specified in the `<lib>'
     argument.

   * `--with-lapack=<lib>': Instruct the `configure' script to look for
     the BLAS library in the way that it is specified in the `<lib>'
     argument.

   * `--with-gsl-prefix=DIR': Installation directory of the GSL
     library. The libraries are expected to be in `DIR/lib' and the
     include files in `DIR/include'. The value of `DIR' is usually
     found by issuing the command `gsl-config --prefix'. (If the GSL
     library is installed, the program `gsl-config' should be
     somewhere.)

   * `--with-netcdf=<lib>': NETCDF library. This is a recommended
     library, although not necessary.

   In addition to these options, several other options have to be
passed to build different executables of octopus (parallel, debugging
version, etc) - *Note Different octopus executables::.

   Run `make', and then `make install'. If everything went fine, you
should now be able to taste `octopus'. Depending on the options passed
to the configure script, some suffixes could be added to the generic
name `octopus' -- i.e. `octopus_cmplx' for the code compiled for
complex wave-functions, `octopus_cmplx_mpi' for a parallel version of
the code compiled for complex wave-function, and so on.

   Depending on the value given to the `--prefix=PREFIX' given, the
executables will reside in `PREFIX/bin', the info file with the
documentation in `PREFIX/info' (so that it may be viewed running `info
-f PREFIX/info/octopus.info'), and the auxiliary files will be copied
to `PREFIX/share/octopus'. The sample input files will be copied to
`PREFIX/share/octopus/samples'.

   The program has been tested in the following platforms:
   * `i686*-linux-gnu': with the Absoft (http://www.absoft.com),   and
     the Intel (http://www.intel.com/software/products/compilers/)
     compiler.

   * `alphae*': both in Linux and in OSF/1 with Compaq's `fort'
     compiler.

   * `powerpc-ibm-aix4.3.3.0': with native `xlf90' compiler.

   * `cray': with native f90 compiler.

   * `opteron': with NAG, PGI, and ABSOFT compilers.

   * `SGI': with native compiler.
   If you manage to compile/run `octopus' on a different platform or
with a different compiler, please let us know so we can update the
list. Patches to solve compiler issues are also welcomed.

   Build the documentation in the format you prefer. Since you are
reading this, you already have it in some format (but maybe not the
correct version).  Due to the power of `texinfo', a series of formats
are available, namely `dvi', `html', `pdf' and `info'. The
`octopus.texi' source code of this document is in the
`OCTOPUS-HOME/doc' directory.

   ---------- Footnotes ----------

   (1) If you downloaded the cvs version, you will not find the
`configure' script.  In order to compile the development version you
will first have to run the GNU autotools.  This may be done by
executing the `autoreconf' perl script (a part of the `autoconf'
distribution).  Note that you need to have working versions of the
`automake' (1.8.5), `autoconf' (2.59) and `libtool' (1.5.6) programs
(the versions we currently use are between parentheses). Note that the
`autoreconf' script will likely fail if you have (much) older versions
of the autotools.

   (2) You may fine-tune further the instalation by making use of a set
of standard options (`--exec-prefix, --bindir, --datadir,
--program-prefix', etc) that are described in the output of
`./configure --help'


File: octopus.info,  Node: Different octopus executables,  Next: Troubleshooting,  Prev: Long instructions,  Up: Installation

3.3 Different octopus executables
=================================

By performing the standard install, you will get an executable called
`octopus', and a set of utility programs called `oct-'_something_.
However, the code may be compiled differently in order to profit from
special feautures (e.g parallel executables, etc). The following is a
list of the options that have to be passed to the `configure' script in
order to obtain these different executables.

   * `--enable-complex': Builds a version with complex wave-functions
     for the ground-state calculations (wave-functions are always
     complex for the evolution). This is needed when spinors are needed
     -- e.g. noncollinear magnetism is going to be considered, or the
     spin-orbit coupling term will be used. The suffix `_cmplx' is
     appended to the `octopus' executable name.

   * `--enable-debug': Builds a version that is able to emit some
     debugging information. Useful for developers, or to report bugs.
     If `octopus' has been built with this option enabled, you may set
     the variable `Verbose' to "debug" level, and set `DebugLevel' The
     suffix `_debug' is appended to the `octopus' executable name.

   * `--enable-single': Builds a version that works in single precision
     mode, rather than in the standard double precision. It will work
     faster.  Unfortunately we are not yet fully sure of the proper
     functioning of the code in this manner.  The suffix `_single' is
     appended to the `octopus' executable name.

   * `--enable-mpi': Builds the parallel version (MPI) of `octopus'.
     The suffix `_mpi' is appended to the `octopus' executable name.



File: octopus.info,  Node: Troubleshooting,  Prev: Different octopus executables,  Up: Installation

3.4 Troubleshooting
===================

If you are reading this it is because something went wrong. Let us see
if we can fix it ;)

   *Could not find library...*: This is probably the most common error
you can get. `octopus' uses three different libraries, GSL, FFTW, and
BLAS/LAPACK. We assume that you have already installed these libraries
but, for some reason, you were not able to compile the code. So, what
went wrong?
   * Did you pass the correct `--with-XXXX' (where XXXX is gsl, fftw or
     lapack in lowercase) to the configure script? If your libraries are
     installed in a non-standard directory (like `/opt/lapack'), you
     will have to pass the script the location of the library (in this
     example, you could try `./configure --with-lapack='-L/opt/lapack
     -llapack''.

   * If you are working on an alpha station, do not forget that the
     `CXML' library includes `BLAS' and `LAPACK', so it can be used by
     `octopus'. If needed, just set the correct path with
     `--with-lapack'.

   * If the configuration script can not find `FFTW', it is probable
     that you did not compile `FFTW' with the same Fortran compiler or
     with the same compiler options. The basic problem is that Fortran
     sometimes converts the function names to uppercase, at other times
     to lowercase, and it can add an "_" to them, or even two.
     Obviously all libraries and the program have to use the same
     convention, so the best is to compile everything with the same
     Fortran compiler/options. If you are a power user, you can check
     the convention used by your compiler using the command `nm
     <library>'.


   *Whatever went wrong...*: Up to now, we cannot really make a list of
commonly found problems. So if something else went wrong, please
subscribe to `octopus-users' mailing list, and ask.


File: octopus.info,  Node: The parser,  Next: Input Variables,  Prev: Installation,  Up: Top

4 The parser
************

All input options should be in a file called "`inp'", in the directory
`octopus' is run from. Alternatively, if this file is not found,
standard input is read. For a fairly comprehensive example, just look
at the file `OCTOPUS_HOME/share/samples/Na2' -- if you installed the
code (you did the `make install'), this file will also be in
`PREFIX/share/octopus/samples/Na2'.

   At the beginning of the program `liboct' reads the input file,
parses it, and generates a list of variables that will be read by
`octopus' (note that the input is case independent).  There are two
kind of variables, scalar values (strings or numbers), and blocks (that
you may view as matrices). A scalar variable `var' can be defined by:
     var = exp
   `var' can contain any alphanumeric character plus "_", and `exp' can
be a quote delimited string, a number (integer, real, or complex), a
variable name, or a mathematical expression.  In the expressions all
arithmetic operators are supported ("a+b", "a-b", "a*b", "a/b"; for
exponentiation the C syntax "a^b" is used), and the following functions
can be used:
   * `sqrt(x)': The square root of `x'.

   * `exp(x)': The exponential of `x'.

   * `log(x)' or `ln(x)': The natural logarithm of `x'.

   * `log10(x)': Base 10 logarithm of `x'.

   * `sin(x)', `cos(x)', `tan(x)', `cot(x)',   `sec(x)', `csc(x)': The
     sinus, co-sinus, tangent, co-tangent,   secant and co-secant of
     `x'.

   * `asin(x)', `acos(x)', `atan(x)', `acot(x)',   `asec(x)',
     `acsc(x)': The inverse (arc-) sinus, co-sinus, tangent, co-tangent,
      secant and co-secant of `x'.

   * `sinh(x)', `cosh(x)', `tanh(x)', `coth(x)',   `sech(x)',
     `csch(x)': The hyperbolic sinus, co-sinus, tangent, co-tangent,
     secant and co-secant of `x'.

   * `asinh(x)', `acosh(x)', `atanh(x)', `acoth(x)',   `asech(x)',
     `acsch(x)': The inverse hyperbolic sinus, co-sinus, tangent,
     co-tangent,   secant and co-secant of `x'.
   You can also use any of the predefined variables:
   * `pi': 3.141592653589793, what else is there to say?

   * `e': The base of the natural logarithms.

   * `false' or `f' or `no': False in all its flavors. For the
     curious, `false' is defined as 0.

   * `true' or `t' or `yes': The truthful companion of `false'. For the
      curious, `true' is defined as 1.

   Blocks are defined as a collection of values, organised in row and
column format.  The syntax is the following:
     %var
       exp | exp | exp | ...
       exp | exp | exp | ...
       ...
     %
   Rows in a block are separated by a newline, while columns are
separated by the character "|" or by a tab. There may be any number of
lines and any number of columns in a block. Note also that each line
can have a different number of columns.

   If `octopus' tries to read a variable that is not defined in the
input file, it automatically assigns to it a default value. All
variables read are output to the file "`out.oct'". If you are not sure
of what the program is reading, just take a look at it.  Everything
following the character "#" until the end of the line is considered a
comment and is simply cast into oblivion.


File: octopus.info,  Node: Input Variables,  Next: Undocumented Variables,  Prev: The parser,  Up: Top

5 Input Variables
*****************

`octopus' has quite a few options, that we will subdivide in different
groups.  After the name of the option, its type and default value (when
applicable) are given in parenthesis.

* Menu:

* Generalities::
* Hamiltonian::
* Spectrum Calculations::
* States::
* System::
* Time Dependent::
* Unoccupied States::


File: octopus.info,  Node: Generalities,  Next: Hamiltonian,  Prev: Input Variables,  Up: Input Variables

5.1 Generalities
================

   * *CalculationMode*
     _Section_: Generalities
     _Default_: gs
     Decides what kind of calculation is to be performed

     _Options_:
        - *gs* (01):  Calculation of the ground state

        - *unocc* (02):  Calculation of unoccupied/virtual KS states

        - *td* (03):  Time-dependent calculation

        - *pol* (04):  Calculation of the static polarizability

        - *geom* (05):  Optimization of the geometry

        - *phonons* (06):  Calculation of the vibrational modes

        - *opt_control* (07):  Optimal control.

        - *pol_lr* (08):  Linear-response calculation of the
          polarizability

        - *casida* (09):  Excitations via linear-response TDDFT

        - *wave_matching* (10):  Wave-matching a la Heiko

        - *bo* (98):  Born-Oppenheimer-like Molecular Dynamics

        - *recipe* (99):  Prints out a tasty recipe

   * *Dimensions*
     _Section_: Generalities
     _Default_: 3
     octopus  can  run  in  1, 2 or 3 dimensions, depending on the
     value of this  variable. Note that not all input variables may be
     available in all cases.

     _Options_:
        - *1*:  The system is 1-dimensional

        - *2*:  The system is 2-dimensional

        - *3*:  The system is 3-dimensional


* Menu:

* Debug::
* IO::
* Parallel::
* Units::


File: octopus.info,  Node: Debug,  Next: IO,  Prev: Generalities,  Up: Generalities

5.1.1 Debug
-----------

   * *DebugLevel*
     _Section_: Generalities::Debug
     _Default_: 1
     This variable decides wether or not to enter debug-mode. In
     debugging mode,  the  program  prints  to  standard  error  when
     it  enters  and  exits the  subroutines, what is the memory it is
     using (only, for the moment being, in  Linux  systems),  and  some
     other  information. Useful for developers, and  mandatory  if
     you  want  to  send a bug report to the developers and being
     considered.  You  have  two options: (i) setting it to zero - or
     less than  zero, in which case you do not run in debugging mode
     (this is the default),  or (ii) setting it to a positive number.
     In this case the entries and exits  to  nested  subroutines are
     only printed down to the level that is given in  this variable.

   * *ProfilingMode*
     _Section_: Generalities::Debug
     _Default_: no
     Use  this  variable  to run octopus in profiling mode. In this
     mode octopus  records  time  spent  in  certain areas of the code
     and the number of times  this  code  is  executed.  These  numbers
     are  written  in  './profiling.NNN/profiling.nnn'  with  nnn
     being  the  node number (000 in  serial)  and  NNN  the number of
     processors. This is mainly for development  purposes.  Note,
     however,  that  octopus  should  be  compiled  with
     -disable-debug to do proper profiling.



File: octopus.info,  Node: IO,  Next: Parallel,  Prev: Debug,  Up: Generalities

5.1.2 IO
--------

   * *FlushMessages*
     _Section_: Generalities::IO
     _Default_: no
     In  addition to writing to stdout and stderr, the code messages
     may also be  flushed to "messages.stdout" and "messages.stderr",
     if this variable is set  to yes.

   * *WorkDir*
     _Section_: Generalities::IO
     _Default_: "."
     By default, all files are written and read from the working
     directory, i.e.   the  directory from which the executable was
     launched. This behavior can be  changed  by  setting  this
     variable: if you give it a name (other than ".")   the files are
     written and read in that directory.

   * *stderr*
     _Section_: Generalities::IO
     _Default_: "-"
     The standard error by default goes to, well, to standard error.
     This can be  changed  by  setting  this variable: if you give it a
     name (other than "-")  the output stream is printed in that file
     instead.

   * *stdout*
     _Section_: Generalities::IO
     _Default_: "-"
     The  standard output by default goes to, well, to standard output.
     This can  be changed by setting this variable: if you give it a
     name (other than "-")  the output stream is printed in that file
     instead.



File: octopus.info,  Node: Parallel,  Next: Units,  Prev: IO,  Up: Generalities

5.1.3 Parallel
--------------

   * *ParallelizationGroupRanks*
     _Section_: Generalities::Parallel
     Specifies  the  size  of the groups used for the parellization.
     For example  (n_d,  n_s, n_k) means we have n_p*n_s*n_k processors
     and that the k-points  should  be  divided in n_k groups, the
     states in n_s groups, and each state  in n_d domains.

   * *ParallelizationStrategy*
     _Section_: Generalities::Parallel
     _Default_: par_domains + par_states + par_kpoints
     Specifies  what  kind  of  parallelization strategy octopus should
     use. The  values  can  be  combined,  for  example "par_domains +
     par_states" means a  combined paralellization in domains and states

     _Options_:
        - *serial*:  Octopus will run in serial.

        - *par_domains* (1):  Octopus will run parallel in domains.

        - *par_states* (2):  Octopus will run parallel in states.

        - *par_kpoints* (4):  Octopus will run parallel in
          k-points/spin.



File: octopus.info,  Node: Units,  Prev: Parallel,  Up: Generalities

5.1.4 Units
-----------

   * *Units*
     _Section_: Generalities::Units
     _Default_: "a.u"
     Atomic  units  seem  to be the preferred system in the atomic and
     molecular  physics  community  (despite  the  opinion  of  some of
     the authors of this  program). Internally, the code works in
     atomic units. However, for input or  output,  some  people  like
     using eV for energies and AA for lengths. This  other system of
     units can also be used.

     _Options_:
        - *"a.u"*:  Atomic units

        - *"eVA"*:  Electron-volts for energy, Angstrom for length.

   * *UnitsInput*
     _Section_: Generalities::Units
     _Default_: "a.u"
     Same as "Units", but only refers to the values in the input files.
     That is,  if  UnitsInput  =  "eVA",  all  physical  values in the
     input files will be  considered to be in eV and Angstroms.

   * *UnitsOutput*
     _Section_: Generalities::Units
     _Default_: "a.u"
     Same  as  "Units",  but only refers to the values in the output
     files. That  is,  if UnitsInput = "eVA", all physical values in
     the output files will be  considered to be in eV and Angstroms.



File: octopus.info,  Node: Hamiltonian,  Next: Spectrum Calculations,  Prev: Generalities,  Up: Input Variables

5.2 Hamiltonian
===============

   * *MultigridLevels*
     _Section_: Hamiltonian
     Number of levels in the grid hierachy used for multigrid.

     _Options_:
        - *max_levels*:  Calculate  the  optimous  number  of  levels
          for the grid. Positive numbers  indicate an absolute numbers
          of levels, negative numbers are substracted to  maximum
          number of levels posible for the grid been used. A value of 1
          means  using  only  the  relaxation  operator  in  the finest
          grid. Default is the  maximun number of levels.

   * *NonInteractingElectrons*
     _Section_: Hamiltonian
     _Default_: no
     Sometimes  it  may  be  helpful  to  treat the electrons as
     non-interacting  particles,  i.e., not to take into account
     Hartree and exchange-correlation  effects  between  the
     electrons.  This variable may be used to toogle this  behavior on
     and off

     _Options_:
        - *no*:  Electrons are treated as *interacting* particles

        - *yes* (1):  Electrons are handled as *non-interacting*
          paticles

   * *SICorrection*
     _Section_: Hamiltonian
     _Default_: sic_none
     This  variable controls which Self Interaction Correction to use.
     Note that  this  correction  will be applyed to the functional
     chosen by 'XFunctional'  and 'CFunctional'

     _Options_:
        - *sic_none* (1):  No Self Interaction Correction

        - *sic_pz* (2):  SIC a Perdew Zunger, hadled by the OEP
          technique

        - *sic_amaldi* (3):  Amaldi correction term (NOT WORKING)


* Menu:

* Poisson::
* Casida::
* General::
* Curvilinear::
* Derivatives::
* Simulation Box::
* EigenSolver::
* Mixing::


File: octopus.info,  Node: Poisson,  Next: Casida,  Prev: Hamiltonian,  Up: Hamiltonian

5.2.1 Poisson
-------------

   * *PoissonSolver*
     _Section_: Hamiltonian::Poisson
     _Default_: fft
     Defines  which  method  to  use in order to solve the Poisson
     equation. The  default for 1D and 2D is the direct evaluation of
     the Hartree potential.

     _Options_:
        - *direct1D* (-1):  Direct evaluation of the Hartree potential
          (in 1D)

        - *direct2D* (-2):  Direct evaluation of the Hartree potential
          (in 2D)

        - *fft*:  FFTs using spherical cutoff (in 2D or 3D; uses FFTW)

        - *fft_cyl* (1):  FFTs using cylindrical cutoff (in 3D; uses
          FFTW)

        - *fft_pla* (2):  FFTs using planar cutoff (in 3D; uses FFTW)

        - *fft_nocut* (3):  FFTs without using a cutoff (in 3D; uses
          FFTW)

        - *fft_corrected* (4):  FFTs + corrections

        - *cg* (5):  Conjugated gradients

        - *cg_corrected* (6):  Corrected conjugated gradients

        - *multigrid* (7):  Multigrid method

   * *PoissonSolverMaxMultipole*
     _Section_: Hamiltonian::Poisson
     Order  of  the  multipolar expansion for boundary corrections.
     Default is 4  for cg_corrected and multigrid and 2 for
     fft_corrected.

   * *PoissonSolverThreshold*
     _Section_: Hamiltonian::Poisson
     The  tolerance  for  the  poisson  solution,  used  by the cg and
     multigrid  solvers. Default is $10^(-5)$.


* Menu:

* Multigrid::


File: octopus.info,  Node: Multigrid,  Prev: Poisson,  Up: Poisson

5.2.1.1 Multigrid
.................

   * *PoissonSolverMGMaxCycles*
     _Section_: Hamiltonian::Poisson::Multigrid
     _Default_: 20
     Maximum number of multigrid cycles that are performed if
     convergence is not  achieved

   * *PoissonSolverMGPostsmoothingSteps*
     _Section_: Hamiltonian::Poisson::Multigrid
     _Default_: 3
     Number  of  gauss-seidel  smoothing  steps after coarse level
     correction in  multigrid Poisson solver

   * *PoissonSolverMGPresmoothingSteps*
     _Section_: Hamiltonian::Poisson::Multigrid
     _Default_: 3
     Number  of  gauss-seidel  smoothing steps before coarse level
     correction in  multigrid Poisson solver.

   * *PoissonSolverMGRelaxationMethod*
     _Section_: Hamiltonian::Poisson::Multigrid
     _Default_: Gauss-Seidel
     Method  used  from  fine  to  relax,  i.e.  to  solve  the  linear
     system  approximately,  in the multigrid procedure that solve
     Poisson equation. For  the moment, the option conjugate gradients
     is experimental. For curvilinear  coordinates the default is
     Gauss-Jacobi

     _Options_:
        - *gauss-seidel* (1):  Gauss-Seidel

        - *gauss-jacobi* (2):  Gauss-Jacobi

        - *cg* (5):  Conjugate-gradients

   * *PoissonSolverMGRestrictionMethod*
     _Section_: Hamiltonian::Poisson::Multigrid
     _Default_: fullweight
     Method used from fine to coarse grid transfer

     _Options_:
        - *injection* (1):  Injection

        - *fullweight* (2):  Fullweight restriction



File: octopus.info,  Node: Casida,  Next: General,  Prev: Poisson,  Up: Hamiltonian

5.2.2 Casida
------------

   * *LinearResponseKohnShamStates*
     _Section_: Linear Response::Casida
     The  calculation  of  the  excitation  spectrum  of  a  system  in
     the  frequency-domain  formulation  of  linear-response
     time-dependent  density  functional  theory  (TDDFT)  implies  the
     use  of  a  basis  set  of  occupied/unoccupied  Kohn-Sham
     orbitals.  This  basis  set  should,  in  principle, include all
     pairs formed by all occupied states, and an infinite  number  of
     unoccupied  states. In practice, one has to truncate this basis
     set,  selecting  a  number of occupied and unoccupied states that
     will form  the  pairs.  These  states  are specified with this
     variable. If there are,  say,  10  occupied states, and one sets
     this variable to the value "10-18",  this  means  that occupied
     states from 10 to 15, and unoccupied states from  16 to 18 will be
     considered.

     This  variable  is  a  string  in  list  form,  i.e.  expressions
     such  as  "1,2-5,8-15"  are valid. You should include a non-null
     number of unoccupied  states and a non-null number of occupied
     states.



File: octopus.info,  Node: General,  Next: Curvilinear,  Prev: Casida,  Up: Hamiltonian

5.2.3 General
-------------

   * *ODESolver*
     _Section_: Math::General
     _Default_: ode_rk4
     Specifies what kind of root solver will be used

     _Options_:
        - *ode_rk4* (1):  Standard Runge-Kutta 4th order

        - *ode_fb78* (2):  Fehlberg solver

        - *ode_vr89* (3):  Verner solver

        - *ode_pd89* (4):  Prince-Dormand solver

   * *RootSolver*
     _Section_: Math::General
     _Default_: root_newton
     Specifies what kind of root solver will be used

     _Options_:
        - *root_bisection* (1):  Bisection method

        - *root_brent* (2):  Brent method

        - *root_newton* (3):  Newton method

        - *root_laguerre* (4):  Laguerre method

        - *root_watterstrom* (5):  Watterstrom method

   * *ScalarMeshType*
     _Section_: Math::General
     _Default_: mesh_sinh
     Specifies what kind of scalar mesh will be used

     _Options_:
        - *mesh_linear* (1):  Linear mesh

        - *mesh_double_log* (2):  Logarithmic mesh

        - *mesh_log* (3):  Double logarithmic mesh

        - *mesh_sinh* (4):  Sinh mesh

        - *gauss_legendre* (5):  Gauss-Legendre mesh

   * *SparskitSolver*
     _Section_: Math::General
     _Default_: sk_cg
     Specifies what kind of linear solver will be used

     _Options_:
        - *sk_dqgmres* (10):  Direct versions of Quasi Generalize
          Minimum Residual method

        - *sk_cg* (1):  Conjugate Gradient Method

        - *sk_cgnr* (2):  Conjugate Gradient Method (Normal Residual
          equation)

        - *sk_bcg* (3):  Bi-Conjugate Gradient Method

        - *sk_dbcg* (4):  BCG with partial pivoting

        - *sk_bcgstab* (5):  BCG stabilized

        - *sk_tfqmr* (6):  Transpose-Free Quasi-Minimum Residual method

        - *sk_fom* (7):  Full Orthogonalization Method

        - *sk_gmres* (8):  Generalized Minimum Residual method

        - *sk_fgmres* (9):  Flexible version of Generalized Minimum
          Residual method



File: octopus.info,  Node: Curvilinear,  Next: Derivatives,  Prev: General,  Up: Hamiltonian

5.2.4 Curvilinear
-----------------

   * *CurvMethod*
     _Section_: Mesh::Curvilinear
     _Default_: curv_uniform
     The  relevant functions in octopus are represented on a mesh in
     real space.   This mesh may be an evenly spaced regular
     rectangular grid (standard mode),  or else an *adaptive* or
     *curvilinear grid*. We have implemented (not still  finished,
     this  is  still  an experimental feature) three kinds of adative
     meshes.

     _Options_:
        - *curv_uniform* (1):  Regular, uniform rectangular grid. The
          default.

        - *curv_gygi* (2):  The deformation of the grid is done
          according to the scheme described by F.   Gygi [F. Gygi and
          G. Galli, Phys. Rev. B 52, R2229 (1995)]

        - *curv_briggs* (3):  The  deformation  of  the grid is done
          according to the scheme described by  Briggs  [E.L. Briggs,
          D.J. Sullivan, and J. Bernholc, Phys. Rev. B 54 14362  (1996)]

        - *curv_modine* (4):  The  deformation  of  the grid is done
          according to the scheme described by  Modine  [N.A.  Modine,
          G.  Zumbach  and E. Kaxiras, Phys. Rev. B 55, 10289  (1997)]


* Menu:

* Gygi::


File: octopus.info,  Node: Gygi,  Prev: Curvilinear,  Up: Curvilinear

5.2.4.1 Gygi
............

   * *CurvGygiA*
     _Section_: Mesh::Curvilinear::Gygi
     The  grid spacing is reduced locally around each atom, and the
     reduction is  given  by 1/(1+A), where A is specified by this
     variable, CurvGygiA. So, if  A=1 (the default), the grid spacing
     is reduced to one half = 1/(1+1). [This  is  the  A_(\alpha)
     variable in Eq. 2 of F. Gygi and G. Galli, Phys. Rev. B  52, R2229
     (1995)] It must be larger than zero.

   * *CurvGygiAlpha*
     _Section_: Mesh::Curvilinear::Gygi
     This number determines the region over which the grid is enhanced
     (range of  enhancement  of  the resolution). That is, the grid is
     enhanced on a sphere  around  each  atom,  whose  radius  is given
     by this variable. [This is the  a_(\alpha)  variable  in  Eq.  2
     of F. Gygi and G. Galli, Phys. Rev. B 52,  R2229  (1995)].  The
     default  is  two atomic units. It must be larger than  zero.

   * *CurvGygiBeta*
     _Section_: Mesh::Curvilinear::Gygi
     This  number  determines  the distance over which Euclidean
     coordinates are  recovered.  [This  is  the  b_(\alpha)  variable
     in Eq. 2 of F. Gygi and G.   Galli, Phys. Rev. B 52, R2229
     (1995)]. The default is four atomic units. It  must be larger than
     zero.



File: octopus.info,  Node: Derivatives,  Next: Simulation Box,  Prev: Curvilinear,  Up: Hamiltonian

5.2.5 Derivatives
-----------------

   * *DerivativesStencil*
     _Section_: Mesh::Derivatives
     _Default_: stencil_star
     Decides  what  kind of stencil is used, i.e. what points, around
     each point  in  the  mesh,  are  the  neighboring  points used in
     the expression of the  differential operator.

     _Options_:
        - *stencil_star* (1):  A star around each point (i.e., only
          points in the axis).

        - *stencil_variational* (2):  Same as the star, but with
          coefficients built in a different way.

        - *stencil_cube* (3):  A cube of points around each point.

        - *stencil_starplus* (4):  The star, plus a number of off-axis
          points.



File: octopus.info,  Node: Simulation Box,  Next: EigenSolver,  Prev: Derivatives,  Up: Hamiltonian

5.2.6 Simulation Box
--------------------

   * *BoxShape*
     _Section_: Mesh::Simulation Box
     _Default_: minimum
     This  variable  decides  the  shape  of  the simulation box. Note
     that some  incompatibilities apply:

     - Spherical or minimum mesh is not allowed for periodic systems.

     -  Cylindrical  mesh  is  not allowed for systems that are
     periodic in more  than one dimension.

     _Options_:
        - *sphere* (1):  The simulation box will be a sphere of radius
          Radius

        - *cylinder* (2):  The  simulation  box  will  be a cylinder
          with radius Radius and height two  times Xlength

        - *minimum* (3):  The  simulation  box  will  be constructed by
          adding spheres created around  each atom (or user defined
          potential), of radius Radius.

        - *parallelepiped* (4):  The  simulation box will be a
          parallelpiped whose dimensions are taken from  the variable
          lsize.

   * *Lsize*
     _Section_: Mesh::Simulation Box
     In  case BoxShape is "parallelepiped", this is assumed to be a
     block of the  form:

     %Lsize
     sizex | sizey | sizez
     %

     where the "size*" are half the lengths of the box in each
     direction.

     If  BoxShape  is "parallelpiped", this block has to be defined in
     the input  file.  The  number  of  columns  must  match  the
     dimensionality  of  the  calculation.

   * *PeriodicDimensions*
     _Section_: Mesh::Simulation Box
     Define which directions are to be considered periodic. Of course,
     it has to  be a number from 0 to three, and it cannot be larger
     than Dimensions.

     _Options_:
        - *0*:  No direction is periodic (molecule)

        - *1*:  The x direction is periodic (wire)

        - *2*:  The x and y directions are periodic (slab)

        - *3*:  The x, y, and z directions are periodic (bulk)

   * *Radius*
     _Section_: Mesh::Simulation Box
     If BoxShape is not "parallelepiped" defines the radius of the
     spheres or of  the  cylinder.  It has to be a positive number. If
     it is not defined in the  input  file,  then the program will
     attempt to fine a suitable default, but  this  is not always
     possible, in which case the code will stop issuing this  error
     message.

   * *Xlength*
     _Section_: Mesh::Simulation Box
     If BoxShape is "cylinder", it is half the total length of the
     cylinder.



File: octopus.info,  Node: EigenSolver,  Next: Mixing,  Prev: Simulation Box,  Up: Hamiltonian

5.2.7 EigenSolver
-----------------

   * *EigenSolver*
     _Section_: SCF::EigenSolver
     _Default_: cg
     Decides  the  eigensolver  that  obtains  the  lowest  eigenvalues
     and  eigenfunctions of the Kohn-Sham Hamiltonian.

     _Options_:
        - *trlan* (1):  Lanczos scheme, as implemented in the TRLan
          package.

        - *plan* (2):  Preconditioned Lanczos scheme.

        - *arpack* (3):  Implicitly Restarted Arnoldi Method, as
          implemented in the ARPACK package

        - *cg* (5):  Conjugate-gradients algorithm

        - *jdqz* (5):  Jacobi-Davidson scheme as implemented in the
          JDQZ package

        - *cg_new* (6):  A rewritting of the cg option, that will
          eventually substitute it.

        - *evolution* (7):  Propagation in imaginary time

   * *EigenSolverArnoldiVectors*
     _Section_: SCF::EigenSolver
     _Default_: 20
     This  indicates  how  many  Arnoldi  vectors  are generated It
     must satisfy  EigenSolverArnoldiVectors  -  Number  Of
     Eigenvectors >= 2. See the ARPACK  documentation for more details.

   * *EigenSolverImaginaryTime*
     _Section_: SCF::EigenSolver
     _Default_: 1.0
     The imaginary-time step that is used in the imaginary-time
     evolution method  to  obtain  the  lowest
     eigenvalues/eigenvectors.  It  must  satisfy
     EigenSolverImaginaryTime > 0.



File: octopus.info,  Node: Mixing,  Prev: EigenSolver,  Up: Hamiltonian

5.2.8 Mixing
------------

   * *MixNumberSteps*
     _Section_: SCF::Mixing
     _Default_: 3
     In  the  Broyden  and  in  the  GR-Pulay  scheme,  the new input
     density or  potential  is  constructed  from  the  values  of
     densities/potentials  of  previous  a given number of previous
     iterations. This number is set by this  variable.

   * *Mixing*
     _Section_: SCF::Mixing
     _Default_: 0.3
     Both  the linear and the Broyden scheme depend on a "mixing
     parameter", set  by this variable.

   * *TypeOfMixing*
     _Section_: SCF::Mixing
     The scheme scheme used to produce, at each iteration in the self
     consistent  cycle  that  attempts  to  solve the Kohn-Sham
     equations, the input density  from the value of the input and
     output densities of previous iterations.

     _Options_:
        - *linear*:  Simple linear mixing.

        - *gr_pulay* (1):  "Guaranteed-reduction" Pulay scheme (FIXME:
          Add reference).

        - *broyden* (2):  Broyden scheme (FIXME: Add reference).



File: octopus.info,  Node: Spectrum Calculations,  Next: States,  Prev: Hamiltonian,  Up: Input Variables

5.3 Spectrum Calculations
=========================

   * *HarmonicSpectrumMode*
     _Section_: Spectrum Calculations
     _Default_: hs_from_dipole
     The  oct-harmonic-spectrum  may  calculate  the spectrum in two
     alternative  ways,  mathematically  equivalent  but numerically
     diferent: by reading the  dipole  moment  (from  the multipoles
     file) and calculating the accelaratio  numerically  from  it,  or
     by  reading  directly the acceleration from the  acceleration
     file, which may also be generated during a time-dependent run  of
     octopus.

     _Options_:
        - *hs_from_dipole* (1):  Calculate  the  harmonic  spectrum  by
          numerically  differentiating  the  multipoles file.

        - *hs_from_acceleration* (2):  Calculate the harmonic spectrum
          by reading the acceleration file.

   * *HarmonicSpectrumPolarization*
     _Section_: Spectrum Calculations
     _Default_: "z"
     The oct-harmonic-spectrum utility program needs to know the
     direction along  which  the  emission  raidiation  is  considered
     to be polarized. It may be  linearly polarized or circularly
     polarized.

     _Options_:
        - *"+"*:  Circularly polarized field, counter clock-wise.

        - *"-"*:  Circularly polarized field, clock-wise.

        - *"x"*:  Linearly polarized field in the x direction.

        - *"y"*:  Linearly polarized field in the y direction.

        - *"z"*:  Linearly polarized field in the z direction.

   * *SpecDampMode*
     _Section_: Spectrum Calculations
     _Default_: polynomial
     Decides  which  damping/filtering  is  to  be applied in order to
     calculate  spectra by calculating a Fourier transform

     _Options_:
        - *no*:  No filtering at all.

        - *exponential* (1):  Exponential filtering, corresponding with
          a Lorentzian-shaped spectrum

        - *polynomial* (2):  Third-order polynomial damping.

        - *gaussian* (3):  Gaussian damping



File: octopus.info,  Node: States,  Next: System,  Prev: Spectrum Calculations,  Up: Input Variables

5.4 States
==========

   * *SpinComponents*
     _Section_: States
     _Default_: unpolarized
     The  calculations  may  be  done  in  three different ways:
     spin-restricted  (TD)DFT  (i.e.,  doubly  occupied  "closed
     shells"), spin-unsrestricted or  "spin-polarized" (TD)DFT (i.e. we
     have two electronic systes, one with spin  up and one with spin
     down), or making use of two-component spinors.

     _Options_:
        - *unpolarized* (1):  Spin-restricted calculations.

        - *spin_polarized* (2):  Spin  unrestricted,  also know as
          spin-DFT, SDFT. This mode will double the  number of wave
          functions will double the number of wave-functions necessary
          for a spin-unpolarised calculation.

        - *spinors* (3):  The  spin-orbitals  are  two-component
          spinors. This effectively allows the  spin-density  to
          arrange non-collinearly - i.e. the magnetization vector is
          allowed to take different directions in different points.



File: octopus.info,  Node: System,  Next: Time Dependent,  Prev: States,  Up: Input Variables

5.5 System
==========

   * *SystemName*
     _Section_: System
     _Default_: "system"
     A  string that identifies the current run. This parameter is
     seldomly used,  but it is sometimes useful to have in the input
     file.


* Menu:

* Coordinates::
* Species::
* Velocities::


File: octopus.info,  Node: Coordinates,  Next: Species,  Prev: System,  Up: System

5.5.1 Coordinates
-----------------

   * *Coordinates*
     _Section_: System::Coordinates
     If  neither  a  "XYZCoordinates"  nor a "PDBCoordinates" was
     found, octopus  tries  to  read the coordinates for the atoms from
     the block "Coordinates".   The format is quite straightforward:

     %Coordinates
     %nbsp;  'C'  |  -0.56415  |  0.0 | 0.0 | no
     'O' | 0.56415 | 0.0 | 0.0 | no
     %

     The  first  line  defines  a Carbon atom at coordinates
     ("-0.56415", "0.0",  "0.0"),  that  is  _not_  allowed to move
     during dynamical simulations. The  second  line  has  a similar
     meaning. This block obviously defines a Carbon  monoxide
     molecule,  if the input units are AA. Note that in this way it is
     possible to fix some of the atoms (this is not possible when
     specifying the  coordinates  through  a  "PDBCoordinates"  or
     "XYZCoordinates" file). It is  always possible to fix _all_ atoms
     using the "MoveIons" directive.

   * *PDBCoordinates*
     _Section_: System::Coordinates
     If  this  variable  is  present,  the  program  tries  to  read
     the atomic  coordinates  from  the  file  specified by its value.
     The PDB (Protein Data  Bank  (http://www.rcsb.org/pdb/))  format
     is quite complicated, and it goes  well  beyond  the  scope  of
     this  manual.  You  can  find a comprehensive  description  in  <a
     href='http://www.rcsb.org/pdb/docs/format/pdbguide2.2/guide2.2_frame.html'>here</a>.
     From the plethora of instructions defined in the PDB standard,
     octopus only  reads two, "ATOM" and "HETATOM". From these fields,
     it reads:
        *   columns  13-16  :  The specie; in fact "octopus" only cares
          about the  first  letter - "CA" and "CB" will both refer to
          Carbon - so elements whose  chemical  symbol  has  more  than
          one letter can not be represented in this  way.  So, if you
          want to run mercury ("Hg") please use one of the other two
          methods to input the atomic coordinates, "XYZCoordinates" or
          "Coordinates".

        *   columns  18-21 : The residue. If residue is "QM", the atom
          is treated  in  Quantum  Mechanics,  otherwise  it  is
          simply  treated  as an external  classical point charge. Its
          charge will be given by columns 61-65.

        *   columns  31-54  :  The  Cartesian  coordinates. The Fortran
          format is  "(3f8.3)".

        *   columns  61-65  : Classical charge of the atom. The Fortran
          format is  "(f6.2)".

   * *XYZCoordinates*
     _Section_: System::Coordinates
     If  "PDBCoordinates"  is  not  present,  the  program  reads  the
     atomic  coordinates from the XYZ file specified by the variable
     "XYZCoordinates" -  in  case this variable is present. The XYZ
     format is very simple: The first  line  of the file has an integer
     indicating the number of atoms. The second  can  contain  comments
     that  are  simply  ignored by "octopus". Then there  follows  one
     line  per  each atom, containing the chemical species and the
     Cartesian coordinates of the atom.



File: octopus.info,  Node: Species,  Next: Velocities,  Prev: Coordinates,  Up: System

5.5.2 Species
-------------

   * *Species*
     _Section_: System::Species
     A  specie  is  by  definition  either  an  "ion" (nucleus + core
     electrons)  described  through a pseudo-potential, or an
     user-defined, model potential.   The  format of this block is
     different for 1, 2 or 3 dimensions, and can be  best understood
     through examples.

     In 1D, or 2D, e.g.

     %Species
     'H'  | 1.0079 | 1 | "-1/sqrt(x^2 + 1)"
     %

     This  defines  a  species  labelled '_H_' of weight _1.0079_, and
     valence  charge 1. This "valence charge" is used to calculate the
     number of  electrons  present  in the calculation: as many as
     indicated by the valence  charges  of  the  species, plus any
     extra charge specified by the user. The  last  field may be any
     user defined potetial - use _x_, _r_ (and  _y_  in  the 2D case)
     for the position of the electron relative to the  species  center.
     For example, the potential often used in 1D calculation is  the
     soft-Coulomb  potential  -Z/\sqrt(x^2  + 1). The previous  example
     would then be an appropriate description of a Hydrogen nucleus for
     one-dimensional calculations.

     In 3D, e.g.

     %Species
     'O'  |  15.9994  |  8  |  "tm2"  |  1 | 1
     'H'  |  1.0079  | 1 | "hgh" | 0 | 0
     'jelli01' |  23.2  |  8.0  |  5.0
     'point01'  |  32.3  |  2.0
     'usdef' | 1 | 8 | "1/2*r^2"
     %

     In this case, we have 5 "species" present, which exemplify the
     five kinds  that may be present:

        *   Oxygen  labelled  '<it>O</it>'.  Next  number  is the
          atomic mass (in  atomic  mass  units), and third field, the
          atomic number (8, in this case).   Afterwards,  "tm2"  is the
          flavour of the pseudopotential: "tm2" stands for
          Troullier-Martins.  This  means  the  pseudopotential  will
          be read from an  _O.ascii_  or _O.vps_ file, either in the
          working directory or in  the  _OCTOPUS-HOME/share/PP/TM2_
          directory.  Next two numbers are the  maximum  _l_-component
          of the pseudo-potential to consider in the calculation,  and
          the _l_-component to consider as local.

        *  Hydrogen defined in the same way as Oxygen. In this case,
          however, the  flavour is "hgh" standing for
          Hartwigsen-Goedecker-Hutter. Last two numbers  are
          irrelevant,  since  they  do  are  not  necessary  to  define
          the HGH  pseudopotentials.

        *   All  species  whose  label starts by 'jelli' are jellium
          spheres. The  other parameters are the weight, the nuclear
          charge, and the valence charge  of the sphere.

        *  All species whose label starts by 'point' are point charges.
          The other  parameters  are  the  weight and the nuclear
          charge. In fact, point charges  are  implemented  as _rather
          small_ jellium spheres, with zero valence  charge.

        *  All species whose label starts by 'usdef' are user defined
          potentials.   The  second  parameter  is  the  mass,  whereas
          the third parameter is the  'valence  charge',  used to
          calculate the number of electrons. Finally, the  potential
          itself  is  defined  by  the  fourth  argument.  Use  any of
          the  _x_, _y_, _z_ or _r_ variables to define the potential.

     Note that some common pseudopotentials are distributed with the
     code in the  directory  _OCTOPUS-HOME/share/PP/_. To use these
     pseudopotentials you  are  not  required  to  define  them
     explicitly  in  the Species block, as  defaults  are  provided  by
     the program (you can override these defaults in  any case).
     Additional pseudopotentials can be downloaded from the  <a
     href='http://www.tddft.org/programs/octopus/pseudo.php'>octopus
     homepage<a>.



File: octopus.info,  Node: Velocities,  Prev: Species,  Up: System

5.5.3 Velocities
----------------

   * *RandomVelocityTemp*
     _Section_: System::Velocities
     If  this  variable is present, octopus will assign random
     velocities to the  atoms  following  a  Bolzmann  distribution
     with  temperature  given  by  RandomVelocityTemp.

   * *Velocities*
     _Section_: System::Velocities
     If  XYZVelocities  is  not  present,  octopus will try to fetch
     the initial  atomic  velocities  from  this block. If this block
     is not present, octopus  will  reset the initial velocities to
     zero. The format of this block can be  illustrated by this example:

     %Velocities
     'C' | -1.7 | 0.0 | 0.0
     'O'  | 1.7 | 0.0 | 0.0
     %

     It  describes  one Carbon and one Oxygen moving at the relative
     velocity of  3.4, velocity units.

     Note:  It is important for the velocities to maintain the ordering
     in which  the species were defined in the coordinates
     specifications.

   * *XYZVelocities*
     _Section_: System::Velocities
     octopus  will try to read the starting velocities of the atoms
     from the XYZ  file specified by the variable XYZVelocities
     ('velocities.xyz' by default).   Note  that  you  do  not  need to
     specify initial velocities if you are not  going  to  perform ion
     dynamics; if you are going to allow the ions to move  but the
     velocities are not specified, they are considered to be null.



File: octopus.info,  Node: Time Dependent,  Next: Unoccupied States,  Prev: System,  Up: Input Variables

5.6 Time Dependent
==================

   * *TDDeltaStrengthMode*
     _Section_: Time Dependent
     _Default_: kick_density
     When  calculating the linear response of the density via the
     propagation in  real  time, one needs to perfrom an initical kick
     on the KS system, at time  zero.  Depending  on  what kind
     response property one wants to obtain, this  kick may be done in
     several modes.

     _Options_:
        - *kick_density*:  The total density of the system is perturbed.

        - *kick_spin* (1):  The  individual  spin  densities  are
          perturbed differently. Note that this  mode  is  only
          possible if the run is done in spin polarized mode, or with
          spinors.

        - *kick_spin_and_density* (2):  A combination of the two above.
          Note that this mode is only possible if the  run is done in
          spin polarized mode, or with spinors.

   * *TDLasers*
     _Section_: Time Dependent
     The  block  TDLasers describe the type and shape of time-dependent
     external  perturbations  that  are  applied  to  the  system.
     Each line of the block  describes a laser field; this way you can
     actually have more than one laser  (e.g. a "pump" and a "probe").
     The syntax of each line is, then:

     %TDLasers

     nx  | ny | nz | amplitude | omega | envelope | tau0 | t0 | tau1 |
     filename1  | filename2

     %

     The  first three (possibly complex) numbers mark the polarization
     direction  of  the field. The "amplitude" is obviously the
     amplitude of the field. The  "omega"  is  the  frequency.  The
     "envelope"  decides  the  shape  of  the  enveloping  function -
     see the manual for details. "tau0", "t0" and "tau1"  are three
     paramenters that decide on the temporal shape of the pulse - the
     exact  details  depend on the particular envelope. If the envelope
     is given  in  a  file,  this will be "filename1". If the spatial
     part of the field is  given in a file, this will be "filename2".

     The  last three columns ("tau1", "filename1" and "filename2") are
     optional;  they will only be searched if needed.

     In  order  to  give the spatial shape of the field in a file, the
     component  "filename2"  has  to be present. If it is not present,
     then the laser field  will be a dipolar field (which is the usual
     case).



File: octopus.info,  Node: Unoccupied States,  Prev: Time Dependent,  Up: Input Variables

5.7 Unoccupied States
=====================

   * *WriteMatrixElements*
     _Section_: Unoccupied States
     _Default_: no
     If true outputs the following matrix elements:

     <i|T + V_ext|j>

     <ij| 1/|r1-r2| |kl>

     in the directory ME



File: octopus.info,  Node: Undocumented Variables,  Next: Examples,  Prev: Input Variables,  Up: Top

6 Undocumented Variables
************************

If you want to use these variables you will have to go to the code to
find out what they do. If you do it, please take the time to write a
short description and send a patch of the manual to us ;) BTW, some of
this variables describe things that may not work, or are under
developments, so don't blame us...
   o   AnimationSampling

   o   AxisType

   o   BoundaryZeroDerivative

   o   CenterOfInversion

   o   CurrentDFT

   o   GuessDensityAtomsMagnet

   o   KineticCutoff

   o   LB94_beta

   o   LB94_modified

   o   LB94_threshold

   o   OEP_level

   o   OEP_mixing

   o   OptControlAlpha

   o   OptControlEps

   o   OptControlInitLaser

   o   OptControlMaxIter

   o   OutputDuringSCF

   o   OutputELF_FS

   o   OutputWfsSqMod

   o   PeriodicDimensions

   o   RestartFileFormat

   o   ShifKPoints

   o   StaticMagneticField

   o   TDDeltaStrengthMode

   o   TDOutputSpin

   o   VlocalCutoff

   o   FromScratch


File: octopus.info,  Node: Examples,  Next: Options Index,  Prev: Undocumented Variables,  Up: Top

7 Examples
**********

* Menu:

* Hello world::
* Benzene::


File: octopus.info,  Node: Hello world,  Next: Benzene,  Prev: Examples,  Up: Examples

7.0.1 Hello world
-----------------

As a first example, we will take a sodium atom.  With your favourite
text editor, create the following input "inp".
       SystemName = 'Na'
       CalculationMode = 1
       %Species
         'Na' | 22.989768 | 11 | "tm2" | 0 | 0
       %
       %Coordinates
         'Na' | 0.0 | 0.0 | 0.0 | no
       %
       Radius = 12.0
       Spacing = .6
       TypeOfMixing = 2

   This input file should be essentially self-explanatory.  Note that a
Troullier-Martins pseudopotential file ("Na.vps", or "Na.ascii") should
be accesible to the program. A sample "Na.ascii" may be found in
`OCTOPUS-HOME/share/PP/TM2'. If `octopus' was installed (`make install'
was issued after `make'), there should be no need to do anything - the
program should find it. Otherwise, you may as well place it in the
working directory.  Then run `octopus' - for example, do `octopus > out
', so that the output is stored in "out" file. If everything goes OK,
"out" should look like (1):
                         Running octopus, version 1.1
                  (build time - Fri Mar 14 14:23:49 CET 2003)

     Info: Calculation started on 2003/03/17 at 03:49:56
     Info: Reading pseudopotential from file:
           '/home/marques/share/octopus/PP/TM2/Na.ascii'
           Calculating atomic pseudo-eigenfunctions for specie Na....
           Done.
     Info: l =  0 component used as local potential
       Type = sphere           Radius [b] =  12.000
       Spacing [b] = ( 0.600, 0.600, 0.600)    volume/point [b^3] =  0.21600
       # inner mesh =  33401   # outer mesh =  18896
     Info: Derivatives calculated in real-space
     Info: Local Potential in Reciprocal Space.
     Info: FFTs used in a double box (for poisson | local potential)
           box size = (  81,  81,  81)
           alpha =      2.00000
     Info: Using FFTs to solve poisson equation with spherical cutoff.
     Info: Exchange and correlation
           Exchange    family    : LDA
                       functional: non-relativistic
           Correlation family    : LDA
                       functional: Perdew-Zunger
     Info: Allocating rpsi.
     Info: Random generating starting wavefunctions.
     Info: Unnormalized total charge =      0.998807
     Info: Renormalized total charge =      1.000000
     Info: Setting up Hamiltonian.
     Info: Performing LCAO calculation.
     Info: LCAO basis dimension:      1
           (not considering spin or k-points)
     Eigenvalues [H]
        #   Eigenvalue    Occupation      Error (1)
        1    -0.102098       1.000000
     Info: SCF using real wavefunctions.
     Info: Broyden mixing used. It can (i) boost your convergence,
           (ii) do nothing special, or (iii) totally screw up the run.
           Good luck!
     Info: Converged =     0
     Eigenvalues [H]
        #   Eigenvalue    Occupation      Error (1)
        1    -0.102975       1.000000      (2.8E-02)
     Info: iter =    1 abs_dens = 0.53E-03 abs_ener = 0.60E+00

     Info: Converged =     0
     Eigenvalues [H]
        #   Eigenvalue    Occupation      Error (1)
        1    -0.102477       1.000000      (1.4E-03)
     Info: iter =    2 abs_dens = 0.43E-03 abs_ener = 0.65E-05

     Info: Converged =     1
     Eigenvalues [H]
        #   Eigenvalue    Occupation      Error (1)
        1    -0.102419       1.000000      (5.1E-04)
     Info: iter =    3 abs_dens = 0.39E-04 abs_ener = 0.20E-06

     Info: Converged =     1
     Eigenvalues [H]
        #   Eigenvalue    Occupation      Error (1)
        1    -0.102436       1.000000      (8.5E-05)
     Info: iter =    4 abs_dens = 0.24E-04 abs_ener = 0.52E-08

     Info: Converged =     1
     Eigenvalues [H]
        #   Eigenvalue    Occupation      Error (1)
        1    -0.102437       1.000000      (1.5E-06)
     Info: iter =    5 abs_dens = 0.14E-05 abs_ener = 0.36E-10

     Info: SCF converged in    5 iterations
     Info: Deallocating rpsi.
     Info: Calculation ended on 2003/03/17 at 03:50:04
   Take now a look at the working directory. It should include the
following files:
     -rw-rw-r--    1 user  group       177 Jul 10 12:29 inp
     -rw-rw-r--    1 user  group      4186 Jul 10 12:35 out
     -rw-rw-r--    1 user  group      1626 Jul 10 12:35 out.oct
     drwxrwxr-x    2 user  group      4096 Jul 10 12:35 static
     drwxrwxr-x    2 user  group      4096 Jul 10 12:35 tmp

   Besides the initial file (`inp') and the `out' file, two new
directories appear. In `static', you will find the file `info', with
information about the static calculation (it should be hopefully
self-explanatory, otherwise please complain to the authors).  In `tmp',
you will find the `restart.static', a binary file containg restart
information about the ground-state, which is used if, for example, you
want to start a time-dependent calculation afterwards.  Finally, you
can safely ignore `out.oct': it is an output from the liboct library,
irrelevant for what concerns physics ;).

   *Exercises*:
   * Study how the total energy and eigenvalue of the sodium atom
     improve   with the mesh spacing.

   * Calculate the static polarizability of the sodium atom
     (`CalculationMode = 7').    Two new files will be generated:
     `restart.pol' that can be used to resume   the polarizability
     calculation, and `Na.pol' that contains the static polarizability
     tensor. Note that this calculation overwrites
     `tmp/restart.static', so that   what now is there is the ground
     state for the system _with_ an external static   electrical field
     applied. Delete it since it is useless.

   * Calculate a few unoccupied states (`CalculationMode = 3'). The
     eigenspectrum   will be in the file `eigenvalues'. Why don't we
     find a Rydberg series in the   eigenspectrum?

   * Repeat the previous calculation with PBE, LB94, and exact exchange.
      Don't forget to *move* the file `tmp/restart.static' when
     switching   between exchange-correlation functionals.

   * Perform a time-dependent evolution (`CalculationMode = 5'), to
     calculate   the optical spectrum of the Na atom. Use a
     `TDDeltaStrength = 0.05', polarised   in the `x' direction. The
     multipole moments of the density are output to   the file
     `td.general/multipoles'. You can process this file with the utility
      `strength-function' to obtain the optical spectrum.    If you
     have computer time to waste, re-run the time-dependent
     simulation for some other xc choices.


   ---------- Footnotes ----------

   (1) Before this output, a beautiful octopus ascii-art picture may be
printed...


File: octopus.info,  Node: Benzene,  Prev: Hello world,  Up: Examples

7.0.2 Benzene
-------------

Well, the sodium atom is a bit too trivial. Let's try something harder:
benzene.  you will just need the geometry for benzene to be able to
play. Here it is (in AA):
      C  0.000  1.396  0.000
      C  1.209  0.698  0.000
      C  1.209 -0.698  0.000
      C  0.000 -1.396  0.000
      C -1.209 -0.698  0.000
      C -1.209  0.698  0.000
      H  0.000  2.479  0.000
      H  2.147  1.240  0.000
      H  2.147 -1.240  0.000
      H  0.000 -2.479  0.000
      H -2.147 -1.240  0.000
      H -2.147  1.240  0.000

   Follow now the steps of the previous example. Carbon and Hydrogen
have a much harder pseudo-potential than Sodium, so you will probably
have to use a tighter mesh. It also takes much more time...


File: octopus.info,  Node: Options Index,  Prev: Examples,  Up: Top

Options Index
*************

 [index ]
* Menu:

* BoxShape
:                             Simulation Box.                  (line  7)
* CalculationMode
:                      Generalities.                           (line  7)
* Coordinates
:                          Coordinates.                        (line  7)
* CurvGygiA
:                            Gygi.                             (line  7)
* CurvGygiAlpha
:                        Gygi.                                 (line 16)
* CurvGygiBeta
:                         Gygi.                                (line 25)
* CurvMethod
:                           Curvilinear.                       (line  7)
* DebugLevel
:                           Debug.                             (line  7)
* DerivativesStencil
:                   Derivatives.                               (line  7)
* Dimensions
:                           Generalities.                      (line 38)
* EigenSolver
:                          EigenSolver.                        (line  7)
* EigenSolverArnoldiVectors
:            EigenSolver.                                      (line 32)
* EigenSolverImaginaryTime
:             EigenSolver.                                     (line 39)
* FlushMessages
:                        IO.                                   (line  7)
* HarmonicSpectrumMode
:                 Spectrum Calculations.                       (line  7)
* HarmonicSpectrumPolarization
:         Spectrum Calculations.                               (line 25)
* LinearResponseKohnShamStates
:         Casida.                                              (line  7)
* Lsize
:                                Simulation Box.               (line 33)
* Mixing
:                               Mixing.                        (line 15)
* MixNumberSteps
:                       Mixing.                                (line  7)
* MultigridLevels
:                      Hamiltonian.                            (line  7)
* NonInteractingElectrons
:              Hamiltonian.                                    (line 19)
* ODESolver
:                            General.                          (line  7)
* ParallelizationGroupRanks
:            Parallel.                                         (line  7)
* ParallelizationStrategy
:              Parallel.                                       (line 14)
* PDBCoordinates
:                       Coordinates.                           (line 28)
* PeriodicDimensions
:                   Simulation Box.                            (line 49)
* PoissonSolver
:                        Poisson.                              (line  7)
* PoissonSolverMaxMultipole
:            Poisson.                                          (line 39)
* PoissonSolverMGMaxCycles
:             Multigrid.                                       (line  7)
* PoissonSolverMGPostsmoothingSteps
:    Multigrid.                                                (line 13)
* PoissonSolverMGPresmoothingSteps
:     Multigrid.                                               (line 19)
* PoissonSolverMGRelaxationMethod
:      Multigrid.                                              (line 25)
* PoissonSolverMGRestrictionMethod
:     Multigrid.                                               (line 41)
* PoissonSolverThreshold
:               Poisson.                                       (line 45)
* ProfilingMode
:                        Debug.                                (line 22)
* Radius
:                               Simulation Box.                (line 64)
* RandomVelocityTemp
:                   Velocities.                                (line  7)
* RootSolver
:                           General.                           (line 21)
* ScalarMeshType
:                       General.                               (line 37)
* SICorrection
:                         Hamiltonian.                         (line 34)
* SparskitSolver
:                       General.                               (line 53)
* SpecDampMode
:                         Spectrum Calculations.               (line 44)
* Species
:                              Species.                        (line  7)
* SpinComponents
:                       States.                                (line  7)
* stderr
:                               IO.                            (line 23)
* stdout
:                               IO.                            (line 31)
* SystemName
:                           System.                            (line  7)
* TDDeltaStrengthMode
:                  Time Dependent.                             (line  7)
* TDLasers
:                             Time Dependent.                  (line 28)
* TypeOfMixing
:                         Mixing.                              (line 21)
* Units
:                                Units.                        (line  7)
* UnitsInput
:                           Units.                             (line 22)
* UnitsOutput
:                          Units.                              (line 29)
* Velocities
:                           Velocities.                        (line 13)
* WorkDir
:                              IO.                             (line 14)
* WriteMatrixElements
:                  Unoccupied States.                          (line  7)
* Xlength
:                              Simulation Box.                 (line 73)
* XYZCoordinates
:                       Coordinates.                           (line 58)
* XYZVelocities
:                        Velocities.                           (line 32)



Tag Table:
Node: Top667
Node: Authors2352
Node: Copying5733
Node: Installation7213
Node: Quick instructions8202
Node: Long instructions8737
Ref: Long instructions-Footnote-118370
Ref: Long instructions-Footnote-218928
Node: Different octopus executables19140
Node: Troubleshooting20942
Node: The parser22888
Node: Input Variables26159
Node: Generalities26616
Node: Debug28076
Node: IO29612
Node: Parallel30929
Node: Units32013
Node: Hamiltonian33248
Node: Poisson35071
Node: Multigrid36580
Node: Casida38158
Node: General39418
Node: Curvilinear41480
Node: Gygi42777
Node: Derivatives44146
Node: Simulation Box44958
Node: EigenSolver47503
Node: Mixing48981
Node: Spectrum Calculations50101
Node: States52196
Node: System53319
Node: Coordinates53706
Node: Species56935
Node: Velocities60898
Node: Time Dependent62395
Node: Unoccupied States64891
Node: Undocumented Variables65237
Node: Examples66332
Node: Hello world66495
Ref: Hello world-Footnote-173118
Node: Benzene73202
Node: Options Index74019

End Tag Table
