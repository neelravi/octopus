#include "global.h"

module gga_m

  use derivatives_m, only: derivatives_t, dderivatives_grad, dderivatives_div
  use interface_xc_m
  use json_m, only: json_object_t
  use kinds_m, only: wp
  use XC_F90(lib_m), only: XC_POLARIZED, XC_UNPOLARIZED

  implicit none

  private
  public ::              &
    gga_init,            &
    gga_set_parameter,   &
    gga_get_kind,        &
    gga_get_exc,         &
    gga_get_exc_and_vxc, &
    gga_get_vxc,         &
    gga_end

  type, public :: gga_t
    private
    integer                      :: spin  = XC_NONE ! XC_UNPOLARIZED | XC_POLARIZED
    integer                      :: nspin = 0
    integer                      :: ndim  = 0
    type(derivatives_t), pointer :: der   =>null()
    type(interface_xc_t)         :: funct
  end type gga_t

contains

  ! ---------------------------------------------------------
  subroutine gga_init(this, der, id, nspin)
    type(gga_t),                 intent(out) :: this
    type(derivatives_t), target, intent(in)  :: der
    integer,                     intent(in)  :: id
    integer,                     intent(in)  :: nspin
    !
    this%der=>der
    ASSERT(nspin>0)
    this%nspin=nspin
    this%spin=XC_UNPOLARIZED
    if(nspin>1)this%spin=XC_POLARIZED
    this%ndim=this%der%mesh%sb%dim
    call interface_xc_init(this%funct, id, this%ndim, nspin)
    return
  end subroutine gga_init

  ! ---------------------------------------------------------
  subroutine gga_set_parameter(this, config)
    type(gga_t),         intent(inout) :: this
    type(json_object_t), intent(in)    :: config
    !
    call interface_xc_set_parameter(this%funct, config)
    return
  end subroutine gga_set_parameter

  ! ---------------------------------------------------------
  elemental function gga_get_kind(this) result(kind)
    type(gga_t), intent(in) :: this
    !
    integer :: kind
    !
    kind=interface_xc_get_kind(this%funct)
    return
  end function gga_get_kind

  ! ---------------------------------------------------------
  subroutine gga_potential_correction(this, potential, dedg)
    type(gga_t),                     intent(in)    :: this
    real(kind=wp), dimension(:,:),   intent(inout) :: potential
    real(kind=wp), dimension(:,:,:), intent(inout) :: dedg !Should be intent in only
    !
    real(kind=wp), dimension(size(potential,dim=1)) :: div
    integer                                         :: i
    !
    ! subtract the divergence of the functional derivative of Exc with respect to
    ! the gradient of the density.
    do i = 1, this%spin
      call dderivatives_div(this%der, dedg(:,:,i), div)
      potential(:,i)=potential(:,i)-div
    end do
    return
  end subroutine gga_potential_correction

  ! ---------------------------------------------------------
  subroutine gga_get_exc(this, density, exc)
    type(gga_t),                   intent(in)  :: this
    real(kind=wp), dimension(:,:), intent(in)  :: density
    real(kind=wp), dimension(:),   intent(out) :: exc
    !
    real(kind=wp), dimension(size(density,dim=1),this%spin) :: dens
    real(kind=wp), dimension(size(exc),this%ndim,this%spin) :: grad
    integer                                                 :: isp
    !
    call interface_xc_density(this%funct, dens, density)
    do isp = 1, this%spin
      call dderivatives_grad(this%der, dens(:,isp), grad(:,:,isp))
    end do
    call interface_xc_gga_exc(this%funct, dens, grad, exc)
    return
  end subroutine gga_get_exc

  ! ---------------------------------------------------------
  subroutine gga_get_exc_and_vxc(this, density, exc, vxc)
    type(gga_t),                   intent(in)  :: this
    real(kind=wp), dimension(:,:), intent(in)  :: density
    real(kind=wp), dimension(:),   intent(out) :: exc
    real(kind=wp), dimension(:,:), intent(out) :: vxc
    !
    real(kind=wp), dimension(size(density,dim=1),          this%spin ) :: dens
    real(kind=wp), dimension(size(exc),          this%ndim,this%nspin) :: grad
    real(kind=wp), dimension(size(density,dim=1),this%ndim,this%spin ) :: dedg
    integer                                                            :: isp
    !
    call interface_xc_density(this%funct, dens, density)
    do isp = 1, this%nspin
      call dderivatives_grad(this%der, dens(:,isp), grad(:,:,isp))
    end do
    call interface_xc_gga_exc_vxc(this%funct, dens, grad, exc, vxc, dedg)
    dedg(this%der%mesh%np+1:,:,:)=0.0_wp
    call gga_potential_correction(this, vxc, dedg)
    return
  end subroutine gga_get_exc_and_vxc

  ! ---------------------------------------------------------
  subroutine gga_get_vxc(this, density, potential)
    type(gga_t),                   intent(in)  :: this
    real(kind=wp), dimension(:,:), intent(in)  :: density
    real(kind=wp), dimension(:,:), intent(out) :: potential
    !
    real(kind=wp), dimension(this%der%mesh%np_part,this%spin)                      :: dens
    real(kind=wp), dimension(this%der%mesh%np,this%der%mesh%sb%dim,this%spin)      :: grad
    real(kind=wp), dimension(this%der%mesh%np_part,this%der%mesh%sb%dim,this%spin) :: dedg
    integer                                                                        :: isp
    !
    call interface_xc_density(this%funct, dens, density)
    do isp = 1, this%spin
      call dderivatives_grad(this%der, dens(:,isp), grad(:,:,isp))
    end do
    call interface_xc_gga_vxc(this%funct, dens(1:this%der%mesh%np,:), grad, &
      potential, dedg(1:this%der%mesh%np,:,:))
    dedg(this%der%mesh%np+1:,:,:)=0.0_wp
    call gga_potential_correction(this, potential, dedg)
    return
  end subroutine gga_get_vxc

  ! ---------------------------------------------------------
  subroutine gga_end(this)
    type(gga_t), intent(inout) :: this
    !
    call interface_xc_end(this%funct)
    this%der=>null()
    return
  end subroutine gga_end

end module gga_m

!! Local Variables:
!! mode: f90
!! End:
