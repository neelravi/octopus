!! Copyright (C) 2009
!!
!! This program is free software; you can redistribute it and/or modify
!! it under the terms of the GNU General Public License as published by
!! the Free Software Foundation; either version 2, or (at your option)
!! any later version.
!!
!! This program is distributed in the hope that it will be useful,
!! but WITHOUT ANY WARRANTY; without even the implied warranty of
!! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!! GNU General Public License for more details.
!!
!! You should have received a copy of the GNU General Public License
!! along with this program; if not, write to the Free Software
!! Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
!! 02111-1307, USA.
!!
!! $Id: output_etsf_inc.F90 5880 2009-09-03 23:44:44Z dstrubbe $

! ---------------------------------------------------------

#if defined(HAVE_ETSF_IO)

subroutine h_sys_output_etsf(st, gr, geo, dir, outp)
  type(states_t),         intent(in) :: st
  type(grid_t),           intent(in) :: gr
  type(geometry_t),       intent(in) :: geo
  character(len=*),       intent(in) :: dir
  type(h_sys_output_t),   intent(in) :: outp

  logical :: lstat
  integer :: i, j, idir, is, ik, idim, ix, iy, iz, nik, nspin, zdim
  FLOAT   :: offset(MAX_DIM)
  FLOAT, allocatable :: d(:), md(:,:)
  REAL_DOUBLE, allocatable, target :: local_rho(:,:,:,:), local_wfs(:,:,:,:,:,:,:), local_ev(:, :, :)
  REAL_DOUBLE, allocatable, target :: local_occ(:,:,:), local_red_coord_kpt(:,:), local_kpoint_weights(:)
  type(etsf_io_low_error)  :: error_data
  type(etsf_dims) :: dims
  type(etsf_groups) :: groups
  type(etsf_groups_flags), target :: flags
  type(etsf_main), target :: main
  type(etsf_geometry), target :: geometry
  type(etsf_electrons), target :: electrons
  type(etsf_kpoints), target :: kpoints
  type(dcf_t) :: cube

  call push_sub("output_etsf_inc.h_sys_output_etsf")

  if (iand(outp%what, output_geometry).ne.0) then
    !Create a cube
    call dcf_new (gr%mesh%idx%ll, cube)
    call dcf_alloc_RS(cube)    

    !Set the dimensions
    dims%number_of_atoms = geo%natoms
    dims%number_of_atom_species = geo%nspecies
    dims%number_of_symmetry_operations = 1

    ! Get the offset
    offset = -matmul(gr%sb%rlattice_primitive, gr%sb%lsize)
    do i = gr%sb%periodic_dim+1, 3
      offset(i)=-(cube%n(i) - 1)/2 * gr%mesh%spacing(i)
    end do

    !Next we created the geometry container
    !For now, we will assume a 3D finite system and we will use a cubic cell with no symmetry operations.
    flags%geometry = etsf_geometry_all - etsf_geometry_valence_charges - &
                    etsf_geometry_pseudo_types - etsf_geometry_atom_species_names
    groups%geometry => geometry
    SAFE_ALLOCATE(geometry%space_group)
    SAFE_ALLOCATE(geometry%primitive_vectors(1:3, 1:3))
    SAFE_ALLOCATE(geometry%reduced_symmetry_matrices(1:3, 1:3, 1:1))
    SAFE_ALLOCATE(geometry%reduced_symmetry_translations(1:3, 1:1))
    SAFE_ALLOCATE(geometry%reduced_atom_positions(3,geo%natoms))
    SAFE_ALLOCATE(geometry%atom_species(geo%natoms))
    SAFE_ALLOCATE(geometry%atomic_numbers(geo%nspecies))
    SAFE_ALLOCATE(geometry%chemical_symbols(geo%nspecies))
    do idir = 1, gr%sb%dim
      geometry%primitive_vectors(1:3, idir) = gr%sb%rlattice(1:3, idir)
    end do
    geometry%space_group = 1
    geometry%reduced_symmetry_matrices = reshape( (/ 1, 0, 0, 0, 1, 0, 0, 0, 1 /), (/ 3, 3, 1 /))
    geometry%reduced_symmetry_translations = reshape( (/ 0, 0, 0 /), (/ 3, 1 /))
    do i = 1, geo%natoms
      !Next line is obviously only valid if the primitive vectors are along the x, y, and z directions.
      do idir = 1, 3
        geometry%reduced_atom_positions(idir, i) = (geo%atom(i)%x(idir) - offset(idir))/geometry%primitive_vectors(idir, idir)
      end do
    end do
    forall(i = 1:geo%nspecies) geometry%atomic_numbers(i) = species_z(geo%species(i))
    forall(i = 1:geo%nspecies) geometry%chemical_symbols(i) = trim(species_label(geo%species(i)))
    do i = 1, geo%natoms
      do j = 1, geo%nspecies
        if (species_z(geo%atom(i)%spec) == species_z(geo%species(j))) then
          geometry%atom_species(i) = j
        end if
      end do
    end do

    !Open the file
    call etsf_io_data_init(dir//"/geometry-etsf.nc", flags, dims, &
         & "Crystallographic_data file", &
         & "Created by "//PACKAGE_STRING, &
         & lstat, error_data, overwrite=.true.)
    if (.not. lstat) then
      call etsf_io_low_error_handle(error_data)
      message(1) = "ETSF_IO returned a fatal error. See message above."
      call write_fatal(1)
    end if

    !Write the geometry to the file
    call etsf_io_data_write(dir//"/geometry-etsf.nc", &
         & groups, lstat, error_data)
    if (.not. lstat) then
      call etsf_io_low_error_handle(error_data)
      message(1) = "ETSF_IO returned a fatal error. See message above."
      call write_fatal(1)
    end if

    !Free the geometry container
    SAFE_DEALLOCATE_P(geometry%space_group)
    SAFE_DEALLOCATE_P(geometry%primitive_vectors)
    SAFE_DEALLOCATE_P(geometry%reduced_symmetry_matrices)
    SAFE_DEALLOCATE_P(geometry%reduced_symmetry_translations)
    SAFE_DEALLOCATE_P(geometry%reduced_atom_positions)
    SAFE_DEALLOCATE_P(geometry%atom_species)
    SAFE_DEALLOCATE_P(geometry%atomic_numbers)
    SAFE_DEALLOCATE_P(geometry%chemical_symbols)
    nullify(groups%geometry)
    flags%geometry = etsf_geometry_none

    !Destroy the cube
    call dcf_free(cube)

    !Reset the dimensions
    dims%number_of_atoms = 1
    dims%number_of_atom_species = 1
    dims%number_of_symmetry_operations = 1
  end if


  if (iand(outp%what, output_density).ne.0) then
    !Create a cube
    call dcf_new (gr%mesh%idx%ll, cube)
    call dcf_alloc_RS(cube)

    !Set the dimensions
    dims%number_of_components = st%d%nspin
    dims%number_of_grid_points_vector1 = cube%n(1)
    dims%number_of_grid_points_vector2 = cube%n(2)
    dims%number_of_grid_points_vector3 = cube%n(3)
    dims%real_or_complex_density = 1

    !Next we created the geometry container
    !We only need the primitive vectors
    flags%geometry = etsf_geometry_primitive_vectors
    groups%geometry => geometry
    SAFE_ALLOCATE(geometry%primitive_vectors(1:3, 1:3))
    do idir = 1, gr%sb%dim
      geometry%primitive_vectors(1:3, idir) = gr%sb%rlattice(1:3, idir)
    end do

    !Open the file
    flags%main = etsf_main_density
    call etsf_io_data_init(dir//"/density-etsf.nc", flags, dims, &
         & "Density file", &
         & "Created by "//PACKAGE_STRING, &
         & lstat, error_data, overwrite=.true.)
    if (.not. lstat) then
      call etsf_io_low_error_handle(error_data)
      message(1) = "ETSF_IO returned a fatal error. See message above."
      call write_fatal(1)
    end if

    !Write the density to the file
    SAFE_ALLOCATE(local_rho(1:cube%n(1), 1:cube%n(2), 1:cube%n(3), 1:st%d%nspin))
    if (st%d%ispin /= SPINORS) then
      do i = 1, st%d%nspin
        call dmesh_to_cube(gr%mesh, st%rho(:,i), cube)
        local_rho(1:cube%n(1), 1:cube%n(2), 1:cube%n(3), i) = cube%RS(1:cube%n(1), 1:cube%n(2), 1:cube%n(3))
      end do
    else
      SAFE_ALLOCATE(md(1:gr%mesh%np, 1:3))
      SAFE_ALLOCATE(d(1:gr%mesh%np_part))

      d = st%rho(:, 1) + st%rho(:, 2)
      call magnetic_density(gr%mesh, st, st%rho, md)

      call dmesh_to_cube(gr%mesh, d, cube)
      local_rho(1:cube%n(1), 1:cube%n(2), 1:cube%n(3), 1) = cube%RS(1:cube%n(1), 1:cube%n(2), 1:cube%n(3))
      do i = 1, 3
        call dmesh_to_cube(gr%mesh, md(:,i), cube)
        local_rho(1:cube%n(1), 1:cube%n(2), 1:cube%n(3), i+1) = cube%RS(1:cube%n(1), 1:cube%n(2), 1:cube%n(3))
      end do
      SAFE_DEALLOCATE_A(d)
      SAFE_DEALLOCATE_A(md)
    end if
    main%density%data4D => local_rho
    groups%main => main
    call etsf_io_data_write(dir//"/density-etsf.nc", &
         & groups, lstat, error_data)
    if (.not. lstat) then
      call etsf_io_low_error_handle(error_data)
      message(1) = "ETSF_IO returned a fatal error. See message above."
      call write_fatal(1)
    end if

    !Free the main container
    nullify(groups%main)
    nullify(main%density%data4D)
    SAFE_DEALLOCATE_A(local_rho)

    !Free the geometry container
    SAFE_DEALLOCATE_P(geometry%primitive_vectors)    
    nullify(groups%geometry)
    flags%geometry = etsf_geometry_none

    !Destroy the cube
    call dcf_free(cube)

    !Reset the dimensions
    dims%number_of_components = 1
    dims%number_of_grid_points_vector1 = 1
    dims%number_of_grid_points_vector2 = 1
    dims%number_of_grid_points_vector3 = 1
    dims%real_or_complex_density = 1
  end if


  if (iand(outp%what, output_wfs).ne.0) then
    !Create a cube
    call dcf_new (gr%mesh%idx%ll, cube)
    call dcf_alloc_RS(cube)    

    !Set the dimensions
    nspin = 1
    if (st%d%ispin == SPIN_POLARIZED) nspin = 2
    nik = st%d%nik/nspin
    if (st%wfs_type == M_REAL) then
      zdim = 1
    elseif(st%wfs_type == M_CMPLX) then
      zdim = 2
    end if    
    dims%max_number_of_states = st%nst
    dims%number_of_kpoints = nik
    dims%number_of_spins = nspin
    dims%number_of_spinor_components = st%d%dim
    dims%number_of_grid_points_vector1 = cube%n(1)
    dims%number_of_grid_points_vector2 = cube%n(2)
    dims%number_of_grid_points_vector3 = cube%n(3)
    dims%real_or_complex_wavefunctions = zdim

    !Created the geometry container
    flags%geometry = etsf_geometry_primitive_vectors + etsf_geometry_red_sym_matrices + etsf_geometry_red_sym_trans    
    groups%geometry => geometry
    SAFE_ALLOCATE(geometry%primitive_vectors(1:3, 1:3))
    SAFE_ALLOCATE(geometry%reduced_symmetry_matrices(1:3, 1:3, 1:1))
    SAFE_ALLOCATE(geometry%reduced_symmetry_translations(1:3, 1:1))
    do idir = 1, gr%sb%dim
      geometry%primitive_vectors(1:3, idir) = gr%sb%rlattice(1:3, idir)
    end do
    geometry%reduced_symmetry_matrices = reshape( (/ 1, 0, 0, 0, 1, 0, 0, 0, 1 /), (/ 3, 3, 1 /))
    geometry%reduced_symmetry_translations = reshape( (/ 0, 0, 0 /), (/ 3, 1 /))

    !Create the electrons container
    flags%electrons = etsf_electrons_eigenvalues + etsf_electrons_occupations + etsf_electrons_number_of_states
    SAFE_ALLOCATE(local_ev(1:st%nst, 1:nik, 1:nspin))
    SAFE_ALLOCATE(local_occ(1:st%nst, 1:nik, 1:nspin))
    do i = 1, st%nst
      do ik = 1, nik
        do is = 1, nspin 
          local_ev(i, ik, is) = st%eigenval(i, nspin*(ik-1) + is)
          local_occ(i, ik, is) = st%occ(i, nspin*(ik-1) + is)
        end do
      end do
    end do
    electrons%eigenvalues%data3D => local_ev
    electrons%occupations%data3D => local_occ
    groups%electrons => electrons

    !Create the kpoints container
    flags%kpoints = etsf_kpoints_red_coord_kpt + etsf_kpoints_kpoint_weights
    SAFE_ALLOCATE(local_red_coord_kpt(1:3, 1:nik))
    SAFE_ALLOCATE(local_kpoint_weights(1:nik))
    !Here we will assume a finite system (one k-point at Gamma)
    local_red_coord_kpt = reshape( (/0, 0, 0/), (/3, 1/))
    local_kpoint_weights = M_ONE
    kpoints%reduced_coordinates_of_kpoints => local_red_coord_kpt
    kpoints%kpoint_weights => local_kpoint_weights
    groups%kpoints => kpoints

    !Open the file
    flags%main = etsf_main_wfs_rsp
    call etsf_io_data_init(dir//"/wfs-etsf.nc", flags, dims, &
         & "Wavefunctions file", &
         & "Created by "//PACKAGE_STRING, &
         & lstat, error_data, overwrite=.true.)
    if (.not. lstat) then
      call etsf_io_low_error_handle(error_data)
      message(1) = "ETSF_IO returned a fatal error. See message above."
      call write_fatal(1)
    end if

    !Write the wavefunctions to the file
    SAFE_ALLOCATE(local_wfs(1:zdim, 1:cube%n(1), 1:cube%n(2), 1:cube%n(3), 1:st%d%dim, 1:st%nst, 1:st%d%nik))
    do is = 1, nspin
      do ik = 1, st%d%nik, nspin
        do i = 1, st%nst
          do idim = 1, st%d%dim
            if (st%wfs_type == M_REAL) then
              call dmesh_to_cube(gr%mesh, st%dpsi(1:gr%mesh%np_part, idim, i, ik+is-1), cube)
              local_wfs(1, 1:cube%n(1), 1:cube%n(2), 1:cube%n(3), idim, i, ik+(is-1)*nik) = &
                   cube%RS(1:cube%n(1), 1:cube%n(2), 1:cube%n(3))

            elseif(st%wfs_type == M_CMPLX) then
              call dmesh_to_cube(gr%mesh, &
                   real(st%zpsi(1:gr%mesh%np_part, idim, i, ik+is-1), REAL_PRECISION), cube)
              local_wfs(1, 1:cube%n(1), 1:cube%n(2), 1:cube%n(3), idim, i, ik+(is-1)*nik) = &
                   cube%RS(1:cube%n(1), 1:cube%n(2), 1:cube%n(3))

              call dmesh_to_cube(gr%mesh, aimag(st%zpsi(1:gr%mesh%np_part, idim, i, ik+is-1)), cube)
              local_wfs(2, 1:cube%n(1), 1:cube%n(2), 1:cube%n(3), idim, i, ik+(is-1)*nik) = &
                   cube%RS(1:cube%n(1), 1:cube%n(2), 1:cube%n(3))
              
            end if
          end do
        end do
      end do
    end do

    main%real_space_wavefunctions%data7D => local_wfs
    groups%main => main
    call etsf_io_data_write(dir//"/wfs-etsf.nc", &
         & groups, lstat, error_data)
    if (.not. lstat) then
      call etsf_io_low_error_handle(error_data)
      message(1) = "ETSF_IO returned a fatal error. See message above."
      call write_fatal(1)
    end if

    !Free the main container
    nullify(groups%main)
    nullify(main%real_space_wavefunctions%data7D)
    SAFE_DEALLOCATE_A(local_wfs)

    !Free the k-points container
    SAFE_DEALLOCATE_A(local_red_coord_kpt)
    SAFE_DEALLOCATE_A(local_kpoint_weights)
    nullify(groups%kpoints)
    nullify(kpoints%reduced_coordinates_of_kpoints)
    nullify(kpoints%kpoint_weights)
    flags%kpoints = etsf_kpoints_none

    !Free the electrons container
    SAFE_DEALLOCATE_A(local_occ)
    SAFE_DEALLOCATE_A(local_ev)
    nullify(groups%electrons)
    nullify(electrons%eigenvalues%data3D)
    nullify(electrons%occupations%data3D)
    flags%electrons = etsf_electrons_none

    !Free the geometry container
    SAFE_DEALLOCATE_P(geometry%primitive_vectors)
    SAFE_DEALLOCATE_P(geometry%reduced_symmetry_matrices)
    SAFE_DEALLOCATE_P(geometry%reduced_symmetry_translations)
    nullify(groups%geometry)
    flags%geometry = etsf_geometry_none

    !Destroy the cube
    call dcf_free(cube)

    !Reset the dimensions
    dims%max_number_of_states = 1
    dims%number_of_kpoints = 1
    dims%number_of_spins = 1
    dims%number_of_spinor_components = 1
    dims%number_of_grid_points_vector1 = 1
    dims%number_of_grid_points_vector2 = 1
    dims%number_of_grid_points_vector3 = 1
    dims%real_or_complex_wavefunctions = 1
  end if

  call pop_sub()
end subroutine h_sys_output_etsf

#endif

!! Local Variables:
!! mode: f90
!! coding: utf-8
!! End:
