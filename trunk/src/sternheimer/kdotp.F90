!!! Copyright (C) 2004 Xavier Andrade, Eugene S. Kadantsev (ekadants@mjs1.phy.queensu.ca)
!!
!! This program is free software; you can redistribute it and/or modify
!! it under the terms of the GNU General Public License as published by
!! the Free Software Foundation; either version 2, or (at your option)
!! any later version.
!!
!! This program is distributed in the hope that it will be useful,
!! but WITHOUT ANY WARRANTY; without even the implied warranty of
!! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!! GNU General Public License for more details.
!!
!! You should have received a copy of the GNU General Public License
!! along with this program; if not, write to the Free Software
!! Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
!! 02111-1307, USA.
!!
!! $Id: kdotp.F90 4145 2008-05-02 23:29:41Z xavier $

#include "global.h"
#define RESTART_DIR "kdotp/"
#define EM_RESTART_DIR "em_resp/"

module kdotp_m
  use datasets_m
  use em_resp_calc_m
  use geometry_m
  use global_m
  use grid_m
  use hamiltonian_m
  use io_m
  use io_function_m
  use kdotp_calc_m
  use lalg_basic_m
  use lalg_adv_m
  use loct_parser_m
  use linear_response_m
  use math_m
  use mesh_function_m
  use mesh_m
  use messages_m
  use mix_m
  use h_sys_output_m
  use pert_m
  use pol_lr_m
  use restart_m
  use states_m
  use sternheimer_m
  use string_m
  use system_m
  use units_m
  use v_ks_m
  
  implicit none

  private

  public :: &
       kdotp_lr_run,       &
       int2str      

  type kdotp_t
    type(pert_t) :: perturbation

    FLOAT, pointer :: eff_mass_inv(:, :, :, :)  ! inverse effective mass tensor
                                                ! (ik, ist, idir1, idir2)

    type(lr_t), pointer :: lr(:,:) ! linear response for (NDIM,1)
                                   ! second index is dummy; should only be 1
                                   ! for compatibility with em_resp routines

    logical :: ok                   ! is converged?
    integer :: occ_solution_method  ! how to get occupied components of response
    integer :: initialization       ! method for initialization of wfns
    FLOAT   :: degen_thres          ! maximum energy difference to be considered
                                    ! degenerate
    FLOAT   :: eta                  ! imaginary freq. added to Sternheimer eqn.
  end type kdotp_t

contains

  ! ---------------------------------------------------------
  subroutine kdotp_lr_run(sys, h, fromScratch)
    type(system_t), target, intent(inout) :: sys
    type(hamiltonian_t),    intent(inout) :: h
    logical,                intent(inout) :: fromScratch

    type(grid_t),   pointer :: gr
    type(kdotp_t)           :: kdotp_vars
    type(sternheimer_t)     :: sh
    logical                 :: calc_eff_mass

    type(lr_t), allocatable :: em_lr(:,:,:)
    logical                 :: calc_pol
    logical                 :: calc_hyperpol
    integer                 :: em_nfactor
    integer                 :: em_nsigma
    CMPLX                   :: alpha(MAX_DIM, MAX_DIM, 3) ! the linear polarizability

    integer            :: idir, ierr, size, is, ist, ik
    character(len=100) :: dirname, str_tmp
    FLOAT              :: elec_dipole(1:MAX_DIM) ! electronic contribution
    FLOAT              :: ion_dipole(1:MAX_DIM)  ! ionic contribution
    integer            :: isigma, ifactor

    call push_sub('kdotp.kdotp_lr_run')

    gr => sys%gr
!    ndim = sys%gr%sb%dim
    size = sys%st%d%nik * sys%st%nst * NDIM * NDIM

    ALLOCATE(kdotp_vars%eff_mass_inv(sys%st%d%nik, sys%st%nst, NDIM, NDIM), size)
    kdotp_vars%eff_mass_inv(:,:,:,:)=0  

    call pert_init(kdotp_vars%perturbation, PERTURBATION_KDOTP, sys%gr, sys%geo)

    ALLOCATE(kdotp_vars%lr(1:NDIM, 1), NDIM)

    call parse_input()

    call read_wfs(sys%st, sys%gr, sys%geo, .true.)
    ! even if wfs are real, the response must be allowed to be complex

    kdotp_vars%lr(1:NDIM, 1:1)%nst = sys%st%nst

    ! setup Hamiltonian
    message(1) = 'Info: Setting up Hamiltonian for linear response'
    call write_info(1)
    call system_h_setup(sys, h)
    
    call sternheimer_init(sh, sys, h, "KdotP_", hermitian = wfs_are_real(sys%st), &
         set_ham_var = 0, set_occ_response = (kdotp_vars%occ_solution_method == 0))
    ! ham_var_set = 0 results in HamiltonianVariation = V_ext_only

    do idir = 1, NDIM
      call lr_init(kdotp_vars%lr(idir, 1))
      call lr_allocate(kdotp_vars%lr(idir, 1), sys%st, sys%gr%m)

      if(fromScratch .and. kdotp_vars%initialization .eq. 1) then
        do is = 1, sys%st%d%dim
          do ist = 1, sys%st%nst
            do ik = 1, sys%st%d%nik
              kdotp_vars%lr(idir, 1)%zdl_psi(1:gr%m%np, is, ist, ik) &
                = -M_zI * gr%m%x(1:gr%m%np, idir) * sys%st%zpsi(1:gr%m%np, is, ist, ik)
            enddo
          enddo
        enddo
      endif
      ! this is the exact solution in the limit of no dispersion, i.e. non-interacting unit cells
      ! |u_i(1)> = -i r_i |u(0)>

      ! load wave-functions
      if(.not.fromScratch) then
         str_tmp =  kdotp_wfs_tag(idir)
         write(dirname,'(3a)') RESTART_DIR, trim(str_tmp), '_1'
         ! 1 is the sigma index which is used in em_resp
         call restart_read(trim(tmpdir)//dirname, sys%st, sys%gr, sys%geo, &
               ierr, lr=kdotp_vars%lr(idir, 1))
          
          if(ierr.ne.0) then
             message(1) = "Could not load response wave-functions from '"//trim(tmpdir)//dirname//"'"
             call write_warning(1)
          end if
          
       end if

    end do

    call io_mkdir(trim(tmpdir)//RESTART_DIR)
    call io_mkdir('kdotp/')
    call info()
    message(1) = "Info: Calculating kdotp linear response of ground-state wavefunctions."
    call write_info(1)
    kdotp_vars%ok = .true.

    ! solve the Sternheimer equation
    do idir = 1, NDIM
      write(message(1), '(a,i3)') 'Info: Calculating response for direction ', idir
      call write_info(1)
      call pert_setup_dir(kdotp_vars%perturbation, idir)
      call zsternheimer_solve(sh, sys, h, kdotp_vars%lr(idir,:), 1, &
        M_zI * kdotp_vars%eta, kdotp_vars%perturbation, RESTART_DIR, &
        kdotp_rho_tag(idir), kdotp_wfs_tag(idir), have_restart_rho=(ierr==0))
      kdotp_vars%ok = kdotp_vars%ok .and. sternheimer_has_converged(sh)         
    end do ! idir

    ! calculate dipole
    write(6, '(a)')
    call zcalc_dipole_periodic(sys, kdotp_vars%lr, elec_dipole(1:NDIM))
    call geometry_dipole(sys%geo, ion_dipole(1:NDIM))
    call io_output_dipole(6, elec_dipole(1:NDIM) + ion_dipole(1:NDIM), NDIM)
    write(6, '(a)') 'Defined up to quantum of polarization.'
    ! quantum of polarization = any lattice vector / cell volume
    ! quantum of dipole = any lattice vector
    write(6, '(a)')

    ! calculate effective masses
    if (calc_eff_mass) then
      message(1) = "Info: Calculating effective masses."
      call write_info(1)

      call zcalc_eff_mass_inv(sys, h, kdotp_vars%lr, kdotp_vars%perturbation, &
        kdotp_vars%eff_mass_inv, kdotp_vars%occ_solution_method, kdotp_vars%degen_thres)
      call kdotp_output(sys%st, sys%gr, kdotp_vars)
    endif

    ! calculate polarizability
    if (calc_pol) then
      ALLOCATE(em_lr(1:NDIM, 1:em_nsigma, 1:em_nfactor), NDIM * em_nsigma * em_nfactor)

      ! load em_resp wavefunctions
      do idir = 1, NDIM
        do ifactor = 1, em_nfactor
          do isigma = 1, em_nsigma
            call lr_init(em_lr(idir, isigma, ifactor))
            call lr_allocate(em_lr(idir, isigma, ifactor), sys%st, sys%gr%m)

            str_tmp = em_wfs_tag(idir, ifactor)
            write(dirname,'(3a, i1)') EM_RESTART_DIR, trim(str_tmp), '_', isigma
            call restart_read(trim(tmpdir)//dirname, sys%st, sys%gr, sys%geo, &
              ierr, lr=em_lr(idir, isigma, ifactor))
         
            if(ierr .ne. 0) then
              message(1) = "Could not load electric response wave-functions from '"//trim(tmpdir)//dirname//"'"
              call write_warning(1)
            end if
          enddo
        enddo
      enddo

      message(1) = "Info: Calculating polarizabilities."
      call write_info(1)

      do ifactor = 1, em_nfactor
        write(dirname, '(a, a)') 'linear_kdotp/'
        call io_mkdir(trim(dirname))

        call zcalc_polarizability_periodic(sys, em_lr(:, :, ifactor), kdotp_vars%lr(:, 1), em_nsigma, &
          alpha(:, :, ifactor))
!        omega = em_vars%freq_factor(ifactor)*em_vars%omega(iomega)
        call out_polarizability(sys%st, sys%gr, alpha(:, :, ifactor), &
          M_ZERO, .true., dirname)
        ! FIX ME: the frequency needs to be supplied here to calculate cross-section
      enddo

      if (calc_hyperpol) then
         ! Now do kdotp perturbation of electric responses, if requested
         message(1) = "Info: Calculating kdotp linear response of electric LR wavefunctions."
         call write_info(1)
      endif ! calc_hyperpol

      do idir = 1, NDIM
        do isigma = 1, em_nsigma
          do ifactor = 1, em_nfactor
            call lr_dealloc(em_lr(idir, isigma, ifactor))
          end do
        end do
      end do

      deallocate(em_lr)
    endif ! calc_pol

    ! clean up some things
    do idir = 1, NDIM
      call lr_dealloc(kdotp_vars%lr(idir, 1))
    end do

    call sternheimer_end(sh)
    call pert_end(kdotp_vars%perturbation)

    deallocate(kdotp_vars%lr)
    call states_deallocate_wfns(sys%st)
    deallocate(kdotp_vars%eff_mass_inv)

    call pop_sub()

  contains

    ! ---------------------------------------------------------

    subroutine parse_input()

      type(block_t) blk

      call push_sub('kdotp.kdotp_lr_run.parse_input')

      !%Variable KdotP_OccupiedSolutionMethod
      !%Type integer
      !%Default sternheimer
      !%Section Linear Response::KdotP
      !%Description
      !% Method of calculating the contribution of the projection of the
      !%  linear-response wavefunctions in the occupied subspace.
      !%Option sternheimer_eqn 0
      !% The Sternheimer equation is solved including the occupied subspace,
      !% to get the full linear-response wavefunctions.
      !%Option sum_over_states 1
      !% The Sternheimer equation is solved only in the unoccupied subspace,
      !% and a sum-over-states perturbation-theory expression is used to
      !% evaluate the contributions in the occupied subspace.
      !%End      

      call loct_parse_int(check_inp('KdotP_OccupiedSolutionMethod'), &
        0, kdotp_vars%occ_solution_method)

      call loct_parse_float(check_inp('DegeneracyThreshold'), &
        CNST(1e-5), kdotp_vars%degen_thres)
      ! Note: this variable is defined in src/states.F90, in states_degeneracy_matrix

      !%Variable KdotP_Eta
      !%Type float
      !%Default 0.0
      !%Section Linear Response::KdotP
      !%Description
      !% Imaginary frequency added to Sternheimer equation which may improve convergence.
      !%End

      call loct_parse_float(check_inp('KdotP_Eta'), M_ZERO, kdotp_vars%eta)
      kdotp_vars%eta = kdotp_vars%eta*units_inp%energy%factor

      !%Variable KdotP_Initialization
      !%Type integer
      !%Default zero
      !%Section Linear Response::KdotP
      !%Description
      !% Initial values assigned to linear-response wavefunctions. Only used if
      !% FromScratch = yes, since otherwise initial values are read from restart directory.
      !%Option zero 0
      !% The initial values are zero.
      !%Option nondispersive 1
      !% The initial values are the exact solutions in the limit of no dispersion, i.e. 
      !% non-interacting unit cells: |u_i(1)> = -i r_i |u(0)>
      !%End

      call loct_parse_int(check_inp('KdotP_Initialization'), 0, kdotp_vars%initialization)

      !%Variable KdotP_CalculatePolarizabilities
      !%Type logical
      !%Default false
      !%Section Linear Response::KdotP
      !%Description
      !% If true, reads wavefunctions from previous em_resp run,
      !% calculates their kdotp perturbations, and uses them to
      !% calculate polarizability and hyperpolarizability.
      !%End      

      call loct_parse_logical(check_inp('KdotP_CalculatePolarizabilities'), &
        .false., calc_pol)

      !%Variable KdotP_CalculateEffectiveMasses
      !%Type logical
      !%Default false
      !%Section Linear Response::KdotP
      !%Description
      !% If true, uses kdotp perturbations of ground-state wavefunctions
      !% to calculate effective masses.
      !%End      

      call loct_parse_logical(check_inp('KdotP_CalculateEffectiveMasses'), &
        .false., calc_eff_mass)

      if (loct_parse_block(check_inp('EMHyperpol'), blk) == 0) then
        calc_hyperpol = .true.
        em_nfactor = 3

        if (loct_parse_block(check_inp('EMFreqs'), blk) == 0) then
          em_nsigma = 2
        else ! omega = 0, static case
          em_nsigma = 1  
        endif

      else
        calc_hyperpol = .false.
        em_nfactor = 1
        em_nsigma = 1
      endif

      call pop_sub()

   end subroutine parse_input

    ! ---------------------------------------------------------
    subroutine info()

      call push_sub('kdotp.kdotp_lr_run.info')

      call pert_info(kdotp_vars%perturbation, stdout)

      write(message(1),'(a)') 'Effective masses'
      call messages_print_stress(stdout, trim(message(1)))

      if (kdotp_vars%occ_solution_method == 0) then
        message(1) = 'Occupied solution method: Sternheimer equation'
      else
        message(1) = 'Occupied solution method: sum over states'
      endif

      if (.not. fromScratch) then
        message(2) = 'KdotP initialization: restart wavefunctions'
      else if (kdotp_vars%initialization == 0) then
        message(2) = 'KdotP initialization: zero'
      else
        message(2) = 'KdotP initialization: non-dispersive solutions'
      endif

      call write_info(2)

      call messages_print_stress(stdout)
      
      call pop_sub()

    end subroutine info

  end subroutine kdotp_lr_run

  ! ---------------------------------------------------------
  subroutine kdotp_output(st, gr, kdotp_vars)
    type(states_t),       intent(inout) :: st
    type(grid_t),         intent(inout) :: gr
    type(kdotp_t),        intent(inout) :: kdotp_vars

    character(len=80) :: filename, tmp
    integer :: iunit, ik, ist, ist2, ik2, ispin
    FLOAT :: determinant

    call push_sub('kdotp.kdotp_output')

    call messages_print_stress(stdout, 'Degenerate subspaces')

    do ik = 1, st%d%nik
      ! figure out the actual spin and k-point
      ! this is not as elegant as using mod and int, but much easier to understand
      if (st%d%nspin == 1) then
        ispin = 1
        ik2 = ik
      else
        if (mod(ik, 2) == 1) then
           ispin = 1
           ik2 = (ik + 1) / 2
        else
           ispin = 2
           ik2 = ik / 2
        endif
      endif

      tmp = int2str(ik2)
      write(*, '(3a, i1)') 'k-point ', trim(tmp), ', spin ', ispin 

      ist = 1
      do while (ist <= st%nst)
      ! test for degeneracies
         write(*,'(a)') '===='
         tmp = int2str(ist)
         write(*,'(a, a, a, f12.8, a, a)') 'State #', trim(tmp), ', Energy = ', &
           st%eigenval(ist, ik)/units_out%energy%factor, ' ', units_out%energy%abbrev
         
         ist2 = ist + 1
         do while (ist2 <= st%nst .and. &
           abs(st%eigenval(ist2, ik) - st%eigenval(ist, ik)) < kdotp_vars%degen_thres)
           ! eigenvalues are supposed to be in ascending order; if they are not, it is a sign
           ! of being in a degenerate subspace?
           ! write(*,*) ist2, ist, sys%st%eigenval(ist2, ik) - sys%st%eigenval(ist, ik)
            tmp = int2str(ist2)
            write(*,'(a, a, a, f12.8, a, a)') 'State #', trim(tmp), ', Energy = ', &
              st%eigenval(ist2, ik)/units_out%energy%factor, ' ', units_out%energy%abbrev
            ist2 = ist2 + 1
         enddo

         ist = ist2
      enddo
      write(*,*)

      tmp = int2str(ik2)
      write(filename, '(3a, i1)') 'kdotp/kpoint_', trim(tmp), '_', ispin
      iunit = io_open(trim(filename), action='write')
      write(iunit,'(a, i10)') '# spin    index = ', ispin
      write(iunit,'(a, i10)') '# k-point index = ', ik2
      write(iunit,'(a, 3f12.8)') '# k-point coordinates = ', st%d%kpoints(1:MAX_DIM, ik)
      if (.not. kdotp_vars%ok) write(iunit, '(a)') "# WARNING: not converged"      
      
      write(iunit,'(a)')
      write(iunit,'(a)') '# Inverse effective mass tensors'
      do ist = 1, st%nst
        write(iunit,'(a)')
        tmp = int2str(ist)
        write(iunit,'(a, a, a, f12.8, a, a)') 'State #', trim(tmp), ', Energy = ', &
          st%eigenval(ist, ik)/units_out%energy%factor, ' ', units_out%energy%abbrev
        call io_output_tensor(iunit, kdotp_vars%eff_mass_inv(ik, ist, :, :), NDIM, M_ONE)
      enddo
      
      write(iunit,'(a)')
      write(iunit,'(a)') '# Effective mass tensors'
      do ist = 1, st%nst
        write(iunit,'(a)')
        tmp = int2str(ist)
        write(iunit,'(a, a, a, f12.8, a, a)') 'State #', trim(tmp), ', Energy = ', &
          st%eigenval(ist, ik)/units_out%energy%factor, ' ', units_out%energy%abbrev
        determinant = lalg_inverter(gr%sb%dim, kdotp_vars%eff_mass_inv(ik, ist, :, :), .true.)
        call io_output_tensor(iunit, kdotp_vars%eff_mass_inv(ik, ist, :, :), NDIM, M_ONE)
      enddo

    enddo

    call pop_sub()

  end subroutine kdotp_output

  character(len=12) function int2str(i) result(str)
    integer, intent(in) :: i
    
    call push_sub('kdotp.int2str')

    write(str, '(i11)') i
    str = trim(adjustl(str))

    call pop_sub()
    
  end function int2str
            
end module kdotp_m

!! Local Variables:
!! mode: f90
!! coding: utf-8
!! End:
