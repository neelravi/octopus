

!! Copyright (C) 2004 Xavier Andrade, Eugene S. Kadantsev (ekadants@mjs1.phy.queensu.ca)
!!
!! This program is free software; you can redistribute it and/or modify
!! it under the terms of the GNU General Public License as published by
!! the Free Software Foundation; either version 2, or (at your option)
!! any later version.
!!
!! This program is distributed in the hope that it will be useful,
!! but WITHOUT ANY WARRANTY; without even the implied warranty of
!! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!! GNU General Public License for more details.
!!
!! You should have received a copy of the GNU General Public License
!! along with this program; if not, write to the Free Software
!! Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
!! 02111-1307, USA.
!!
!! -*- coding: utf-8 mode: f90 -*-
!! $Id$

#include "global.h"
#define RESTART_DIR "restart_pol_lr/"

module static_pol_lr_m
  use global_m
  use messages_m
  use units_m
  use mesh_m
  use mesh_function_m
  use system_m
  use restart_m
  use hamiltonian_m
  use mix_m
  use poisson_m
  use linear_response_m
  use io_m
  use lib_oct_parser_m
  use math_m
  use string_m

  implicit none

  private
  public :: &
    static_pol_lr_run
  
  type pol_props_t
    logical :: add_fxc
    logical :: add_hartree
    logical :: from_scratch
    logical :: calc_hyperpol
    logical :: orth_response
  end type pol_props_t

  type status_t
    logical :: ok
  end type status_t
  
contains

  ! ---------------------------------------------------------
  subroutine static_pol_lr_run(sys, h, fromScratch)
    type(system_t), target, intent(inout) :: sys
    type(hamiltonian_t),    intent(inout) :: h
    logical,                intent(inout) :: fromScratch

    type(lr_t), allocatable :: lr(:,:,:) ! lr(NDIM,NS,NFREQ)

    type(grid_t),   pointer :: gr

    type(status_t)          :: status

    CMPLX :: alpha(1:MAX_DIM, 1:MAX_DIM, 1:3)
    CMPLX :: beta(1:MAX_DIM, 1:MAX_DIM, 1:MAX_DIM)

    FLOAT :: eta, freq_factor(0:MAX_DIM) !starts from 0 to prevent a segfault

    integer :: nsigma, sigma, ndim, i, j, k, nomega, dir, ierr, iomega, ifactor, nfactor

    character(len=80) :: fname, dirname

    type(pol_props_t) :: props

    FLOAT, allocatable :: omega(:)

    logical :: complex_response


    call push_sub('em_resp.static_pol_lr_run')

    gr => sys%gr
    ndim = sys%gr%sb%dim

    props%from_scratch = fromScratch

    call parse_input()
    nfactor = 1

    if(props%calc_hyperpol) nfactor=3

    nsigma = 2  ! positive and negative values of the frequency must be considered

    complex_response = (eta /= M_ZERO ) .or. wfs_are_complex(sys%st)

    ALLOCATE(lr(1:ndim, 1:nsigma, 1:nfactor), ndim*nsigma*nfactor)

    call read_wfs()

    ! setup Hamiltonian
    message(1) = 'Info: Setting up Hamiltonian for linear response'
    call write_info(1)

    call system_h_setup(sys, h)

    do dir = 1, ndim
      do sigma = 1, nsigma
        do ifactor = 1, nfactor 

          if (wfs_are_complex(sys%st)) then 
            call lr_init(lr(dir, sigma, ifactor), "Pol", def_solver=LR_BICGSTAB)
          else
            call lr_init(lr(dir, sigma, ifactor), "Pol", def_solver=LR_CG)            
          end if

          call lr_alloc_fHxc (sys%st, gr%m, lr(dir, sigma, ifactor))

          if(wfs_are_real(sys%st)) then
            ierr = dlr_alloc_psi(sys%st, gr%m, lr(dir, sigma, ifactor))
            lr(dir, sigma, ifactor)%ddl_rho = M_ZERO
          else
            ierr = zlr_alloc_psi(sys%st, gr%m, lr(dir, sigma, ifactor))
            lr(dir, sigma, ifactor)%zdl_rho = M_ZERO
          end if

          if(props%add_fxc) then 
            call lr_build_fxc(gr%m, sys%st, sys%ks%xc, lr(dir, sigma, ifactor)%dl_Vxc)
          else 
            lr(dir, sigma, ifactor)%dl_Vxc=M_ZERO
          end if

        end do
      end do
    end do


    if(.not.fromScratch) then
      ! load wave-functions
      do dir = 1, ndim
        do sigma = 1, nsigma
          do ifactor = 1, nfactor

            write(dirname,'(a,i1,a,i1, a, i1)') RESTART_DIR//"wfs", dir, "_", ifactor, "_", sigma
            call restart_read(trim(tmpdir)//dirname, sys%st, sys%gr, sys%geo, ierr, lr=lr(dir, sigma, ifactor))
            if(ierr.ne.0) then
              message(1) = "Could not load response wave-functions from '"//trim(tmpdir)//dirname
              call write_warning(1)
            end if

          end do
        end do
      end do
    end if

    call io_mkdir(trim(tmpdir)//RESTART_DIR)

    call info()

    message(1) = "Info: Calculating polarizabilities."
    call write_info(1)
    
    call output_init()

    do iomega = 1, nomega

      do ifactor = 1, nfactor

        do dir = 1, sys%gr%sb%dim

          write(message(1), '(a,i1,a,f5.3)') 'Info: Calculating response for direction ', dir, &
               ' and frequency ', freq_factor(ifactor)*omega(iomega)/units_out%energy%factor
          call write_info(1)

          if( ifactor > 1 .and. freq_factor(ifactor) ==  freq_factor(ifactor-1) ) then 

            !if the previous frequency is the same, save work
            call lr_copy(lr(dir, 1, ifactor-1), lr(dir, 1, ifactor))
            call lr_copy(lr(dir, 2, ifactor-1), lr(dir, 2, ifactor))

          else
            if (wfs_are_complex(sys%st)) then 
              call zget_response_e(sys, h, lr(:, :, ifactor), dir, ifactor, 2 , &
                   freq_factor(ifactor)*omega(iomega) + M_zI * eta, props, status)
            else
              call dget_response_e(sys, h, lr(:, :, ifactor), dir, ifactor, 2 , &
                   freq_factor(ifactor)*omega(iomega), props, status)
            end if
          end if
        end do ! dir

      end do ! ifactor

      !calculate polarizability
      do ifactor = 1, nfactor

        if(wfs_are_complex(sys%st)) then 
          call zlr_calc_polarizability(sys, lr(:, :, ifactor), alpha(:,:, ifactor))
        else
          call dlr_calc_polarizability(sys, lr(:, :, ifactor), alpha(:,:, ifactor))
        end if

      end do

      !calculate hyperpolarizability
      if(props%calc_hyperpol) then 

        if(wfs_are_complex(sys%st)) then 
          call zlr_calc_beta(sys, lr(:, :, :), props, beta)
        else
          call dlr_calc_beta(sys, lr(:, :, :), props, beta)
        end if

      end if

      call output()

    end do ! nomega

    do dir = 1, ndim
      do sigma = 1, nsigma
        do ifactor = 1, nfactor
          call lr_dealloc(lr(dir, sigma, ifactor))
        end do
      end do
    end do

    deallocate(omega)
    deallocate(lr)

    call states_deallocate_wfns(sys%st)
    call pop_sub()

  contains

    ! ---------------------------------------------------------
    subroutine parse_input()
      C_POINTER :: blk
      integer   :: nrow
      integer   :: number, j, k, ham_var
      FLOAT     :: omega_ini, omega_fin, domega
      logical   :: static

      call push_sub('em_resp.parse_input')

      !%Variable PolOrthResponse
      !%Type logical
      !%Default false
      !%Section Linear Response::Polarizabilities
      !%Description
      !% Wheter variations should be orthogonalized or not against the
      !% occupied states.
      !%End

      call loct_parse_logical(check_inp('PolOrthResponse'), .true., props%orth_response)

      !%Variable PolFreqs
      !%Type block
      !%Section Linear Response::Polarizabilities
      !%Description
      !% This block defines for which frequencies the polarizabilities
      !% will be calculated. If is not present the static (omega = 0) response
      !% is calculated.
      !%
      !% Each row of the block indicates a sequence of frequency values, the
      !% first column is an integer that indicates the number of steps, the
      !% second number is the initial frequency, and the third number the final
      !% frequency. If the first number is one, then only the initial value is
      !% considered. The block can have any number of rows. Consider the next example:
      !%
      !% <tt>%PolFreqs
      !% <br>31 | 0.0 | 1.0
      !% <br> 1 | 0.32
      !% <br>%</tt>
      !%
      !%End

      if (loct_parse_block(check_inp('PolFreqs'), blk) == 0) then 

        nrow = loct_parse_block_n(blk)
        nomega = 0

        !count the number of frequencies
        do i= 0, nrow-1
          call loct_parse_block_int(blk, i, 0, number)
          nomega = nomega + number
        end do

        ALLOCATE(omega(1:nomega), nomega)

        !read frequencies
        j = 1
        do i = 0, nrow-1
          call loct_parse_block_int(blk, i, 0, number)
          call loct_parse_block_float(blk, i, 1, omega_ini)
          if(number > 1) then 
            call loct_parse_block_float(blk, i, 2, omega_fin)
            domega = (omega_fin - omega_ini)/(number - M_ONE)
            do k = 0, number-1
              omega(j + k) = (omega_ini + domega*k) * units_inp%energy%factor
            end do
            j = j + number
          else
            omega(j) = omega_ini * units_inp%energy%factor
            j = j + 1
          end if
        end do

        call loct_parse_block_end(blk)

        call sort(omega)

      else
        !there is no frequency block, we calculate response for w=0.0
        nomega = 1
        ALLOCATE(omega(1:nomega), nomega)
        omega(1)=M_ZERO
      end if

      !%Variable PolEta
      !%Type float
      !%Default 0.0
      !%Section Linear Response::Polarizabilities
      !%Description
      !% Imaginary part of the frequency.
      !%End

      call loct_parse_float(check_inp('PolEta'), M_ZERO, eta)
      eta = eta * units_inp%energy%factor

      !%Variable PolHamiltonianVariation
      !%Type integer
      !%Default hartree+fxc
      !%Section Linear Response::Polarizabilities
      !%Description
      !% The terms are considered in the variation of the
      !% hamiltonian. V_ext is always considered. The default is to include
      !% the fxc and hartree terms. If you want to do RPA only include
      !% hartree.
      !%Option hartree 1 
      !% The variation of the hartree potential.
      !%Option fxc 2
      !% The exchange and correlation kernel, the variation of the
      !% exchange and correlation potential.
      !%End

      if(.not. h%ip_app) then 
        call loct_parse_int(check_inp('PolHamiltonianVariation'), 3, ham_var)    
        props%add_fxc = ((ham_var/2) == 1)
        props%add_hartree = (mod(ham_var, 2) == 1)
      else
        props%add_fxc = .false. 
        props%add_hartree = .false.
      end if

      !%Variable PolHyper
      !%Type float
      !%Default 0.0
      !%Section Linear Response::Polarizabilities
      !%Description
      !% The terms are considered in the variation of the
      !% hamiltonian. V_ext is always considered. The default is to include
      !% the fxc and hartree terms. If you want to do RPA only include
      !% hartree.
      !%Option shg 1.0
      !% Second harmonic generation 1 1 -2
      !%Option or -1.0
      !% Optical recitifcation, 1 -1 0
      !%End

      if (loct_parse_block(check_inp('PolHyper'), blk) == 0) then 

        call loct_parse_block_float(blk, 0, 0, freq_factor(1))
        call loct_parse_block_float(blk, 0, 1, freq_factor(2))
        call loct_parse_block_float(blk, 0, 2, freq_factor(3))

        call loct_parse_block_end(blk)

        props%calc_hyperpol = .true.

      else

        props%calc_hyperpol = .false.
        freq_factor(1:MAX_DIM)=M_ONE

      end if

      call pop_sub()

    end subroutine parse_input


    ! ---------------------------------------------------------
    subroutine read_wfs()    
      integer :: kpoints, nst, ierr, dim

      !check how many wfs we have

      call push_sub('em_resp.parse_input')

      call restart_look(trim(tmpdir)//'restart_gs', sys%gr%m, kpoints, dim, nst, ierr)

      if(ierr.ne.0) then
        message(1) = 'Could not properly read wave-functions from "'//trim(tmpdir)//'restart_gs".'
        call write_fatal(1)
      end if

      do sigma=1,nsigma
        do dir=1,NDIM
          do ifactor = 1, nfactor
            lr(dir, sigma, ifactor)%nst =sys%st%nst
          end do
        end do
      end do

      sys%st%nst    = nst
      sys%st%st_end = nst
      deallocate(sys%st%eigenval, sys%st%occ)

      if ( complex_response ) then 
        call states_allocate_wfns(sys%st, gr%m, M_CMPLX)
      else 
        call states_allocate_wfns(sys%st, gr%m, M_REAL)
      end if

      ALLOCATE(sys%st%eigenval(sys%st%nst, sys%st%d%nik), sys%st%nst*sys%st%d%nik)
      ALLOCATE(sys%st%occ(sys%st%nst, sys%st%d%nik), sys%st%nst*sys%st%d%nik)

      if(sys%st%d%ispin == SPINORS) then
        ALLOCATE(sys%st%mag(sys%st%nst, sys%st%d%nik, 2), sys%st%nst*sys%st%d%nik*2)
        sys%st%mag = M_ZERO
      end if
      sys%st%eigenval = huge(PRECISION)
      sys%st%occ      = M_ZERO

      ! load wave-functions
      call restart_read(trim(tmpdir)//'restart_gs', sys%st, sys%gr, sys%geo, ierr)  
      if(ierr.ne.0) then
        message(1) = "Could not read KS orbitals from '"//trim(tmpdir)//"restart_gs'"
        message(2) = "Please run a calculation of the ground state first!"
        call write_fatal(2)
      end if

      call pop_sub()

    end subroutine read_wfs


    ! ---------------------------------------------------------

    subroutine info()

      write(message(1),'(a)') 'Linear Reponse Polarizabilities'
      call messages_print_stress(stdout, trim(message(1)))

      if (wfs_are_real(sys%st)) then 
        message(1) = 'Wavefunctions type: Complex'
      else
        message(1) = 'Wavefunctions type: Real'
      end if
      call write_info(1)

      if (props%add_hartree .and. props%add_fxc) then 
        message(1)='Hamiltonian variation: V_ext + hartree + fxc'
      else
        message(1)='Hamiltonian variation: V_ext'
        if (props%add_fxc) message(1)='Hamiltonian variation: V_ext + fxc'
        if (props%add_hartree) message(1)='Hamiltonian variation: V_ext + hartree'
      end if
      call write_info(1)

      write(message(1),'(a,i3,a)') 'Calculating polarizability tensor for ', nomega, ' frequencies.'

      call write_info(1)

      call messages_print_stress(stdout)

    end subroutine info

    subroutine output_init()

      call io_mkdir('linear/')

    end subroutine output_init

    subroutine cross_section_header(out_file)
      integer, intent(in) :: out_file
      character(len=80) :: header_string

      !this header is the same from sprectrum.F90
      write(out_file, '(a1, a20)', advance = 'no') '#', str_center("Energy", 20)
      write(out_file, '(a20)', advance = 'no') str_center("(1/3)*Tr[sigma]", 20)
      write(out_file, '(a20)', advance = 'no') str_center("Anisotropy[sigma]", 20)
      
      do i = 1, 3
        do k = 1, 3
          write(header_string,'(a6,i1,a1,i1,a1)') 'sigma(',i,',',k,')'
          write(out_file, '(a20)', advance = 'no') str_center(trim(header_string), 20)
        end do
      end do
      
      write(out_file, *)
      write(out_file, '(a1,a20)', advance = 'no') '#', str_center('['//trim(units_out%energy%abbrev) // ']', 20)
      do i = 1, 11
        write(out_file, '(a20)', advance = 'no')  str_center('['//trim(units_out%length%abbrev) //'^2]', 20)
      end do
      write(out_file,*)
    end subroutine cross_section_header

    subroutine output()
      FLOAT :: cross(MAX_DIM, MAX_DIM), crossp(MAX_DIM, MAX_DIM)
      FLOAT :: average, anisotropy, bpar(1:MAX_DIM), bper(1:MAX_DIM) 
      integer :: iunit, ist, ivar, ik, sigma
      CMPLX   :: tr_beta, proj
      FLOAT   :: msp

      !CREATE THE DIRECTORY FOR EACH FREQUENCY
      do ifactor = 1, nfactor

        write(dirname, '(a, f5.3)') 'linear/freq_', freq_factor(ifactor)*omega(iomega)/units_out%energy%factor
        call io_mkdir(trim(dirname))


        !OUTPUT POLARIZABILITY
        iunit = io_open(trim(dirname)//'/alpha', action='write')

        write(iunit, '(2a)', advance='no') '# Polarizability tensor [', &
             trim(units_out%length%abbrev)
        if(NDIM.ne.1) write(iunit, '(a,i1)', advance='no') '^', NDIM
        write(iunit, '(a)') ']'


        msp = M_ZERO
        do j = 1, NDIM
          write(iunit, '(3f12.6)') real(alpha(j, 1:NDIM, ifactor)) / units_out%length%factor**NDIM
          msp = msp + real(alpha(j, j, ifactor))
        end do
        msp = msp / M_THREE

        write(iunit, '(a, f12.6)')  'Mean static polarizability', msp &
             / units_out%length%factor**NDIM

        call io_close(iunit)

        !CROSS SECTION (THE COMPLEX PART OF POLARIZABILITY)
        cross(1:MAX_DIM, 1:MAX_DIM) = aimag(alpha(1:MAX_DIM, 1:MAX_DIM, ifactor)) * &
             omega(iomega)/units_out%energy%factor * M_FOUR * M_PI / P_c 

        iunit = io_open(trim(dirname)//'/cross_section', action='write')
        average = M_THIRD* ( cross(1, 1) + cross(2, 2) + cross(3, 3) )
        crossp(:, :) = matmul(cross(:, :),cross(:, :))
        anisotropy =  M_THIRD * ( M_THREE * (crossp(1, 1) + crossp(2, 2) + crossp(3, 3)) - &
             (cross(1, 1) + cross(2, 2) + cross(3, 3))**2 )

        call cross_section_header(iunit)
        write(iunit,'(3e20.8)', advance = 'no') omega(iomega) / units_out%energy%factor, &
             average , sqrt(max(anisotropy, M_ZERO)) 
        write(iunit,'(9e20.8)', advance = 'no') cross(1:3, 1:3)
        write(iunit,'(a)', advance = 'yes')
        call io_close(iunit)


        !PROJECTIONS
        do ik = 1, sys%st%d%nspin

          do dir = 1, NDIM

            write(fname, '(2a,i1,a,i1)') trim(dirname), '/projection-', ik, '-', dir
            iunit = io_open(trim(fname), action='write')

            write(iunit, '(a)', advance='no') '# state '
            do ivar = 1, lr(dir, 1, 1)%nst
              do sigma=1,nsigma

                if( sigma == nsigma .and. ivar == lr(dir, 1, 1)%nst) then 
                  write(iunit, '(i3)', advance='yes') (3-2*sigma)*ivar
                else 
                  write(iunit, '(i3)', advance='no') (3-2*sigma)*ivar
                end if

              end do

            end do

            do ist = 1, sys%st%nst
              write(iunit, '(i3)', advance='no') ist

              do ivar = 1, lr(dir, 1, 1)%nst
                do sigma=1,nsigma

                  if(wfs_are_complex(sys%st)) then
                    proj=zstates_dotp(sys%gr%m, sys%st%d%dim, &
                         sys%st%zpsi(:,:, ist, ik), &
                         lr(dir, sigma, ifactor)%zdl_psi(:,:, ivar, ik))
                  else
                    proj=dstates_dotp(sys%gr%m, sys%st%d%dim, &
                         sys%st%dpsi(:,:, ist, ik), &
                         lr(dir, sigma, ifactor)%ddl_psi(:,:, ivar, ik))
                  end if

                  if( sigma == nsigma .and. ivar == lr(dir, 1, 1)%nst) then 
                    write(iunit, '(f12.6)', advance='yes') abs(proj)
                  else 
                    write(iunit, '(f12.6,a)', advance='no') abs(proj), ' '
                  end if

                end do
              end do

            end do

            call io_close(iunit)

          end do ! dir
        end do !ik

        !WRITE FUNCTIONS
        do dir = 1, NDIM

          if( wfs_are_complex(sys%st) ) then 

            if(NDIM==3) then
              if(iand(sys%outp%what, output_elf).ne.0) &
                   call zlr_calc_elf(sys%st,sys%gr, lr(dir, 1, ifactor), lr(dir, 2, ifactor))
            end if
            call zlr_output(sys%st, sys%gr, lr(dir, 1, ifactor), dirname, dir, sys%outp)
            
          else

            if(NDIM==3) then
              if(iand(sys%outp%what, output_elf).ne.0) &
                   call dlr_calc_elf(sys%st,sys%gr, lr(dir, 1, ifactor), lr(dir, 2, ifactor))
            end if
            call dlr_output(sys%st, sys%gr, lr(dir, 1, ifactor), dirname, dir, sys%outp)

          end if
        end do

      end do

      !HYPERPOLARIZABILITY
      if(props%calc_hyperpol) then

        iunit = io_open('linear/beta', action='write', position='append' )
        if(status%ok) then           
          write(iunit, '(7f12.6)') omega(iomega), &
               real(beta(1,1,1)), aimag(beta(1,1,1)), &
               real(beta(2,2,2)), aimag(beta(2,2,2)), &
               real(beta(3,3,3)), aimag(beta(3,3,3))
        else
          write(iunit, '(a,f12.6)') '#calculation did not converge for frequency ', omega(iomega)
        end if

        call io_close(iunit)

        write(dirname, '(a, f5.3)') 'linear/freq_', omega(iomega)/units_out%energy%factor

        call io_mkdir(dirname)

        ! Output first hyperpolarizabilty (beta)
        iunit = io_open(trim(dirname)//'/beta', action='write')

        write(iunit, '(2a)', advance='no') '#hyperpolarizability tensor [', &
             trim(units_out%length%abbrev)
        if(NDIM.ne.1) write(iunit, '(a,i1)', advance='no') '^', NDIM+2
        write(iunit, '(a)') ']'

        if (sys%st%d%nspin /= UNPOLARIZED ) then 
          write(iunit, '(a)') 'WARNING: Hyperpolarizability has not been tested for spin polarized systems'
        end if

        do i = 1, NDIM
          do j = 1, NDIM
            do k = 1, NDIM
              write(iunit,'(3i2,e20.8,e20.8)') i, j, k, &
                   real(beta(i, j, k))/units_out%length%factor**(5), aimag(beta(i, j, k))/units_out%length%factor**(5)
            end do
          end do
        end do

        if (NDIM == 3) then 

          bpar = M_ZERO
          do i = 1, NDIM
            do j = 1, NDIM
              bpar(i) = bpar(i) + beta(i, j, j) + beta(j, i, j) + beta(j, j, i)
              bper(i) = bper(i) + M_TWO*beta(i, j, j) - M_THREE*beta(j, i, j) + M_TWO*beta(j, j, i)
            end do
          end do

          bpar = bpar / (M_FIVE * units_out%length%factor**(NDIM+2))
          bper = bper / (M_FIVE * units_out%length%factor**(NDIM+2))

          write(iunit, '(a, 3f12.6)') 'beta parallel     ', bpar(1:NDIM)
          write(iunit, '(a, 3f12.6)') 'beta perpendicular', bper(1:NDIM)
          write(iunit, '(a, 3f12.6)') 'beta K            ', M_THREE*M_HALF*(bpar(1:NDIM) - bper(1:NDIM))

        endif

        call io_close(iunit)

      end if


    end subroutine output

  end subroutine static_pol_lr_run

  subroutine lr_calc_current(st, gr, lr, lr_m)
    type(states_t),   intent(inout) :: st
    type(grid_t),     intent(inout) :: gr
    type(lr_t),       intent(inout) :: lr
    type(lr_t), optional, intent(inout) :: lr_m

    integer :: k, ist, ispin, idim, ndim, np

    CMPLX, allocatable :: gpsi(:,:), gdl_psi(:,:), gdl_psi_m(:,:)

    call push_sub('em_resp.lr_calc_current')
  
    if(.not. associated(lr%dl_j)) ALLOCATE(lr%dl_j(gr%m%np, MAX_DIM, st%d%nspin), gr%m%np*MAX_DIM*st%d%nspin)

    np = NP
    ndim = NDIM

    ALLOCATE(   gpsi(1:np, 1:ndim), np*ndim)
    ALLOCATE(gdl_psi(1:np, 1:ndim), np*ndim)
    if(present(lr_m)) ALLOCATE(gdl_psi_m(1:np, 1:ndim), np*ndim)

    lr%dl_j = M_ZERO

    do ispin = 1, st%d%nspin
      do ist = 1, st%nst
        do idim = 1, st%d%dim

          call zf_gradient(gr%sb, gr%f_der, lr%zdl_psi(:, idim, ist, ispin), gdl_psi)
          call zf_gradient(gr%sb, gr%f_der, st%zpsi(:, idim, ist, ispin), gpsi)

          if(present(lr_m)) then               

            call zf_gradient(gr%sb, gr%f_der, lr_m%zdl_psi(:, idim, ist, ispin), gdl_psi_m)

            do k = 1, NDIM 

              lr%dl_j(1:np,k,ispin) = lr%dl_j(1:np, k, ispin) + (           &
                   + conjg(st%zpsi(1:np, idim, ist, ispin)) *       gdl_psi(1:np,k)   &
                   -       st%zpsi(1:np, idim, ist, ispin) * conjg(gdl_psi_m(1:np,k))  &
                   + conjg(lr_m%zdl_psi(1:np, idim, ist, ispin)) *     gpsi(1:np,k)   & 
                   -       lr%zdl_psi(1:np, idim, ist, ispin)  * conjg(gpsi(1:np,k))  &
                   )/(M_TWO*M_zI)
            end do

          else 

            do k = 1, NDIM 

              lr%dl_j(1:np,k,ispin) = lr%dl_j(1:np, k, ispin) + (           &
                   + conjg(st%zpsi(1:np, idim, ist, ispin)) *       gdl_psi(1:np,k)   &
                   -       st%zpsi(1:np, idim, ist, ispin)  * conjg(gdl_psi(1:np,k))  &
                   + conjg(lr%zdl_psi(1:np, idim, ist, ispin)) *       gpsi(1:np,k)   & 
                   -       lr%zdl_psi(1:np, idim, ist, ispin)  * conjg(gpsi(1:np,k))  &
                   )/(M_TWO*M_zI)

            end do

          end if

        end do
      end do
    end do

    deallocate(gpsi)
    deallocate(gdl_psi)
    if(present(lr_m)) deallocate(gdl_psi_m)

    call pop_sub()

  end subroutine lr_calc_current


#include "undef.F90"
#include "complex.F90"

#include "em_resp_inc.F90"

#include "undef.F90"
#include "real.F90"
#include "em_resp_inc.F90"

end module static_pol_lr_m
