!! Copyright (C) 2005-2006 Heiko Appel, Florian Lorenzen
!!
!! This program is free software; you can redistribute it and/or modify
!! it under the terms of the GNU General Public License as published by
!! the Free Software Foundation; either version 2, or (at your option)
!! any later version.
!!
!! This program is distributed in the hope that it will be useful,
!! but WITHOUT ANY WARRANTY; without even the implied warranty of
!! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!! GNU General Public License for more details.
!!
!! You should have received a copy of the GNU General Public License
!! along with this program; if not, write to the Free Software
!! Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
!! 02111-1307, USA.
!!
!! $Id$

#include "global.h"

! Simple profiling module to count the number of
! times code between
! call profiling_in(tag)
! ...
! call profiling_out(tag)
! is executed and how much time is consumed. The tag
! has to be registered as constant C_PROFILING_[SOMETHING] and
! in tag_label (C_TAG_LENGTH and C_NUM_TAG should be adjusted
! after adding a new tag).
! The routines maintain entry and exit counters (in profiling_in,
! profiling_out respectively). They should be equal, otherwise
! measurements are likely to be incorrect (e. g. because
! of a return inside subroutine without an profiling_out).
! loct_gettimeofday is used to get the times.
! The results are written to .profiling.NNN/profiling.nnn
! for every node with nnn being the node number and NNN the
! total number of nodes.

module profiling_m

  use global_m
  use io_m
  use lib_oct_m
  use messages_m
  use mpi_m

  implicit none
  private

  public ::                             &
    profiling_init,                     &
    profiling_in,                       &
    profiling_out,                      &
    profiling_output

  integer, parameter ::                 & 
    C_TAG_LENGTH = 17,                  &  ! Max. number of characters of tag label.
    C_NUM_TAGS   = 38                      ! Number of tags.

  integer ::                            &
    pass_in(C_NUM_TAGS)           =  0, &
    pass_out(C_NUM_TAGS)          =  0, &
    time_in_sec(C_NUM_TAGS)       =  0, &
    time_in_usec(C_NUM_TAGS)      =  0, &
    time_sec(C_NUM_TAGS)          =  0, &
    time_usec(C_NUM_TAGS)         =  0

  integer, parameter, public ::         &
    C_PROFILING_COMPLETE_DATASET  =  1, &
    C_PROFILING_MF_INTEGRATE      =  2, &
    C_PROFILING_MF_DOTP           =  3, &
    C_PROFILING_MF_NRM2           =  4, &
    C_PROFILING_NL_OPERATOR       =  5, &
    C_PROFILING_GHOST_UPDATE      =  6, &
    C_PROFILING_VEC_INTEGRATE     =  7, &
    C_PROFILING_SCF_CYCLE         =  8, &
    C_PROFILING_MF_DOTP_ALLREDUCE =  9, &
    C_PROFILING_HPSI              = 10
  integer, parameter, public ::         &
    C_PROFILING_KINETIC           = 11, &
    C_PROFILING_VLPSI             = 12, &
    C_PROFILING_VNLPSI            = 13, &
    C_PROFILING_POISSON_SOLVE     = 14, &
    C_PROFILING_XC                = 15, &
    C_PROFILING_XC_LOCAL          = 16, &
    C_PROFILING_XC_OEP            = 17, &
    C_PROFILING_XC_EXX            = 18, &
    C_PROFILING_XC_SIC            = 19, &
    C_PROFILING_XC_KLI            = 20
  integer, parameter, public ::         &
    C_PROFILING_XC_OEP_FULL       = 21, &
    C_PROFILING_TIME_STEP         = 22, &
    C_PROFILING_GRAM_SCHMIDT1     = 23, &
    C_PROFILING_GRAM_SCHMIDT2     = 24, &
    C_PROFILING_EIGEN_SOLVER      = 25, &
    C_PROFILING_DISK_ACCESS       = 26, &
    C_PROFILING_LCAO              = 27, &
    C_PROFILING_LCAO_INIT         = 28, &
    C_PROFILING_FORCES            = 29, &
    C_PROFILING_EPOT_GENERATE     = 30
  integer, parameter, public ::         &
    C_PROFILING_ELEC_PROPAGATOR   = 31, &
    C_PROFILING_LOBPCG_BLOCKT     = 32, &
    C_PROFILING_LOBPCG_BLOCK_MATR = 33, &
    C_PROFILING_LOBPCG_ESOLVE     = 34, &
    C_PROFILING_LOBPCG_CHOL       = 35, &
    C_PROFILING_LOBPCG_INV        = 36, &
    C_PROFILING_LOBPCG_COPY       = 37, &
    C_PROFILING_LOBPCG_LOOP       = 38

  character(len=C_TAG_LENGTH), dimension(C_NUM_TAGS) :: tag_label 


contains


  ! ---------------------------------------------------------
  ! Create profiling subdirectory.
  subroutine profiling_init
#if defined(HAVE_MPI)
    character(len=3) :: dirnum
#endif

    tag_label(1)  = 'COMPLETE_DATASET '
    tag_label(2)  = 'MF_INTEGRATE     '
    tag_label(3)  = 'MF_DOTP          '
    tag_label(4)  = 'MF_NRM2          '
    tag_label(5)  = 'NL_OPERATOR      '
    tag_label(6)  = 'GHOST_UPDATE     '
    tag_label(7)  = 'VEC_INTEGRATE    '
    tag_label(8)  = 'SCF_CYCLE        '
    tag_label(9)  = 'MF_DOTP_ALLREDUCE'
    tag_label(10) = 'HPSI             '
    tag_label(11) = 'KINETIC          '
    tag_label(12) = 'VLPSI            '
    tag_label(13) = 'VNLPSI           '
    tag_label(14) = 'POISSON_SOLVE    '
    tag_label(15) = 'XC               '
    tag_label(16) = 'XC_LOCAL         '
    tag_label(17) = 'XC_OEP           '
    tag_label(18) = 'XC_EXX           '
    tag_label(19) = 'XC_SIC           '
    tag_label(20) = 'XC_KLI           '
    tag_label(21) = 'XC_OEP_FULL      '
    tag_label(22) = 'TIME_STEP        '
    tag_label(23) = 'GRAM_SCHMIDT1    '
    tag_label(24) = 'GRAM_SCHMIDT2    '
    tag_label(25) = 'EIGEN_SOLVER     '
    tag_label(26) = 'DISK_ACCESS      '
    tag_label(27) = 'LCAO             '
    tag_label(28) = 'LCAO_INIT        '
    tag_label(29) = 'FORCES           '
    tag_label(30) = 'EPOT_GENERATE    '
    tag_label(31) = 'ELEC_PROPAGATOR  '
    tag_label(32) = 'LOBPCG_BLOCKT    '
    tag_label(33) = 'LOBPCG_BLOCK_MATR'
    tag_label(34) = 'LOBPCG_ESOLVE    '
    tag_label(35) = 'LOBPCG_CHOL      '
    tag_label(36) = 'LOBPCG_INV       '
    tag_label(37) = 'LOBPCG_COPY      '
    tag_label(38) = 'LOBPCG_LOOP      '


    if(.not.in_profiling_mode) return

    call push_sub('profiling.profiling_init')

#if defined(HAVE_MPI)
    if(mpi_grp_is_root(mpi_world)) then
      write(dirnum, '(i3.3)') mpi_world%size
      call io_mkdir(trim('profiling.'//dirnum))
    end if
#else
    call io_mkdir('profiling.ser')
#endif

    ! initialize counter
    pass_in      = 0
    pass_out     = 0
    time_in_sec  = 0
    time_in_usec = 0
    time_sec     = 0
    time_usec    = 0

    call pop_sub()
  end subroutine profiling_init


  ! ---------------------------------------------------------
  ! Increment in counter and save entry time.
  subroutine profiling_in(tag)
    integer :: tag

    if(.not.in_profiling_mode) return

    pass_in(tag) = pass_in(tag)+1
    call loct_gettimeofday(time_in_sec(tag), time_in_usec(tag))

  end subroutine profiling_in


  ! ---------------------------------------------------------
  ! Increment out counter and sum up difference between entry
  ! and exit time.
  subroutine profiling_out(tag)
    integer :: tag

    integer :: sec, usec

    if(.not.in_profiling_mode) return

    pass_out(tag) = pass_out(tag)+1
    call loct_gettimeofday(sec, usec)
    call time_diff(time_in_sec(tag), time_in_usec(tag), sec, usec)
    call time_sum(sec, usec, time_sec(tag), time_usec(tag))

  end subroutine profiling_out


  ! ---------------------------------------------------------
  ! Write profiling results of each node to profiling.NNN/profifling.nnn
  ! The format of each line is
  ! tag-label    pass_in    pass_out    time   time/pass_in
  !
  ! The last column gives the average time consumed between in and out
  ! (only, if pass_in and pass_out are equal).
  subroutine profiling_output
    integer          :: i
    integer          :: iunit
    character(len=3) :: filenum
    character(len=3) :: dirnum
    real             :: time_per_pass
    real             :: total_time, percent

    if(.not.in_profiling_mode) return

    call push_sub('profiling.profiling_output')

#if defined(HAVE_MPI)
    write(filenum, '(i3.3)') mpi_world%rank
    write(dirnum, '(i3.3)') mpi_world%size
#else
    filenum = '000'
    dirnum  = 'ser'
#endif

    total_time = real(time_sec(C_PROFILING_COMPLETE_DATASET))+1e-6*real(time_usec(C_PROFILING_COMPLETE_DATASET))

    iunit = io_open('profiling.'//dirnum//'/profiling.'//filenum, action='write')
    if(iunit.lt.0) then
      message(1) = 'Could not write profiling results.'
      call write_warning(1)
      call pop_sub()
      return
    end if
    write(iunit,'(a80)') &
         'TAG                   NUMBER OF CALLS       TOTAL TIME    TIME PER CALL    %TIME'
    write(iunit,'(a80 )') &
         '================================================================================'
    do i = 1, C_NUM_TAGS
      if(pass_in(i).eq.pass_out(i)) then
        time_per_pass = (real(time_sec(i))+1e-6*real(time_usec(i)))/ &
          real(max(pass_in(i), 1))
        percent = 100.0*(real(time_sec(i))+1e-6*real(time_usec(i)))/total_time

      else
        write(iunit,'(3a,i10,a,i10)') '*** WARNING: Entries and exits for ',trim(tag_label(i)), ' do not coincide:', &
                          pass_in(i), ' .ne.', pass_out(i)
        cycle
      end if
      if(pass_in(i) .eq. 0) cycle
      write(iunit, '(a,i20,i10,a1,i6.6,f17.7, f9.1)') tag_label(i), pass_in(i), &
           time_sec(i), '.', time_usec(i), time_per_pass, percent
    end do

    call io_close(iunit)
    call pop_sub()
  end subroutine profiling_output

end module profiling_m

!! Local Variables:
!! mode: f90
!! coding: utf-8
!! End:
