!! Copyright (C) 2002-2006 M. Marques, A. Castro, A. Rubio, G. Bertsch
!!
!! This program is free software; you can redistribute it and/or modify
!! it under the terms of the GNU General Public License as published by
!! the Free Software Foundation; either version 2, or (at your option)
!! any later version.
!!
!! This program is distributed in the hope that it will be useful,
!! but WITHOUT ANY WARRANTY; without even the implied warranty of
!! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!! GNU General Public License for more details.
!!
!! You should have received a copy of the GNU General Public License
!! along with this program; if not, write to the Free Software
!! Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
!! 02111-1307, USA.
!!
!! $Id$

!***********************************************************************
!                                Comments
!***********************************************************************
! Atomic weights should be read in [atomic mass units] (u) (not to mistake
! with [atomic units]), that is, it should be given the relative
! atomic weight). 1u is roughly the mass of the proton, and exactly
! one twelveth of the ^{12}C isotope. The relation of the atomic mass
! unit and the atomic unit of mass, au_[mass], is:
!
! 1 au_[mass] = 5.485799110e-4 u
!
! The atomic unit of mass is the mass of the electron. Unfortunately, the
! code uses units of mass of (eV/A^2)(h/(2pieV))^2, which are related to
! atomic units through 1cu_[mass] = 7.619963358 au_[mass] . So:
!
! 1u = (1/5.485799110e-4) au_[mass] = (1/5.485799110e-4) *
!      (1/7.619963358) cu_[mass] = 239.225360 cu_[mass].

#include "global.h"

module units_m
  use datasets_m
  use global_m
  use lib_oct_parser_m
  use messages_m
  use io_m

  implicit none

  private
  public ::           &
    unit_t,           &
    unit_system_t,    &
    units_init,       &
    units_get,        &
    units_inp,        &
    units_out,        &
    units_from_file

  type unit_t
    FLOAT :: factor
    character(len=12) :: abbrev ! common abbreviation of the unit name
    character(len=50) :: name   ! common name
  end type unit_t

  type unit_system_t
    type(unit_t) :: length
    type(unit_t) :: energy
    type(unit_t) :: time
    type(unit_t) :: velocity
    type(unit_t) :: mass
    type(unit_t) :: force
    type(unit_t) :: acceleration
  end type unit_system_t

  type(unit_system_t) :: units_inp, units_out
  
  FLOAT, parameter, public :: hartree_to_cm_inv = 219474.63

contains


  ! ---------------------------------------------------------
  subroutine units_init()
    character(len=10) :: c
    character(len=3) :: cinp, cout

    call push_sub('units.units_init')

    !%Variable Units
    !%Type string
    !%Default "a.u"
    !%Section Generalities::Units
    !%Description
    !% Atomic units seem to be the preferred system in the atomic and
    !% molecular physics community (despite the opinion of some of the authors
    !% of this program). Internally, the code works in atomic units. However,
    !% for input or output, some people like using eV for energies and AA for
    !% lengths. This other system of units can also be used.
    !%Option "a.u"
    !% Atomic units
    !%Option "eVA"
    !% Electron-volts for energy, Angstrom for length.
    !%End

    !%Variable UnitsInput
    !%Type string
    !%Default "a.u"
    !%Section Generalities::Units
    !%Description
    !% Same as "Units", but only refers to the values in the input files.  That
    !% is, if UnitsInput = "eVA", all physical values in the input files
    !% will be considered to be in eV and Angstroms.
    !%End

    !%Variable UnitsOutput
    !%Type string
    !%Default "a.u"
    !%Section Generalities::Units
    !%Description
    !% Same as "Units", but only refers to the values in the output files.  That
    !% is, if UnitsInput = "eVA", all physical values in the output files
    !% will be considered to be in eV and Angstroms.
    !%End

    if(loct_parse_isdef(check_inp('Units')).ne.0) then
      call loct_parse_string(check_inp('Units'), "a.u", c)
      cinp = c(1:3)
      cout = c(1:3)
    else
      call loct_parse_string(check_inp('UnitsInput'), "a.u", c)
      cinp = c(1:3)
      call loct_parse_string(check_inp('UnitsOutput'), "a.u", c)
      cout = c(1:3)
    end if

    call units_get(units_inp, cinp)
    call units_get(units_out, cout)

    call pop_sub()

  end subroutine units_init

  ! ---------------------------------------------------------
  subroutine units_get(u, c)
    type(unit_system_t), intent(out) :: u
    character(len=3) :: c

    select case(c)
    case ("a.u")
      call units_atomic(u)
    case ("eVA")
      call units_eV_Ang(u)
    case default
      call input_error('Units')
    end select
  end subroutine units_get


  ! these routines output the unit conversions factors, defined by
  ! [a.u.] = <input>*u.unit
  ! <output> = [a.u.]/u.unit

  ! ---------------------------------------------------------
  subroutine units_atomic(u)
    type(unit_system_t), intent(out) :: u

    u%length%abbrev = "b"
    u%length%name   = "bohr"
    u%length%factor = M_ONE

    u%energy%abbrev = "H"
    u%energy%name   = "Hartree"
    u%energy%factor = M_ONE

    u%time%abbrev = "hbar/H"
    u%time%name   = "hbar/Hartree"
    u%time%factor = M_ONE/u%energy%factor

    u%velocity%abbrev = "bH(2pi/h)"
    u%velocity%name   = "bohr times Hartree over h bar"
    u%velocity%factor = M_ONE

    u%mass%abbrev   = "u"
    u%mass%name     = "1/12 of the mass of C^12"
    u%mass%factor   = M_ONE/CNST(5.485799110e-4)

    u%force%abbrev  = "H/b"
    u%force%name    = "Hartree/bohr"
    u%force%factor  = M_ONE

    u%acceleration%abbrev = "bH(2pi/h)^2"
    u%acceleration%name   = "bohr times (Hartree over h bar) squared"
    u%acceleration%factor = M_ONE
  end subroutine units_atomic


  ! ---------------------------------------------------------
  subroutine units_eV_Ang(u)
    type(unit_system_t), intent(out) :: u

    u%length%abbrev = "A"
    u%length%name   = "Angstrom"
    u%length%factor = P_Ang  ! 1 a.u. = 0.529 A

    u%energy%abbrev = "eV"
    u%energy%name   = "electron volt"
    u%energy%factor = M_ONE/(M_TWO*P_Ry)   ! 1 a.u. = 27.2 eV

    u%time%abbrev = "hbar/eV"
    u%time%name   = "hbar/electron volt"
    u%time%factor = M_ONE/u%energy%factor

    u%velocity%abbrev = "AeV(2pi/h)"
    u%velocity%name   = "Angstrom times electron volts over h bar"
    u%velocity%factor = u%length%factor*u%energy%factor

    u%mass%abbrev   = "u"
    u%mass%name     = "1/12 of the mass of C^12"
    u%mass%factor   = M_ONE/CNST(5.485799110e-4)

    u%force%abbrev  = "eV/A"
    u%force%name    = "electron volt/amstrong"
    u%force%factor  = u%energy%factor/u%length%factor

    u%acceleration%abbrev = "AeV(2pi/h)^2"
    u%acceleration%name   = "Angstrom times (electron volt over h bar) squared"
    u%acceleration%factor = u%length%factor/u%time%factor**2
  end subroutine units_eV_Ang


  ! ---------------------------------------------------------
  ! This is a very primitive procedure that attempts to find out
  ! which units were used to write one octopus file, be it a
  ! "multipoles", a "cross_section_tensor", etc. 
  ! TODO: although it seems to work in most cases, it is obviously
  ! a very weak code.
  ! ---------------------------------------------------------
  subroutine units_from_file(u, fname, ierr)
    type(unit_system_t), intent(inout) :: u
    character(len=*),    intent(in)    :: fname
    integer,             intent(inout) :: ierr

    integer            :: iunit, ios, i
    character(len=256) :: line

    call push_sub('units.units_from_file')

    iunit = io_open(file = trim(fname), action = 'read', status = 'old', die = .false.)
    if(iunit < 0) then
      ierr = -2
      call pop_sub(); return
    end if

    ierr = 0
    do
      read(iunit, '(a)', iostat = ios) line
      if(ios.ne.0) exit
      if(index(line,'[A]').ne.0  .or.  index(line,'eV').ne.0) then
        call units_get(u, 'eVA')
        call pop_sub(); return
      elseif(index(line,'[b]').ne.0) then
        call units_get(u, 'a.u')
        call pop_sub(); return
      end if
    end do

    ierr = -1

    call pop_sub()
  end subroutine units_from_file


end module units_m

!! Local Variables:
!! mode: f90
!! coding: utf-8
!! End:
