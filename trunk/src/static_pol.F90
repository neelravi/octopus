!! Copyright (C) 2002 M. Marques, A. Castro, A. Rubio, G. Bertsch
!!
!! This program is free software; you can redistribute it and/or modify
!! it under the terms of the GNU General Public License as published by
!! the Free Software Foundation; either version 2, or (at your option)
!! any later version.
!!
!! This program is distributed in the hope that it will be useful,
!! but WITHOUT ANY WARRANTY; without even the implied warranty of
!! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!! GNU General Public License for more details.
!!
!! You should have received a copy of the GNU General Public License
!! along with this program; if not, write to the Free Software
!! Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
!! 02111-1307, USA.

#include "config_F90.h"

module static_pol
use liboct
use io
use units
use system
use hamiltonian
use scf

implicit none

contains

subroutine static_pol_run(scf, sys, h)
  type(system_type), intent(inout) :: sys
  type(hamiltonian_type), intent(inout) :: h
  type(scf_type), intent(inout) :: scf
  
  integer :: iunit, ios, i_start, i, j, is
  real(r8) :: e_field
  real(r8), allocatable :: Vpsl_save(:)
  real(r8) :: dipole(0:conf%dim, conf%dim, sys%st%nspin)
  logical :: out_pol

  sub_name = 'static_pol_run'; call push_sub()

  ! read in e_field value
  call oct_parse_double(C_string('POLStaticField'), &
       0.001_r8/units_inp%energy%factor*units_inp%length%factor, e_field)
  e_field = e_field * units_inp%energy%factor / units_inp%length%factor
  if (e_field <= 0._r8) then
    write(message(1), '(a,e14.6,a)') "Input: '", e_field, "' is not a valid POLStaticField"
    message(2) = '(0 < POLStaticField)'
    call write_fatal(2)
  end if

  ! open restart file
  call io_assign(iunit)
  open(iunit, file='tmp/restart.pol', status='unknown')
  do i_start = 0, conf%dim
    read(iunit, fmt=*, iostat=ios) dipole(i_start, 1:conf%dim, :)
    if(ios.ne.0) exit
  end do
  if(ios.eq.0) then ! all information is already calculated
    i_start = 4 ! do not do the do loop
    out_pol = .true.
  else
    out_pol = .false.
  end if
  call io_close(iunit)

  ! save local pseudopot
  allocate(Vpsl_save(sys%m%np))
  Vpsl_save = h%Vpsl

  do i = i_start, conf%dim
    if(clean_stop()) exit

    write(message(1), '(a, i2)')'Info: Calculating dipole moment for field ', i
    call write_info(1)

    h%Vpsl = Vpsl_save
    h%Vpsl = h%Vpsl - sys%m%Lxyz(i,:)*sys%m%h(i)*e_field

    call scf_run(scf, sys, h)
    
    ! calculate dipole
    do is = 1, sys%st%nspin
      do j = 1, conf%dim
        dipole(i, j, is) = sum(sys%st%rho(:, is)*sys%m%Lxyz(j,:))*sys%m%h(j)*sys%m%vol_pp
      end do
    end do

    ! output dipole
    call io_assign(iunit)
    open(iunit, file='tmp/restart.pol', status='unknown')
    do j = 0, i
      write(iunit, fmt=*) dipole(j, 1:conf%dim, :)
    end do
    call io_close(iunit)

    if(i == conf%dim) then 
      out_pol = .true.
    end if
  end do

  deallocate(Vpsl_save)

  if(out_pol) then ! output pol file
    call oct_mkdir(C_string("linear"))
    call io_assign(iunit)
    open(iunit, file='linear/polarizability', status='unknown')
    write(iunit, '(2a)', advance='no') '# Static polarizability tensor [', &
         trim(units_out%length%abbrev)
    if(conf%dim.ne.1) write(iunit, '(a,i1)', advance='no') '^', conf%dim
    write(iunit, '(a)') ']'
         
    do is = 1, sys%st%nspin
      do j = 1, conf%dim
        write(iunit, '(3f12.6)') (dipole(j, 1:conf%dim, is) - dipole(0, 1:conf%dim, is))/e_field &
             / units_out%length%factor**conf%dim
      end do
    end do
    call io_close(iunit)
  end if

  call pop_sub()
  return
end subroutine static_pol_run

end module static_pol
