!! Copyright (C) 2002-2006 M. Marques, A. Castro, A. Rubio, G. Bertsch
!!
!! This program is free software; you can redistribute it and/or modify
!! it under the terms of the GNU General Public License as published by
!! the Free Software Foundation; either version 2, or (at your option)
!! any later version.
!!
!! This program is distributed in the hope that it will be useful,
!! but WITHOUT ANY WARRANTY; without even the implied warranty of
!! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!! GNU General Public License for more details.
!!
!! You should have received a copy of the GNU General Public License
!! along with this program; if not, write to the Free Software
!! Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
!! 02111-1307, USA.
!!
!! $Id: target_hhg_inc.F90 $


  ! ----------------------------------------------------------------------
  !> 
  subroutine target_init_hhg(tg, td, w0)
    type(target_t),   intent(inout) :: tg
    type(td_t),       intent(in)    :: td
    FLOAT,            intent(in)    :: w0

    integer       :: jj
    type(block_t) :: blk
    PUSH_SUB(target_init_hhg)

    !%Variable OCTOptimizeHarmonicSpectrum
    !%Type block
    !%Default no
    !%Section Calculation Modes::Optimal Control
    !%Description
    !% WARNING: Experimental
    !%
    !% If <tt>OCTTargetOperator = oct_tg_hhg</tt>, the target is the harmonic emission spectrum.
    !% In that case, you must supply an <tt>OCTOptimizeHarmonicSpectrum</tt> block in the <tt>inp</tt>
    !% file. The target is given, in general, by:
    !%
    !% <math>J_1 = \int_0^\infty d\omega \alpha(\omega) H(\omega)</math>,
    !%
    !% where <math>H(\omega)</math> is the harmonic spectrum generated by the system, and
    !% <math>\alpha(\omega)</math> is some function that determines what exactly we want
    !% to optimize. The role of the <tt>OCTOptimizeHarmonicSpectrum</tt> block is to determine
    !% this <math>\alpha(\omega)</math> function. Currently, this function is defined as:
    !%
    !% <math>\alpha(\omega) = \sum_{L=1}^{M} \frac{\alpha_L}{a_L} \sqcap( (\omega - L\omega_0)/a_L )</math>,
    !%
    !% where <math>omega_0</math> is the carrier frequency. <math>M</math> is
    !% the number of columns in the <tt>OCTOptimizeHarmonicSpectrum</tt> block. The values of <i>L</i> will be listed
    !% in the first row of this block; <math> alpha_L </math> in the second row, and <math>a_L</math> in
    !% the third.
    !% 
    !% Example:
    !%
    !% <tt>%OCTOptimizeHarmonicSpectrum
    !% <br>&nbsp;&nbsp;  7    |  9    | 11
    !% <br>&nbsp;&nbsp; -1    |  1    | -1 
    !% <br>&nbsp;&nbsp;  0.01 |  0.01 |  0.01
    !% <br>%</tt>
    !%
    !%End
    if(parse_isdef(datasets_check('OCTOptimizeHarmonicSpectrum')) /= 0) then
      if(parse_block(datasets_check('OCTOptimizeHarmonicSpectrum'), blk) == 0) then
        tg%hhg_nks = parse_block_cols(blk, 0)
        SAFE_ALLOCATE(    tg%hhg_k(1:tg%hhg_nks))
        SAFE_ALLOCATE(tg%hhg_alpha(1:tg%hhg_nks))
        SAFE_ALLOCATE(    tg%hhg_a(1:tg%hhg_nks))
        do jj = 1, tg%hhg_nks
          call parse_block_integer(blk, 0, jj - 1, tg%hhg_k(jj))
          call parse_block_float(blk, 1, jj - 1, tg%hhg_alpha(jj))
          call parse_block_float(blk, 2, jj - 1, tg%hhg_a(jj))
        end do
        call parse_block_end(blk)
      else
        message(1) = '"OCTOptimizeHarmonicSpectrum" has to be specified as a block.'
        call messages_info(1)
        call input_error('OCTOptimizeHarmonicSpectrum')
      end if
    else
      write(message(1), '(a)') 'If "OCTTargetMode = oct_targetmode_hhg", you must supply an'
      write(message(2), '(a)') '"OCTOptimizeHarmonicSpectrum" block.'
      call messages_fatal(2)
    end if

    tg%hhg_w0 = w0
    tg%dt     = td%dt
    SAFE_ALLOCATE(tg%td_fitness(0:td%max_iter))
    tg%td_fitness = M_ZERO

    POP_SUB(target_init_hhg)
  end subroutine target_init_hhg


  ! ----------------------------------------------------------------------
  !> 
  subroutine target_init_hhgnew(gr, tg, td, geo, ep)
    type(grid_t),     intent(in)    :: gr
    type(target_t),   intent(inout) :: tg
    type(td_t),       intent(in)    :: td
    type(geometry_t), intent(in)    :: geo
    type(epot_t),     intent(inout) :: ep

    integer :: ist, jst, iunit, jj, nn(3), optimize_parity(3)
    logical :: optimize(3)
    FLOAT :: dw, psi_re, psi_im, ww
    FLOAT, allocatable  :: vl(:), vl_grad(:,:)
    PUSH_SUB(target_init_hhgnew)

    if(parse_isdef('OCTMoveIons')  ==  0) then
       message(1) = 'If OCTTargetOperator = oct_tg_hhgnew, then you must supply'
       message(2) = 'the variable "OCTMoveIons".'
       call messages_fatal(2)
    else
       call parse_logical(datasets_check('OCTMoveIons'), .false., tg%move_ions)
    end if

    ! We allocate many things that are perhaps not necessary if we use a direct optimization scheme.
    SAFE_ALLOCATE(tg%vel(td%max_iter+1, MAX_DIM))
    SAFE_ALLOCATE(tg%acc(td%max_iter+1, MAX_DIM))
    SAFE_ALLOCATE(tg%gvec(td%max_iter+1, MAX_DIM))
    SAFE_ALLOCATE(tg%alpha(td%max_iter))

    ! The following is a temporary hack, that assumes only one atom at the origin of coordinates.
    if(geo%natoms > 1) then
      message(1) = 'If "OCTTargetOperator = oct_tg_hhgnew", then you can only have one atom.'
      call messages_fatal(1)
    end if

    ! The following is a temporary hack, that assumes only one atom at the origin of coordinates.
    if(geo%natoms > 1) then
      message(1) = 'If "OCTTargetOperator = oct_tg_hhgnew", then you can only have one atom.'
      call messages_fatal(1)
    end if

    SAFE_ALLOCATE(tg%grad_local_pot(1:geo%natoms, 1:gr%mesh%np, 1:gr%sb%dim))
    SAFE_ALLOCATE(vl(1:gr%mesh%np_part))
    SAFE_ALLOCATE(vl_grad(1:gr%mesh%np, 1:gr%sb%dim))
    SAFE_ALLOCATE(tg%rho(1:gr%mesh%np))

    vl(:) = M_ZERO
    vl_grad(:,:) = M_ZERO
    call epot_local_potential(ep, gr%der, gr%dgrid, geo, 1, vl)
    call dderivatives_grad(gr%der, vl, vl_grad)
    forall(ist=1:gr%mesh%np, jst=1:gr%sb%dim)
      tg%grad_local_pot(1, ist, jst) = vl_grad(ist, jst)
    end forall
    ! Note that the calculation of the gradient of the potential
    ! is wrong at the borders of the box, since it assumes zero boundary
    ! conditions. The best way to solve this problems is to define the 
    ! target making use of the definition of the forces based on the gradient
    ! of the density, rather than on the gradient of the potential.

          
    !%Variable OCTHarmonicWeight
    !%Type string
    !%Section Calculation Modes::Optimal Control
    !%Description
    !% EXPERIMENTAL: If "OCTTargetOperator = oct_tg_plateau", then the function to optimize is the integral of the
    !% harmonic spectrum H(w), weighted with a function f(w) that is defined as a string here. For example, if 
    !% you set OCTHarmonicWeight  = "step(w-1)", the function to optimize is the integral of step(w-1)*H(w) or, i.e.
    !% the integral of H(w) from one to infinity. In practice, it is better if you also set an upper limit, i.e.
    !% for example f(w) = step(w-1)*step(2-w).
    !%End
    call parse_string(datasets_check('OCTHarmonicWeight'), "1", tg%plateau_string)
    tg%dt = td%dt
    SAFE_ALLOCATE(tg%td_fitness(0:td%max_iter))
    tg%td_fitness = M_ZERO

    iunit = io_open('.alpha', action = 'write')
    dw = (M_TWO * M_PI) / (td%max_iter * tg%dt)
    do jj = 0, td%max_iter - 1
      ww = jj * dw
      call parse_expression(psi_re, psi_im, "w", ww, tg%plateau_string)
      tg%alpha(jj+1) = psi_re
      write(iunit, *) ww, psi_re
    end do
    call io_close(iunit)

    nn(1:3) = (/ td%max_iter, 1, 1 /)
    optimize(1:3) = .false.
    optimize_parity(1:3) = -1
    call fft_init(tg%fft_handler, nn(1:3), 1, FFT_COMPLEX, FFTLIB_FFTW, optimize, optimize_parity)

    POP_SUB(target_init_hhgnew)
  end subroutine target_init_hhgnew


  ! ----------------------------------------------------------------------
  !> 
  FLOAT function target_j1_hhg(tg) result(j1)
    type(target_t),   intent(inout) :: tg

    integer :: maxiter, jj
    FLOAT :: aa, ww, maxhh, omega
    CMPLX, allocatable :: ddipole(:)
    PUSH_SUB(target_j1_hhg)

    maxiter = size(tg%td_fitness) - 1
    SAFE_ALLOCATE(ddipole(0:maxiter))
    ddipole = M_z0
    ddipole = tg%td_fitness

    call spectrum_hsfunction_init(tg%dt, 0, maxiter, maxiter, ddipole)
    do jj = 1, tg%hhg_nks
      aa = tg%hhg_a(jj) * tg%hhg_w0
      ww = tg%hhg_k(jj) * tg%hhg_w0
      call spectrum_hsfunction_min(ww - aa, ww + aa, omega, maxhh)
      j1 = j1 + tg%hhg_alpha(jj) * log(-maxhh)
    end do
    call spectrum_hsfunction_end()

    SAFE_DEALLOCATE_A(ddipole)
    POP_SUB(target_j1_hhg)
  end function target_j1_hhg


  ! ----------------------------------------------------------------------
  !> 
  FLOAT function target_j1_hhgnew(gr, tg) result(j1)
    type(grid_t),     intent(in)    :: gr
    type(target_t),   intent(inout) :: tg

    integer :: maxiter, i
    FLOAT :: dw, ww
    PUSH_SUB(target_j1_hhgnew)

    maxiter = size(tg%td_fitness) - 1
    dw = (M_TWO * M_PI) / (maxiter * tg%dt)
    j1 = M_ZERO
    do i = 0, maxiter - 1
      ww = i * dw
      j1 = j1 + dw * tg%alpha(i+1) * sum(abs(tg%vel(i+1, 1:gr%sb%dim))**2)
    end do

    POP_SUB(target_j1_hhgnew)
  end function target_j1_hhgnew



!! Local Variables:
!! mode: f90
!! coding: utf-8
!! End:
