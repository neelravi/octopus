!! Copyright (C) 2002-2006 M. Marques, A. Castro, A. Rubio, G. Bertsch, X. Andrade
!!
!! This program is free software; you can redistribute it and/or modify
!! it under the terms of the GNU General Public License as published by
!! the Free Software Foundation; either version 2, or (at your option)
!! any later version.
!!
!! This program is distributed in the hope that it will be useful,
!! but WITHOUT ANY WARRANTY; without even the implied warranty of
!! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!! GNU General Public License for more details.
!!
!! You should have received a copy of the GNU General Public License
!! along with this program; if not, write to the Free Software
!! Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
!! 02111-1307, USA.
!!
!! $Id$

#include "global.h"

module multigrid_m
  use curvlinear_m
  use derivatives_m
  use datasets_m
  use geometry_m
  use global_m
  use loct_parser_m
  use mesh_m
  use mesh_init_m
  use messages_m
  use par_vec_m

  implicit none

  private
  public ::                         &
    multigrid_level_t,              &
    multigrid_t,                    &
    multigrid_init,                 &
    multigrid_end,                  &
    multigrid_mesh_half,            &
    multigrid_mesh_double,          &
    dmultigrid_fine2coarse,          &
    zmultigrid_fine2coarse,          &
    dmultigrid_coarse2fine,         &
    zmultigrid_coarse2fine,         &
    multigrid_get_transfer_tables

  integer, parameter, public :: &
    INJECTION  = 1,             &
    FULLWEIGHT = 2

  type multigrid_level_t
    type(mesh_t),  pointer  :: m
    type(derivatives_t),   pointer  :: der

    integer          ::  n_coarse
    integer, pointer :: to_coarse(:)

    integer          ::  n_fine
    integer          ::  n_fine1,       n_fine2,       n_fine4,       n_fine8
    integer, pointer :: to_fine1(:,:), to_fine2(:,:), to_fine4(:,:), to_fine8(:,:)
    integer, pointer :: fine_i(:)
  end type multigrid_level_t

  type multigrid_t
    integer                          :: n_levels
    type(multigrid_level_t), pointer :: level(:)

    integer          :: tp
    integer, pointer :: sp(:)
    integer, pointer :: ep(:)
    integer, pointer :: ep_part(:)
  end type multigrid_t

contains

  ! ---------------------------------------------------------
  subroutine multigrid_init(mgrid, geo, cv, m, der, n_stencil, stencil)
    type(multigrid_t),             intent(out) :: mgrid
    type(geometry_t),              intent(in)  :: geo
    type(curvlinear_t),            intent(in)  :: cv
    type(mesh_t),          target, intent(in)  :: m
    type(derivatives_t),   target, intent(in)  :: der
    integer,                       intent(in)  :: n_stencil
    integer,                       intent(in)  :: stencil(:, :)

    integer :: i, n_levels, np

    call push_sub('multigrid.multigrid_init')

    !%Variable MultigridLevels
    !%Type integer
    !%Default 0 
    !%Section Mesh
    !%Description
    !% Number of levels in the grid hierarchy used for multigrid. Positive
    !% numbers indicate an absolute number of levels, negative
    !% numbers are subtracted to maximum number of levels possible for
    !% the grid been used. Default is the maximum number of levels for
    !% the grid.
    !%Option max_levels 0
    !% Calculate the optimal number of levels for the grid.
    !%End

    call loct_parse_int(check_inp('MultigridLevels'), 0, n_levels)

    if ( n_levels <= 0 )then
      n_levels=n_levels-3
      np=m%np

      do while ( np > 1 )
        np=np/8
        n_levels=n_levels+1
      end do
    else
      n_levels=n_levels-1
    end if

    mgrid%n_levels = n_levels

    ALLOCATE(mgrid%level(0:n_levels), n_levels+1)

    mgrid%level(0)%m   => m
    mgrid%level(0)%der => der

    mgrid%level(0)%n_fine = m%np
    ALLOCATE(mgrid%level(0)%fine_i(m%np), m%np)

    write(message(1), '(a,i3)') "Multigrid levels:", n_levels+1
    call write_info(1)

    do i = 1, mgrid%n_levels
      ALLOCATE(mgrid%level(i)%m, 1)
      ALLOCATE(mgrid%level(i)%der, 1)
      
      call multigrid_mesh_half(geo, cv, mgrid%level(i-1)%m, mgrid%level(i)%m, der%lapl%stencil, der%lapl%n)

      call derivatives_init(mgrid%level(i)%der, m%sb, cv%method.ne.CURV_METHOD_UNIFORM)

      if(m%parallel_in_domains) then
        call mesh_init_stage_3(mgrid%level(i)%m, geo, cv, stencil, n_stencil, m%mpi_grp, &
             parent = mgrid%level(i - 1)%m)
      else
        call mesh_init_stage_3(mgrid%level(i)%m, geo, cv)
      end if

      call multigrid_get_transfer_tables(mgrid%level(i), mgrid%level(i-1)%m, mgrid%level(i)%m)

      call derivatives_build(mgrid%level(i)%der, mgrid%level(i)%m)

      call mesh_write_info(mgrid%level(i)%m, stdout)

    end do
    
    ALLOCATE(mgrid%sp(0:mgrid%n_levels), mgrid%n_levels)
    ALLOCATE(mgrid%ep(0:mgrid%n_levels), mgrid%n_levels)
    ALLOCATE(mgrid%ep_part(0:mgrid%n_levels), mgrid%n_levels)

    mgrid%tp = 0
    do i = 0, mgrid%n_levels    
      mgrid%sp(i) = 1 + mgrid%tp
      mgrid%ep(i) = mgrid%tp + mgrid%level(i)%m%np
      mgrid%tp = mgrid%tp + mgrid%level(i)%m%np_part
      mgrid%ep_part(i) = mgrid%tp      
    end do

    call pop_sub()    
  end subroutine multigrid_init

  ! ---------------------------------------------------------
  ! creates the lookup tables to go between the coarse and fine meshes
  subroutine multigrid_get_transfer_tables(tt, fine, coarse)
    type(multigrid_level_t), intent(inout) :: tt
    type(mesh_t),            intent(in)    :: fine, coarse

    integer :: i, i1, i2, i4, i8, pt, ig
    integer :: ii, jj
    integer :: x(MAX_DIM), mod2(MAX_DIM)

    call push_sub('multigrid.multigrid_get_transfer_tables')

    tt%n_coarse = coarse%np
    ALLOCATE(tt%to_coarse(tt%n_coarse), tt%n_coarse)

    ! GENERATE THE TABLE TO MAP FROM THE FINE TO THE COARSE GRID
    do i = 1, tt%n_coarse
      ig = i
#ifdef HAVE_MPI
      ! translate to a global index of the coarse grid
      if(coarse%parallel_in_domains) ig = coarse%vp%local(ig - 1 + coarse%vp%xlocal(coarse%vp%partno))
#endif
      ! locate the equivalent global fine grid point
      ig = fine%Lxyz_inv(2*coarse%Lxyz(ig, 1), 2*coarse%Lxyz(ig, 2), 2*coarse%Lxyz(ig, 3))
#ifdef HAVE_MPI
      ! translate to a local number of the fine grid
      if(fine%parallel_in_domains) ig = vec_global2local(fine%vp, ig, fine%vp%partno)
#endif
      tt%to_coarse(i) = ig
    end do

    ! count
    tt%n_fine = fine%np
    ALLOCATE(tt%fine_i(tt%n_fine), tt%n_fine)

    tt%n_fine1 = 0
    tt%n_fine2 = 0
    tt%n_fine4 = 0
    tt%n_fine8 = 0
    do i = 1, tt%n_fine
      ig = i
#ifdef HAVE_MPI
      ! translate to a global index
      if(fine%parallel_in_domains) ig = fine%vp%local(ig - 1 + fine%vp%xlocal(fine%vp%partno))
#endif
      mod2 = mod(fine%Lxyz(ig, :), 2)
      
      pt = sum(abs(mod2(1:3)))
      
      select case(pt)
      case(0)
        tt%n_fine1 = tt%n_fine1 + 1
        tt%fine_i(i) = 1
      case(1)
        tt%n_fine2 = tt%n_fine2 + 1
        tt%fine_i(i) = 2
      case(2)
        tt%n_fine4 = tt%n_fine4 + 1
        tt%fine_i(i) = 4
      case(3)
        tt%n_fine8 = tt%n_fine8 + 1
        tt%fine_i(i) = 8
      end select
    end do
    
    ASSERT(tt%n_fine1 + tt%n_fine2 + tt%n_fine4 + tt%n_fine8 == tt%n_fine)

    ALLOCATE(tt%to_fine1(1, tt%n_fine1), 1*tt%n_fine1)
    ALLOCATE(tt%to_fine2(2, tt%n_fine2), 2*tt%n_fine2)
    ALLOCATE(tt%to_fine4(4, tt%n_fine4), 4*tt%n_fine4)
    ALLOCATE(tt%to_fine8(8, tt%n_fine8), 8*tt%n_fine8)

    ! and now build the tables
    i1 = 0;  i2 = 0;  i4 = 0;  i8 = 0
    do i = 1, fine%np
      ig = i
#ifdef HAVE_MPI
      ! translate to a global index
      if(fine%parallel_in_domains) ig = fine%vp%local(ig - 1 + fine%vp%xlocal(fine%vp%partno))
#endif
      x(1:3)    = fine%Lxyz(ig, 1:3)/2
      mod2(1:3) = mod(fine%Lxyz(ig, 1:3), 2)

      pt = sum(abs(mod2(1:3)))

      select case(pt)
      case(0)
        i1 = i1 + 1
        tt%to_fine1(1, i1) = coarse%Lxyz_inv(x(1), x(2), x(3))
        
      case(1)
        i2 = i2 + 1
        tt%to_fine2(1, i2) = coarse%Lxyz_inv(x(1)          , x(2)          , x(3)          )
        tt%to_fine2(2, i2) = coarse%Lxyz_inv(x(1) + mod2(1), x(2) + mod2(2), x(3) + mod2(3))
        
      case(2)
        i4 = i4 + 1
        tt%to_fine4(1, i4) = coarse%Lxyz_inv(x(1)          , x(2) + mod2(2), x(3) + mod2(3))
        tt%to_fine4(2, i4) = coarse%Lxyz_inv(x(1) + mod2(1), x(2)          , x(3) + mod2(3))
        tt%to_fine4(3, i4) = coarse%Lxyz_inv(x(1) + mod2(1), x(2) + mod2(2), x(3)          )
        tt%to_fine4(4, i4) = coarse%Lxyz_inv(x(1) + mod2(1), x(2) + mod2(2), x(3) + mod2(3))
        
      case(3)
        i8 = i8 + 1
        tt%to_fine8(1, i8) = coarse%Lxyz_inv(x(1)          , x(2)          , x(3)          )
        tt%to_fine8(2, i8) = coarse%Lxyz_inv(x(1) + mod2(1), x(2)          , x(3)          )
        tt%to_fine8(3, i8) = coarse%Lxyz_inv(x(1)          , x(2) + mod2(2), x(3)          )
        tt%to_fine8(4, i8) = coarse%Lxyz_inv(x(1)          , x(2)          , x(3) + mod2(3))
        tt%to_fine8(5, i8) = coarse%Lxyz_inv(x(1)          , x(2) + mod2(2), x(3) + mod2(3))
        tt%to_fine8(6, i8) = coarse%Lxyz_inv(x(1) + mod2(1), x(2)          , x(3) + mod2(3))
        tt%to_fine8(7, i8) = coarse%Lxyz_inv(x(1) + mod2(1), x(2) + mod2(2), x(3)          )
        tt%to_fine8(8, i8) = coarse%Lxyz_inv(x(1) + mod2(1), x(2) + mod2(2), x(3) + mod2(3))
        
      end select
      
    end do

    ASSERT(i1 == tt%n_fine1 .and. i2 == tt%n_fine2 .and. i4 == tt%n_fine4 .and. i8 == tt%n_fine8)

    ! translate to local points.
#ifdef HAVE_MPI
    if (coarse%parallel_in_domains) then

      do ii = 1, tt%n_fine1
        tt%to_fine1(1, ii) = vec_global2local(coarse%vp, tt%to_fine1(1, ii), coarse%vp%partno)
      end do

      do ii = 1, tt%n_fine2
        do jj = 1, 2
          tt%to_fine2(jj, ii) = vec_global2local(coarse%vp, tt%to_fine2(jj, ii), coarse%vp%partno)
        end do
      end do

      do ii = 1, tt%n_fine4
        do jj = 1, 4
          tt%to_fine4(jj, ii) = vec_global2local(coarse%vp, tt%to_fine4(jj, ii), coarse%vp%partno)
        end do
      end do

      do ii = 1, tt%n_fine8
        do jj = 1, 8
          tt%to_fine8(jj, ii) = vec_global2local(coarse%vp, tt%to_fine8(jj, ii), coarse%vp%partno)
        end do
      end do

    end if
#endif

    call pop_sub()
  end subroutine multigrid_get_transfer_tables

  !/*---------------------------------------------------------------------------------
  ! Creates a mesh that has twice the spacing betwen the points than the in mesh.
  ! This is used in the multi-grid routines
  !---------------------------------------------------------------------------------*/
  subroutine multigrid_mesh_half(geo, cv, mesh_in, mesh_out, stencil, np_stencil)
    type(geometry_t),   intent(in)  :: geo
    type(curvlinear_t), intent(in)  :: cv
    type(mesh_t),       intent(in)  :: mesh_in
    type(mesh_t),       intent(inout) :: mesh_out
    integer,            intent(in)  :: stencil(:, :)
    integer,            intent(in)  :: np_stencil

    call push_sub('multigrid.multigrid_mesh_half')

    nullify(mesh_out%lead_unit_cell)

    mesh_out%sb             => mesh_in%sb
    mesh_out%use_curvlinear =  mesh_in%use_curvlinear

    mesh_out%h(:)    = 2*mesh_in%h(:)
    mesh_out%nr(:,:) = mesh_in%nr(:,:)/2
    mesh_out%l(:)    = mesh_out%nr(2, :) - mesh_out%nr(1, :) + 1

    mesh_out%enlarge = mesh_in%enlarge
    
    call mesh_init_stage_2(mesh_out%sb, mesh_out, geo, cv, stencil, np_stencil)

    call pop_sub()
  end subroutine multigrid_mesh_half

  subroutine multigrid_mesh_double(geo, cv, mesh_in, mesh_out, stencil, np_stencil)
    type(geometry_t),   intent(in)  :: geo
    type(curvlinear_t), intent(in)  :: cv
    type(mesh_t),       intent(in)  :: mesh_in
    type(mesh_t),       intent(inout) :: mesh_out
    integer,            intent(in)  :: stencil(:, :)
    integer,            intent(in)  :: np_stencil

    call push_sub('multigrid.multigrid_mesh_double')

    nullify(mesh_out%lead_unit_cell)

    mesh_out%sb             => mesh_in%sb
    mesh_out%use_curvlinear =  mesh_in%use_curvlinear
    
    mesh_out%h(:)    = M_HALF*mesh_in%h(:)
    mesh_out%nr(:,:) = mesh_in%nr(:,:)*2
    mesh_out%l(:)    = mesh_out%nr(2, :) - mesh_out%nr(1, :) + 1
    
    mesh_out%enlarge = mesh_in%enlarge
    
    call mesh_init_stage_2(mesh_out%sb, mesh_out, geo, cv, stencil, np_stencil)

    call pop_sub()
  end subroutine multigrid_mesh_double

  ! ---------------------------------------------------------
  subroutine multigrid_end(mgrid)
    type(multigrid_t), intent(inout) :: mgrid

    integer :: i
    type(multigrid_level_t), pointer :: level

    call push_sub('multigrid.multigrid_end')

    deallocate(mgrid%sp)
    deallocate(mgrid%ep)
    deallocate(mgrid%ep_part)

    deallocate(mgrid%level(0)%fine_i)

    do i = 1, mgrid%n_levels
      level => mgrid%level(i)

      call derivatives_end(level%der)
      call mesh_end(level%m)
      deallocate(level%m, level%der)
      nullify   (level%m, level%der)

      deallocate(level%to_coarse, level%to_fine1, level%to_fine2, &
        level%to_fine4, level%to_fine8, level%fine_i)
      nullify   (level%to_coarse, level%to_fine1, level%to_fine2, &
        level%to_fine4, level%to_fine8, level%fine_i)
    end do

    deallocate(mgrid%level)

    call pop_sub()
  end subroutine multigrid_end

#include "undef.F90"
#include "real.F90"
#include "multigrid_inc.F90"

#include "undef.F90"
#include "complex.F90"
#include "multigrid_inc.F90"

end module multigrid_m

!! Local Variables:
!! mode: f90
!! coding: utf-8
!! End:
