!! Copyright (C) 2007 X. Andrade
!!
!! This program is free software; you can redistribute it and/or modify
!! it under the terms of the GNU General Public License as published by
!! the Free Software Foundation; either version 2, or (at your option)
!! any later version.
!!
!! This program is distributed in the hope that it will be useful,
!! but WITHOUT ANY WARRANTY; without even the implied warranty of
!! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!! GNU General Public License for more details.
!!
!! You should have received a copy of the GNU General Public License
!! along with this program; if not, write to the Free Software
!! Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
!! 02111-1307, USA.
!!
!! $Id: submesh.F90 2781 2007-03-23 10:58:32Z lorenzen $
 
#include "global.h"
  
module submesh_m
  use blas_m
  use global_m
  use lalg_basic_m
  use messages_m
  use mesh_m
  use mpi_m
  use par_vec_m
  use profiling_m
  use simul_box_m
  use solids_m

  implicit none
  private 

  public ::                 &
       submesh_t,           &
       submesh_null,        &
       submesh_init_sphere, &
       submesh_copy,        &
       submesh_get_inv,     &
       dsm_integrate,       &
       zsm_integrate,       &
       submesh_end

#ifdef HAVE_MPI
  public ::                   &
       submesh_comm_t,        &
       dsubmesh_comm_reduce,  &
       zsubmesh_comm_reduce,  &
       dsubmesh_comm_finish,  &
       zsubmesh_comm_finish
#endif

  type submesh_t
     integer               :: ns = -1        ! number of points inside the submesh
     integer               :: ns_part        ! number of points inside the submesh including ghost points
     integer               :: np_part
     integer,      pointer :: jxyz(:) => null()       ! index in the mesh of the points inside the sphere
     FLOAT,        pointer :: x(:,:)  => null()
     type(mesh_t), pointer :: mesh
     logical               :: has_points
#ifdef HAVE_MPI
     integer,      pointer :: psize(:) => null()      ! the number of points each processor holds
#endif
  end type submesh_t
  
  type submesh_comm_t
    private
    integer          :: nreq
    integer, pointer :: requests(:) => null()
    FLOAT,   pointer :: dallval(:, :) => null()
    CMPLX,   pointer :: zallval(:, :) => null()
  end type submesh_comm_t

  integer :: tagcounter = 0

contains
  
  subroutine submesh_null(sm)
    type(submesh_t), intent(out) :: sm

    sm%ns = -1
    sm%np_part = 0
    nullify(sm%jxyz)
    nullify(sm%x)
#ifdef HAVE_MPI
    nullify(sm%psize)
#endif

  end subroutine submesh_null

  subroutine submesh_init_sphere(this, sb, m, center, rc)
    type(submesh_t),      intent(out)  :: this
    type(simul_box_t),    intent(in)   :: sb
    type(mesh_t), target, intent(in)   :: m
    FLOAT,                intent(in)   :: center(1:MAX_DIM)
    FLOAT,                intent(in)   :: rc
    
    FLOAT :: r2, x(1:MAX_DIM)
    FLOAT, allocatable :: center_copies(:, :)
    integer :: icell, is, isb, ip, ix, iy, iz
    type(profile_t), save :: submesh_init_prof
    type(periodic_copy_t) :: pp
    integer, allocatable :: jxyz_inv(:)
    integer :: nmax(1:MAX_DIM), nmin(1:MAX_DIM)

    call push_sub('submesh.submesh_init_sphere')
    call profiling_in(submesh_init_prof, "SUBMESH_INIT")

    this%np_part = m%np_part
    this%mesh => m

    ! The spheres are generated differently for periodic coordinates,
    ! mainly for performance reasons.
    if(.not. simul_box_is_periodic(sb)) then 

      ALLOCATE(jxyz_inv(0:this%np_part), this%np_part+1)
      jxyz_inv(0:this%np_part) = 0
      
      nmin = 0
      nmax = 0

      ! get a cube of points that contains the sphere
      nmin(1:sb%dim) = int((center(1:sb%dim) - abs(rc) - sb%box_offset(1:sb%dim))/m%h(1:sb%dim)) - 1
      nmax(1:sb%dim) = int((center(1:sb%dim) + abs(rc) - sb%box_offset(1:sb%dim))/m%h(1:sb%dim)) + 1

      ! make sure that the cube is inside the grid
      nmin(1:MAX_DIM) = max(m%idx%nr(1, 1:MAX_DIM), nmin(1:MAX_DIM))
      nmax(1:MAX_DIM) = min(m%idx%nr(2, 1:MAX_DIM), nmax(1:MAX_DIM))

      ! Get the total number of points inside the sphere
      is = 0   ! this index counts inner points
      isb = 0  ! and this one boundary points
      do iz = nmin(3), nmax(3)
        do iy = nmin(2), nmax(2)
          do ix = nmin(1), nmax(1)
            ip = m%idx%Lxyz_inv(ix, iy, iz)
#if defined(HAVE_MPI)
            if(ip == 0) cycle
            if(m%parallel_in_domains) ip = vec_global2local(m%vp, ip, m%vp%partno)
#endif
            if(ip == 0) cycle
            r2 = sum((m%x(ip, 1:MAX_DIM) - center(1:MAX_DIM))**2)
            if(r2 <= rc**2) then
              if(ip > m%np) then
                ! boundary points are marked as negative values
                isb = isb + 1
                jxyz_inv(ip) = -isb
              else
                is = is + 1
                jxyz_inv(ip) = is
              end if
            end if
          end do
        end do
      end do
      this%ns = is
      this%ns_part = is + isb
      
      ALLOCATE(this%jxyz(this%ns_part), this%ns_part)
      ALLOCATE(this%x(this%ns_part, 0:MAX_DIM), this%ns_part * (MAX_DIM + 1))
      
      ! Generate the table and the positions
      do iz = nmin(3), nmax(3)
        do iy = nmin(2), nmax(2)
          do ix = nmin(1), nmax(1)
            ip = m%idx%Lxyz_inv(ix, iy, iz)
#if defined(HAVE_MPI)
            if(ip == 0) cycle
            if(m%parallel_in_domains) ip = vec_global2local(m%vp, ip, m%vp%partno)
#endif
            is = jxyz_inv(ip)
            if(is == 0) cycle
            if(is < 0) then
              ! it is a boundary point, move it to ns+1:ns_part range
              is = -is + this%ns
              jxyz_inv(ip) = is
            end if
            this%jxyz(is) = ip
            this%x(is, 1:MAX_DIM) = m%x(ip, 1:MAX_DIM) - center(1:MAX_DIM)
            this%x(is, 0) = sqrt(sum(this%x(is, 1:MAX_DIM)**2))
          end do
        end do
      end do

      SAFE_DEALLOCATE_A(jxyz_inv)

    ! This is the case for a periodic system
    else

      ! Get the total number of points inside the sphere considering
      ! replicas along PBCs

      ! this requires some optimization, but we are far from doing MD
      ! with PBC

      call periodic_copy_init(pp, sb, center(1:MAX_DIM), rc)
      
      ALLOCATE(center_copies(1:MAX_DIM, periodic_copy_num(pp)), MAX_DIM*periodic_copy_num(pp))

      do icell = 1, periodic_copy_num(pp)
        center_copies(1:MAX_DIM, icell) = periodic_copy_position(pp, sb, icell)
      end do

      is = 0
      do ip = 1, m%np_part
        do icell = 1, periodic_copy_num(pp)
          r2 = sum((m%x(ip, 1:MAX_DIM) - center_copies(1:MAX_DIM, icell))**2)
          if(r2 > rc**2 ) cycle
          is = is + 1
        end do
        if (ip == m%np) this%ns = is
      end do
      
      this%ns_part = is

      ALLOCATE(this%jxyz(this%ns_part), this%ns_part)
      ALLOCATE(this%x(this%ns_part, 0:MAX_DIM), this%ns_part * (MAX_DIM + 1))
            
      !iterate again to fill the tables
      is = 0
      do ip = 1, m%np_part
        do icell = 1, periodic_copy_num(pp)
          x(1:MAX_DIM) = m%x(ip, 1:MAX_DIM) - center_copies(1:MAX_DIM, icell)
          r2 = sum(x(1:MAX_DIM)**2)
          if(r2 > rc**2 ) cycle
          is = is + 1
          this%jxyz(is) = ip
          this%x(is, 0) = sqrt(r2)
          this%x(is, 1:MAX_DIM) = x(1:MAX_DIM)
         end do
      end do

      SAFE_DEALLOCATE_A(center_copies)
      
      call periodic_copy_end(pp)

    end if

    this%has_points = (this%ns > 0)

#ifdef HAVE_MPI
    if(m%parallel_in_domains) then
      ALLOCATE(this%psize(1:m%vp%npart), m%vp%npart)
      call MPI_Allgather(this%ns, 1, MPI_INTEGER, this%psize, 1, MPI_INTEGER, m%mpi_grp%comm, mpi_err)
    else
      nullify(this%psize)
    end if
#endif

    call profiling_out(submesh_init_prof)
    call pop_sub()

  end subroutine submesh_init_sphere

  subroutine submesh_end(this)
    type(submesh_t),   intent(inout)  :: this
    
    call push_sub('submesh.submesh_end')

#ifdef HAVE_MPI
    SAFE_DEALLOCATE_P(this%psize)
#endif

    if( this%ns /= -1 ) then
      nullify(this%mesh)
      this%ns = -1
      SAFE_DEALLOCATE_P(this%jxyz)
      SAFE_DEALLOCATE_P(this%x)
    end if

    call pop_sub()

  end subroutine submesh_end

  subroutine submesh_copy(sm_in, sm_out)
    type(submesh_t), target,  intent(in)   :: sm_in
    type(submesh_t),          intent(out)  :: sm_out

    call push_sub('submesh.submesh_copy')
    
    ASSERT(sm_out%ns == -1)

    sm_out%mesh => sm_in%mesh

    sm_out%ns = sm_in%ns
    sm_out%ns_part = sm_in%ns_part
    sm_out%np_part  = sm_in%np_part
    
    ALLOCATE(sm_out%jxyz(1:sm_out%ns_part), sm_out%ns_part)
    ALLOCATE(sm_out%x(1:sm_out%ns_part, 0:MAX_DIM), sm_out%ns_part*(MAX_DIM + 1))

    sm_out%jxyz(1:sm_out%ns_part) = sm_in%jxyz(1:sm_in%ns_part)
    sm_out%x(1:sm_out%ns_part, 0:MAX_DIM) = sm_in%x(1:sm_in%ns_part, 0:MAX_DIM)

    call pop_sub()

  end subroutine submesh_copy

  subroutine submesh_get_inv(this, jxyz_inv)
    type(submesh_t),      intent(in)   :: this
    integer,              intent(out)  :: jxyz_inv(:)

    integer :: is

    jxyz_inv(1:this%np_part) = 0

    forall (is = 1:this%ns) jxyz_inv(this%jxyz(is)) = is

  end subroutine submesh_get_inv

#include "undef.F90"
#include "real.F90"
#include "submesh_inc.F90"

#include "undef.F90"
#include "complex.F90"
#include "submesh_inc.F90"

end module submesh_m

!! Local Variables:
!! mode: f90
!! coding: utf-8
!! End:
