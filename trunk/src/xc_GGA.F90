!! Copyright (C) 2002 M. Marques, A. Castro, A. Rubio, G. Bertsch
!!
!! This program is free software; you can redistribute it and/or modify
!! it under the terms of the GNU General Public License as published by
!! the Free Software Foundation; either version 2, or (at your option)
!! any later version.
!!
!! This program is distributed in the hope that it will be useful,
!! but WITHOUT ANY WARRANTY; without even the implied warranty of
!! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!! GNU General Public License for more details.
!!
!! You should have received a copy of the GNU General Public License
!! along with this program; if not, write to the Free Software
!! Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
!! 02111-1307, USA.

subroutine xc_get_gga(xcs, m, f_der, st, vxc, ex, ec, ip, qtot)
  type(xc_type),     intent(IN)    :: xcs
  type(mesh_type),   intent(IN)    :: m
  type(f_der_type),  intent(inout) :: f_der
  type(states_type), intent(IN)    :: st
  FLOAT,             intent(out)   :: vxc(m%np, st%d%nspin), ex, ec
  FLOAT,             intent(in)    :: ip, qtot
  
  FLOAT :: e, dpol, dtot, vpol, r

  FLOAT, allocatable :: d(:, :), lpot(:, :)
  FLOAT, allocatable :: rhoplus(:), rhominus(:)
  FLOAT, allocatable :: grhoplus(:, :), grhominus(:, :)
  FLOAT, allocatable :: vlocaldedgd(:,:,:), vlocaldedgd1(:,:)

  FLOAT :: locald(st%d%spin_channels), localgd(3, st%d%spin_channels), &
       localdedd(st%d%spin_channels)

  integer :: i, is, spin_channels
  integer :: ixc

  call push_sub('xc_gga')

  spin_channels = st%d%spin_channels

  allocate(d(m%np, st%d%nspin), lpot(m%np, spin_channels))
  allocate(rhoplus(m%np), rhominus(m%np))
  allocate(grhoplus(m%np, 3), grhominus(m%np, 3))
  allocate(vlocaldedgd(m%np, 3, spin_channels), vlocaldedgd1(3, spin_channels))

  ! Store in local variables d the density matrix
  ! (in the global reference system).
  call lalg_copy(m%np, st%d%nspin, st%rho(:,:), d(:,:))

  ! If the pseudo has non-local core corrections, add the core charge
  ! (to the diagonal of the density matrix)
  if(xcs%nlcc) then
    do is = 1, spin_channels
      call lalg_axpy(m%np, M_ONE/spin_channels, st%rho_core(:), d(:, is))
    end do
  end if

  do i = 1, m%np
    select case(st%d%ispin)
    case(UNPOLARIZED)
      rhoplus(i) = max(d(i, 1), M_ZERO)
    case(SPIN_POLARIZED)
      rhoplus(i)  = max(d(i, 1), M_ZERO)
      rhominus(i) = max(d(i, 2), M_ZERO)
    case(SPINORS)
      dtot = d(i, 1) + d(i, 2)
      dpol = sqrt( (d(i, 1)-d(i, 2))**2 + M_FOUR*(d(i, 3)**2+d(i, 4)**2) )
      rhoplus(i)  = max(M_HALF*(dtot+dpol), M_ZERO)
      rhominus(i) = max(M_HALF*(dtot-dpol), M_ZERO)
    end select
  enddo

  grhoplus = M_ZERO; grhominus = M_ZERO
  call df_gradient(f_der, rhoplus, grhoplus)
  if(st%d%ispin > UNPOLARIZED) call df_gradient(f_der, rhominus, grhominus)

  lpot        = M_ZERO
  vlocaldedgd = M_ZERO
  space_loop: do i = 1, m%np

    locald(1) = rhoplus(i)
    localgd(1:3, 1) = grhoplus(i, 1:3)
    if(st%d%ispin > UNPOLARIZED) then
      locald(2) = rhominus(i)
      localgd(1:3, 2) = grhominus(i, 1:3)
    endif

    ! Calculate the potential/gradient density in local reference frame.
    functl_loop: do ixc = 1, XC_GGA_N
      if(.not.btest(xcs%gga_functl, ixc)) cycle

      ! call xc library
      if(ixc == XC_GGA_XC_LB - 100) then
        call mesh_r(m, i, r)
        call xc_gga_lb(xcs%gga_conf(ixc), locald(1), localgd(1,1), &
           r, ip, qtot, localdedd(1))

        e = M_ZERO
        vlocaldedgd1(:,:) = M_ZERO
      else
        call xc_gga(xcs%gga_conf(ixc), locald(1), localgd(1,1), &
           e, localdedd(1), vlocaldedgd1(1,1))
      end if
      
      if(ixc == XC_GGA_X_PBE-100) then
        ex = ex + sum(d(i,:)) * e * m%vol_pp(i)
      else
        ec = ec + sum(d(i,:)) * e * m%vol_pp(i)
      end if
      lpot(i, :) = lpot(i, :) + localdedd(:)
      vlocaldedgd(i,:,:) = vlocaldedgd(i,:,:) + vlocaldedgd1(:,:)
      
    end do functl_loop

  end do space_loop

  ! We now add substract the divergence of the functional derivative of fxc with respect to
  ! the gradient of the density.
  do is = 1, spin_channels
    call df_divergence(f_der, vlocaldedgd(:,:,is), rhoplus(:))
    call lalg_axpy(m%np, -M_ONE, rhoplus(:), lpot(:, is))
  end do
      
  ! And now we rotate back (do not need the rotation matrix for this).
  if(st%d%ispin == SPINORS) then
    do i = 1, m%np
      dtot = d(i, 1) + d(i, 2)
      dpol = sqrt( (d(i, 1)-d(i, 2))**2 + M_FOUR*(d(i, 3)**2+d(i, 4)**2) )
      vpol = (lpot(i, 1) - lpot(i, 2))*(d(i, 1) - d(i, 2)) / (dpol + tiny)
      vxc(i, 1) = vxc(i, 1) + M_HALF*(lpot(i, 1) + lpot(i, 2) + vpol)
      vxc(i, 2) = vxc(i, 2) + M_HALF*(lpot(i, 1) + lpot(i, 2) - vpol)
      vxc(i, 3) = vxc(i, 3) + (lpot(i, 1) - lpot(i, 2))*d(i, 3) / (dpol + tiny)
      vxc(i, 4) = vxc(i, 4) + (lpot(i, 1) - lpot(i, 2))*d(i, 4) / (dpol + tiny)
    enddo
  else
    vxc = vxc + lpot
  endif
  
  ! If LB94, we have to calculate the energy 
  ! Levy-Perdew relation (PRA 32, 2010 (1985))
  !if(iand(xcs%functl, X_FUNC_GGA_LB94).ne.0) then
  !  do is = 1, st%d%nspin
  !    call df_gradient(f_der, vxc(:, is), grhoplus)
  !    do i = 1, m%np
  !      ex = ex - d(i, is) * sum(m%x(i,:)*grhoplus(i,:)) * m%vol_pp(i)
  !    end do
  !  end do
  !end if

  deallocate(d, lpot, rhoplus, rhominus, grhoplus, grhominus, vlocaldedgd, vlocaldedgd1)
  call pop_sub()
end subroutine xc_get_gga
