!! Copyright (C) 2002-2006 M. Marques, A. Castro, A. Rubio, G. Bertsch
!!
!! This program is free software; you can redistribute it and/or modify
!! it under the terms of the GNU General Public License as published by
!! the Free Software Foundation; either version 2, or (at your option)
!! any later version.
!!
!! This program is distributed in the hope that it will be useful,
!! but WITHOUT ANY WARRANTY; without even the implied warranty of
!! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!! GNU General Public License for more details.
!!
!! You should have received a copy of the GNU General Public License
!! along with this program; if not, write to the Free Software
!! Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
!! 02111-1307, USA.
!!
!! $Id$

#include "global.h"

module scf_m
  use datasets_m
  use eigen_solver_m
  use external_pot_m
  use functions_m
  use geometry_m
  use global_m
  use grid_m
  use hamiltonian_m
  use io_m
  use lcao_m
  use loct_m
  use loct_parser_m
  use magnetic_m
  use mesh_function_m
  use mesh_m
  use messages_m
  use mix_m
  use mpi_m
  use mpi_lib_m
  use h_sys_output_m
  use profiling_m
  use restart_m
  use simul_box_m
  use solids_m
  use states_m
  use units_m
  use v_ks_m
  use varinfo_m

  implicit none

  private
  public ::             &
    scf_t,              &
    scf_init,           &
    scf_run,            &
    scf_end

  integer, parameter :: &
    MIXPOT  = 1,        &
    MIXDENS = 2

  integer, public, parameter :: &
    VERB_NO      = 0,   &
    VERB_COMPACT = 1,   &
    VERB_FULL    = 3
  
  type scf_t      ! some variables used for the scf cycle
    integer :: max_iter   ! maximum number of scf iterations

    FLOAT :: lmm_r

    ! several convergence criteria
    FLOAT :: conv_abs_dens, conv_rel_dens, conv_abs_ev, conv_rel_ev, conv_abs_force, conv_rel_force
    FLOAT :: abs_dens, rel_dens, abs_ev, rel_ev, abs_force, rel_force

    integer :: what2mix
    logical :: lcao_restricted

    type(mix_t) :: smix
    type(eigen_solver_t) :: eigens
  end type scf_t


contains

  ! ---------------------------------------------------------
  subroutine scf_init(gr, geo, scf, st, h)
    type(grid_t),        intent(inout) :: gr
    type(geometry_t),    intent(in)    :: geo
    type(scf_t),         intent(inout) :: scf
    type(states_t),      intent(in)    :: st
    type(hamiltonian_t), intent(in)    :: h

    integer :: dim
    FLOAT :: rmin

    call push_sub('scf.scf_init')

    !%Variable MaximumIter
    !%Type integer
    !%Default 200
    !%Section SCF::Convergence
    !%Description
    !% Maximum number of SCF iterations. The code will stop even if convergence
    !% has not been achieved. <tt>0</tt> means unlimited.
    !%End
    call loct_parse_int  (check_inp('MaximumIter'), 200, scf%max_iter)

    !%Variable ConvAbsDens
    !%Type float
    !%Default 1e-5
    !%Section SCF::Convergence
    !%Description
    !% Absolute convergence of the density: 
    !% <math>\epsilon = \int {\rm d}^3r \vert \rho^{out}(\bf r) -\rho^{inp}(\bf r) \vert</math>.
    !% A zero value means do not use this criterion.
    !%End
    call loct_parse_float(check_inp('ConvAbsDens'), CNST(1e-3), scf%conv_abs_dens)

    !%Variable ConvRelDens
    !%Type float
    !%Default 0.0
    !%Section SCF::Convergence
    !%Description
    !% Relative convergence of the density:
    !% <math>\epsilon = {1\over N} ConvAbsDens</math>.
    !% <i>N</i> is the total number of electrons in the problem.
    !% A zero value means do not use this criterion.
    !%End
    call loct_parse_float(check_inp('ConvRelDens'), M_ZERO, scf%conv_rel_dens)

    !%Variable ConvAbsEv
    !%Type float
    !%Default 0.0
    !%Section SCF::Convergence
    !%Description
    !% Absolute convergence of the eigenvalues:
    !% <math>\epsilon = \sum_{j=1}^{N_{occ}} \vert \epsilon_j^{out}-\epsilon_j^{inp}\vert</math>.
    !% A zero value means do not use this criterion.
    !%End
    call loct_parse_float(check_inp('ConvAbsEv'), M_ZERO, scf%conv_abs_ev)
    scf%conv_abs_ev = scf%conv_abs_ev * units_inp%energy%factor

    !%Variable ConvRelEv
    !%Type float
    !%Default 0.0
    !%Section SCF::Convergence
    !%Description
    !% Relative convergence of the eigenvalues:
    !% <math>\epsilon = {1 \over E} \sum_{j=1}^{N_{occ}} \vert \epsilon_j^{out}-\epsilon_j^{inp}\vert</math>.
    !% <i>E</i> is the sum of the eigenvalues. A zero value means do not use this criterion.
    !%End
    call loct_parse_float(check_inp('ConvRelEv'), M_ZERO, scf%conv_rel_ev)

    !%Variable ConvAbsForce
    !%Type float
    !%Default 0.0
    !%Section SCF::Convergence
    !%Description
    !% Absolute convergence of the forces: 
    !% maximum variation of any component of the ionic forces in consecutive iterations.
    !% A zero value means do not use this criterion.
    !%End
    call loct_parse_float(check_inp('ConvAbsForce'), M_ZERO, scf%conv_abs_force)
    scf%conv_abs_force = scf%conv_abs_force * units_inp%force%factor

    !%Variable ConvRelForce
    !%Type float
    !%Default 0.0
    !%Section SCF::Convergence
    !%Description
    !% Relative convergence of the forces:
    !% absolute convergence divided by the modulus of the force on the ion where the force changes the most.
    !% A zero value means do not use this criterion.
    !%End
    call loct_parse_float(check_inp('ConvRelForce'), M_ZERO, scf%conv_rel_force)

    if(scf%max_iter <= 0 .and. &
      scf%conv_abs_dens <= M_ZERO .and. scf%conv_rel_dens <= M_ZERO .and. &
      scf%conv_abs_ev <= M_ZERO .and. scf%conv_rel_ev <= M_ZERO .and. &
      scf%conv_abs_force <= M_ZERO .and. scf%conv_rel_force <= M_ZERO) then
      message(1) = "Input: Not all convergence criteria can be <= 0"
      message(2) = "Please set one of the following:"
      message(3) = "MaximumIter | ConvAbsDens | ConvRelDens | ConvAbsEv | ConvRelEv | ConvAbsForce | ConvRelForce"
      call write_fatal(3)
    end if

    if(scf%max_iter <= 0) scf%max_iter = huge(scf%max_iter)

    !%Variable What2Mix
    !%Type integer
    !%Default density
    !%Section SCF::Mixing
    !%Description
    !% Selects what should be mixed during the SCF cycle.
    !%Option potential 1
    !% The Kohn-Sham potential
    !%Option density 2
    !% The density
    !%End
    call loct_parse_int(check_inp('What2Mix'), MIXDENS, scf%what2mix)
    if(.not.varinfo_valid_option('What2Mix', scf%what2mix)) call input_error('What2Mix')
    call messages_print_var_option(stdout, "What2Mix", scf%what2mix, "what to mix during SCF cycles")

    if (scf%what2mix == MIXPOT.and.h%theory_level==INDEPENDENT_PARTICLES) then
      message(1) = "Input: Cannot mix the potential with non-interacting particles."
      call write_fatal(1)
    end if

    ! Handle mixing now...
    dim = 1
    if (h%d%cdft) dim = 1 + NDIM
    call mix_init(scf%smix, gr%m%np, dim, st%d%nspin)
    call mesh_init_mesh_aux(gr%m)

    ! now the eigen solver stuff
    call eigen_solver_init(gr, scf%eigens, st, 25)

    !%Variable SCFinLCAO
    !%Type logical
    !%Default no
    !%Section SCF
    !%Description
    !% Performs all the SCF cycle restricting the calculation to the LCAO subspace.
    !% This may be useful for systems with convergence problems (first do a 
    !% calculation within the LCAO subspace, then restart from that point for
    !% an unrestricted calculation).
    !%End
    call loct_parse_logical(check_inp('SCFinLCAO'), .false., scf%lcao_restricted)
    if(scf%lcao_restricted) then
      message(1) = 'Info: SCF restricted to LCAO subspace'
      call write_info(1)
    end if

    call geometry_min_distance(geo, rmin)
    if(geo%natoms == 1) rmin = CNST(100.0)
    call loct_parse_float(check_inp('LocalMagneticMomentsSphereRadius'), rmin*M_HALF/units_inp%length%factor, scf%lmm_r)
    scf%lmm_r = scf%lmm_r * units_inp%length%factor

    call pop_sub()
  end subroutine scf_init


  ! ---------------------------------------------------------
  subroutine scf_end(scf)
    type(scf_t), intent(inout) :: scf

    call push_sub('scf.scf_end')

    call eigen_solver_end(scf%eigens)
    call mix_end(scf%smix)

    call pop_sub()
  end subroutine scf_end


  ! ---------------------------------------------------------
  subroutine scf_run(scf, gr, geo, st, ks, h, outp, gs_run, verbosity)
    type(scf_t),         intent(inout) :: scf
    type(grid_t),        intent(inout) :: gr
    type(geometry_t),    intent(inout) :: geo
    type(states_t),      intent(inout) :: st
    type(v_ks_t),        intent(inout) :: ks
    type(hamiltonian_t), intent(inout) :: h
    type(h_sys_output_t),intent(in)    :: outp
    logical, optional,   intent(in)    :: gs_run
    integer, optional,   intent(in)    :: verbosity 

    type(lcao_t) :: lcao_data

    integer :: iter, is, idim, iatom, nspin, dim, err
    FLOAT :: evsum_out, evsum_in, forcetmp
    real(8) :: etime, itime
    FLOAT, allocatable :: rhoout(:,:,:), rhoin(:,:,:), rhonew(:,:,:)
    FLOAT, allocatable :: vout(:,:,:), vin(:,:,:), vnew(:,:,:)
    FLOAT, allocatable :: forceout(:,:), forcein(:,:), forcediff(:), tmp(:)
    character(len=8) :: dirname
    logical :: finish, forced_finish, gs_run_
    integer :: verbosity_

    call push_sub('scf.scf_run')

    if(present(gs_run)) then 
      gs_run_ = gs_run
    else 
      gs_run_ = .true.
    end if
    
    verbosity_ = VERB_FULL
    if(present(verbosity)) verbosity_ = verbosity

    if(scf%lcao_restricted) then
      call lcao_init(gr, geo, lcao_data, st, h)
      if(.not.lcao_data%state == 1) then
        message(1) = 'Nothing to do'
        call write_fatal(1)
      end if
    end if

    nspin = st%d%nspin

    dim = 1
    if (h%d%cdft) dim = 1 + NDIM

    ALLOCATE(rhoout(NP, dim, nspin), NP*dim*nspin)
    ALLOCATE(rhoin (NP, dim, nspin), NP*dim*nspin)

    rhoin(1:NP, 1, 1:nspin) = st%rho(1:NP, 1:nspin)
    rhoout = M_ZERO
    if (st%d%cdft) then
      rhoin(1:NP, 2:dim, 1:nspin) = st%j(1:NP, 1:NDIM, 1:nspin)
    end if

    if (scf%what2mix == MIXPOT) then
      ALLOCATE(vout(NP, dim, nspin), NP*dim*nspin)
      ALLOCATE( vin(NP, dim, nspin), NP*dim*nspin)
      ALLOCATE(vnew(NP, dim, nspin), NP*dim*nspin)

      vin(1:NP, 1, 1:nspin) = h%vhxc(1:NP, 1:nspin)
      vout = M_ZERO
      if (st%d%cdft) vin(1:NP, 2:dim, 1:nspin) = h%axc(1:NP, 1:NDIM, 1:nspin)
    else
      ALLOCATE(rhonew(NP, dim, nspin), NP*dim*nspin)
    end if
    evsum_in = states_eigenvalues_sum(st)

    ! allocate and compute forces only if they are used as convergence criteria
    if (scf%conv_abs_force > M_ZERO .or. scf%conv_rel_force > M_ZERO) then
      ALLOCATE(forcein(geo%natoms, NDIM), geo%natoms*NDIM)
      ALLOCATE(forceout(geo%natoms, NDIM), geo%natoms*NDIM)
      ALLOCATE(forcediff(NDIM), NDIM)
      call epot_forces(gr, geo, h%ep, st)
      do iatom = 1, geo%natoms
        forcein(iatom,1:NDIM) = geo%atom(iatom)%f(1:NDIM)
      end do
    endif

    if ( verbosity_ /= VERB_NO ) then
      write(message(1),'(a)') 'Info: Starting SCF iteration'
      call write_info(1)
    end if

    ! SCF cycle
    itime = loct_clock()
    do iter = 1, scf%max_iter
      call profiling_in(C_PROFILING_SCF_CYCLE)

      if(scf%lcao_restricted) then
        call lcao_wf(lcao_data, st, gr, h)
      else
        scf%eigens%converged = 0
        call eigen_solver_run(scf%eigens, gr, st, h, iter)
      end if

      ! occupations
      call states_fermi(st, gr%m)

      ! compute output density, potential (if needed) and eigenvalues sum
      call states_calc_dens(st, NP, st%rho)
      rhoout(1:NP, 1, 1:nspin) = st%rho(1:NP, 1:nspin)
      if (h%d%cdft) then
        call calc_physical_current(gr, st, st%j)
        rhoout(1:NP, 2:dim, 1:nspin) = st%j(1:NP, 1:NDIM, 1:nspin)
      end if
      if (scf%what2mix == MIXPOT) then
        call v_ks_calc(gr, ks, h, st)
        vout(1:NP, 1, 1:nspin) = h%vhxc(1:NP, 1:nspin)
        if (h%d%cdft) vout(1:NP, 2:dim, 1:nspin) = h%axc(1:NP, 1:NDIM, 1:nspin)
      end if
      evsum_out = states_eigenvalues_sum(st)

      ! recalculate total energy
      call hamiltonian_energy(h, gr, geo, st, iunit = 0)

      ! compute convergence criteria
      scf%abs_dens = M_ZERO
      ALLOCATE(tmp(NP), NP)
      do is = 1, nspin
        do idim = 1, dim
          tmp = abs(rhoin(1:NP, idim, is) - rhoout(1:NP, idim, is))
          scf%abs_dens = scf%abs_dens + dmf_integrate(gr%m, tmp)
        end do
      end do
      deallocate(tmp)

      ! compute forces only if they are used as convergence criteria
      if (scf%conv_abs_force > M_ZERO .or. scf%conv_rel_force > M_ZERO) then
        call epot_forces(gr, geo, h%ep, st)
        scf%abs_force = M_ZERO
        scf%rel_force = M_ZERO
        do iatom = 1, geo%natoms
          forceout(iatom,1:NDIM) = geo%atom(iatom)%f(1:NDIM)
          forcediff(1:NDIM) = abs( forceout(iatom,1:NDIM) - forcein(iatom,1:NDIM) )
          forcetmp = maxval( forcediff )
          if ( forcetmp > scf%abs_force ) then
            scf%abs_force = forcetmp
            scf%rel_force = scf%abs_force / sqrt( dot_product( forcediff, forcediff ) )
          end if
        end do
      end if

      scf%abs_dens = sqrt(scf%abs_dens)
      scf%rel_dens = scf%abs_dens / st%qtot
      scf%abs_ev = abs(evsum_out - evsum_in)
      scf%rel_ev = scf%abs_ev / abs(evsum_out)

      ! are we finished?
      finish = &
        (scf%conv_abs_dens  > M_ZERO .and. scf%abs_dens  <= scf%conv_abs_dens)  .or. &
        (scf%conv_rel_dens  > M_ZERO .and. scf%rel_dens  <= scf%conv_rel_dens)  .or. &
        (scf%conv_abs_force > M_ZERO .and. scf%abs_force <= scf%conv_abs_force) .or. &
        (scf%conv_rel_force > M_ZERO .and. scf%rel_force <= scf%conv_rel_force) .or. &
        (scf%conv_abs_ev    > M_ZERO .and. scf%abs_ev    <= scf%conv_abs_ev)    .or. &
        (scf%conv_rel_ev    > M_ZERO .and. scf%rel_ev    <= scf%conv_rel_ev)

      etime = loct_clock() - itime
      itime = etime + itime
      call scf_write_iter

      ! mixing
      select case (scf%what2mix)
      case (MIXDENS)
        ! mix input and output densities and compute new potential
        call dmixing(scf%smix, iter, rhoin, rhoout, rhonew, dmf_dotp_aux)
        st%rho(1:NP,1:nspin) = rhonew(1:NP, 1, 1:nspin)
        if (h%d%cdft) st%j(1:NP,1:NDIM,1:nspin) = rhonew(1:NP, 2:dim, 1:nspin)
        call v_ks_calc(gr, ks, h, st)
      case (MIXPOT)
        ! mix input and output potentials
        call dmixing(scf%smix, iter, vin, vout, vnew, dmf_dotp_aux)
        h%vhxc(1:NP, 1:nspin) = vnew(1:NP, 1, 1:nspin)
        if (h%d%cdft) h%axc(1:NP, 1:NDIM, 1:nspin) = vnew(1:NP, 2:dim, 1:nspin)
      end select

      ! Are we asked to stop? (Whenever Fortran is ready for signals, this should go away)
      forced_finish = clean_stop()

      if(gs_run_) then 
        ! save restart information
        if(finish.or.(modulo(iter, 3) == 0).or.iter==scf%max_iter.or.forced_finish) then
          call restart_write(trim(tmpdir)//'gs', st, gr, err, iter=iter)
          if(err.ne.0) then
            message(1) = 'Unsuccesfull write of "'//trim(tmpdir)//'gs"'
            call write_fatal(1)
          end if
        end if
      end if

      if(finish) then
        if(verbosity_ >= VERB_COMPACT) then
          write(message(1), '(a, i4, a)') 'Info: SCF converged in ', iter, ' iterations'
          write(message(2), '(a)')        '' 
          call write_info(2)
        end if
        if(scf%lcao_restricted) call lcao_end(lcao_data, st%nst)
        call profiling_out(C_PROFILING_SCF_CYCLE)
        exit
      end if

      if(outp%duringscf .and. gs_run_) then
        write(dirname,'(a,i4.4)') "scf.",iter
        call h_sys_output_all(outp, gr, geo, st, h, dirname)
      end if

      ! save information for the next iteration
      rhoin(1:NP, 1, 1:nspin) = st%rho(1:NP, 1:nspin)
      if (h%d%cdft) rhoin(1:NP, 2:dim, 1:nspin) = st%j(1:NP, 1:NDIM, 1:nspin)
      if (scf%what2mix == MIXPOT) then
        vin(1:NP, 1, 1:nspin) = h%vhxc(1:NP, 1:nspin)
        if (h%d%cdft) vin(1:NP, 2:dim, 1:nspin) = h%axc(1:NP, 1:NDIM, 1:nspin)
      end if
      evsum_in = evsum_out
      if (scf%conv_abs_force > M_ZERO .or. scf%conv_rel_force > M_ZERO) then
        forcein(1:geo%natoms, 1:NDIM) = forceout(1:geo%natoms, 1:NDIM)
      end if

      if(forced_finish) then
        call profiling_out(C_PROFILING_SCF_CYCLE)
        exit
      end if

      ! check if debug mode should be enabled or disabled on the fly
      call io_debug_on_the_fly()


      call profiling_out(C_PROFILING_SCF_CYCLE)
    end do

    if (scf%what2mix == MIXPOT) then
      call v_ks_calc(gr, ks, h, st)
      deallocate(vout, vin, vnew)
    else
      deallocate(rhonew)
    end if
    deallocate(rhoout, rhoin)

    if(.not.finish) then
      message(1) = 'SCF *not* converged!'
      call write_warning(1)
    end if

    ! calculate forces
    call epot_forces(gr, geo, h%ep, st)

    if (st%wfs_type == M_REAL) then
      call dstates_calc_momentum(gr, st)
    else
      call zstates_calc_momentum(gr, st)
    end if

    if(gs_run_) then 
      ! output final information
      call scf_write_static("static", "info")
      call h_sys_output_all(outp, gr, geo, st, h, "static")
    end if

    if(simul_box_is_periodic(gr%sb).and.st%d%nik > st%d%nspin) then
      call states_write_bands('static', st%nst, st, gr%sb)
      call states_write_dos  ('static', st)
      call states_write_fermi_energy('static', st, gr%m, gr%sb)
      call states_degeneracy_matrix(st)
    end if

    call pop_sub()

  contains


    ! ---------------------------------------------------------
    subroutine scf_write_iter
      character(len=50) :: str

      call push_sub('scf.scf_write_iter')

      if ( verbosity_ == VERB_FULL ) then

        write(str, '(a,i5)') 'SCF CYCLE ITER #' ,iter
        call messages_print_stress(stdout, trim(str))

        write(message(1),'(a,es15.8,2(a,es9.2))') ' etot = ', h%etot/units_out%energy%factor, &
             ' abs_ev   = ', scf%abs_ev/units_out%energy%factor, ' rel_ev   = ', scf%rel_ev
        write(message(2),'(23x,2(a,es9.2))') &
             ' abs_dens = ', scf%abs_dens, ' rel_dens = ', scf%rel_dens
        ! write info about forces only if they are used as convergence criteria
        if (scf%conv_abs_force > M_ZERO .or. scf%conv_rel_force > M_ZERO) then
          write(message(3),'(23x,2(a,es9.2))') &
               ' abs_force   = ', scf%abs_force/units_out%force%factor, ' rel_force   = ', scf%rel_force
          call write_info(3)
        else
          call write_info(2)
        end if

        if(.not.scf%lcao_restricted) then
          write(message(1),'(a,i6)') 'Matrix vector products: ', scf%eigens%matvec
          write(message(2),'(a,i6)') 'Converged eigenvectors: ', scf%eigens%converged
          call write_info(2)
          call states_write_eigenvalues(stdout, st%nst, st, gr%sb, scf%eigens%diff)
        else
          call states_write_eigenvalues(stdout, st%nst, st, gr%sb)
        end if

        if(st%d%ispin > UNPOLARIZED) then
          call write_magnetic_moments(stdout, gr%m, st)
        end if

        write(message(1),'(a)') ''
        write(message(2),'(a,f14.2)') 'Elapsed time for SCF step:', etime
        call write_info(2)

        call messages_print_stress(stdout)
        
      end if

      if ( verbosity_ == VERB_COMPACT ) then
        ! write info about forces only if they are used as convergence criteria
        if (scf%conv_abs_force > M_ZERO .or. scf%conv_rel_force > M_ZERO) then
        write(message(1),'(a,i4,a,es15.8, 2(a,es9.2), a, f7.1, a)') &
             'iter ', iter, &
             ' : etot ', h%etot/units_out%energy%factor, &
             ' : abs_dens', scf%abs_dens, &
             ' : abs_force', scf%abs_force/units_out%force%factor, &
             ' : etime ', etime, 's'
        else
        write(message(1),'(a,i4,a,es15.8, a,es9.2, a, f7.1, a)') &
             'iter ', iter, &
             ' : etot ', h%etot/units_out%energy%factor, &
             ' : abs_dens', scf%abs_dens, &
             ' : etime ', etime, 's'
        end if
        call write_info(1)
      end if

      call pop_sub()
    end subroutine scf_write_iter


    ! ---------------------------------------------------------
    subroutine scf_write_static(dir, fname)
      character(len=*), intent(in) :: dir, fname

      FLOAT :: e_dip(4, st%d%nspin), n_dip(MAX_DIM)
      FLOAT, parameter :: ATOMIC_TO_DEBYE = CNST(2.5417462)
      integer :: iunit, i, j

      call push_sub('scf.scf_write_static')

      if(mpi_grp_is_root(mpi_world)) then ! this the absolute master writes
        call io_mkdir(dir)
        iunit = io_open(trim(dir) // "/" // trim(fname), action='write')

        call grid_write_info(gr, iunit)

        if(simul_box_is_periodic(gr%sb)) then
          call kpoints_write_info(st%d, iunit)
          write(iunit,'(1x)')
        end if

        call v_ks_write_info(ks, iunit)

        ! scf information
        if(finish) then
          write(iunit, '(a, i4, a)')'SCF converged in ', iter, ' iterations'
        else
          write(iunit, '(a)') 'SCF *not* converged!'
        end if
        write(iunit, '(1x)')

        call states_write_eigenvalues(iunit, st%nst, st, gr%sb)
        write(iunit, '(1x)')

        write(iunit, '(a)') 'Energy:'
      else
        iunit = 0
      end if

      call hamiltonian_energy(h, gr, geo, st, iunit, full = .true.)

      if(mpi_grp_is_root(mpi_world)) write(iunit, '(1x)')
      if(st%d%ispin > UNPOLARIZED) then
        call write_magnetic_moments(iunit, gr%m, st)
        if(mpi_grp_is_root(mpi_world)) write(iunit, '(1x)')
      end if


      ! Next lines of code calculate the dipole of the molecule, summing the electronic and
      ! ionic contributions.
      do j = 1, st%d%nspin
        call df_multipoles(gr%m, st%rho(:,j), 1, e_dip(:, j))
      end do
      do j = 1, 3
        e_dip(j+1, 1) = sum(e_dip(j+1, :))
      end do
      call geometry_dipole(geo, n_dip)
      n_dip(1:NDIM) = n_dip(1:NDIM) - e_dip(2:NDIM+1, 1)

      if(mpi_grp_is_root(mpi_world)) then
        write(iunit, '(3a)') 'Dipole [', trim(units_out%length%abbrev), ']:                    [Debye]'
        do j = 1, NDIM
          write(iunit, '(6x,a,i1,a,es14.5,3x,2es14.5)') '<x', j, '> = ', n_dip(j) / units_out%length%factor, &
            n_dip(j)*ATOMIC_TO_DEBYE
        end do
        write(iunit,'(a)')
      end if

      ! Output expecation values of the momentum operator
      call write_momentum(iunit)

      ! Next is the angular momentum. Only applies to 2D and 3D.
      if(NDIM.ne.1) call write_angular_momentum(iunit)

      if(mpi_grp_is_root(mpi_world)) then
        write(iunit, '(a)') 'Convergence:'
        write(iunit, '(6x, a, es14.8,a,es14.8,a)') 'abs_dens = ', scf%abs_dens, &
          ' (', scf%conv_abs_dens, ')'
        write(iunit, '(6x, a, es14.8,a,es14.8,a)') 'rel_dens = ', scf%rel_dens, &
          ' (', scf%conv_rel_dens, ')'
        write(iunit, '(6x, a, es14.8,a,es14.8,4a)') 'abs_ev = ', scf%abs_ev, &
          ' (', scf%conv_abs_ev / units_out%energy%factor, ')', &
          ' [',  trim(units_out%energy%abbrev), ']'
        write(iunit, '(6x, a, es14.8,a,es14.8,a)') 'rel_ev = ', scf%rel_ev, &
          ' (', scf%conv_rel_ev, ')'
        write(iunit,'(1x)')

        write(iunit,'(3a)') 'Forces on the ions [', trim(units_out%force%abbrev), "]"
        write(iunit,'(a,10x,14x,a,14x,a,14x,a)') ' Ion','x','y','z'
        do i = 1, geo%natoms
          write(iunit,'(i4,a10,3f15.6)') i, trim(geo%atom(i)%spec%label), &
            geo%atom(i)%f(:) / units_out%force%factor
        end do

        call io_close(iunit)
      end if

      call pop_sub()
    end subroutine scf_write_static


    ! ---------------------------------------------------------
    subroutine write_angular_momentum(iunit)
      integer, intent(in) :: iunit

      integer            :: ik, ist, ns, j
      character(len=80)  :: tmp_str(MAX_DIM), cspin
      FLOAT              :: angular(3), lsquare, o
      FLOAT, allocatable :: ang(:, :, :), ang2(:, :)
#if defined(HAVE_MPI)
      integer            :: tmp
      FLOAT              :: lang(1:st%lnst)
#endif

      call push_sub('scf.write_angular_momentum')

      ns = 1
      if(st%d%nspin == 2) ns = 2

      if(mpi_grp_is_root(mpi_world)) then
        write(iunit,'(a)') 'Angular Momentum of the KS states [dimensionless]:'
        if (st%d%nik > ns) then
          message(1) = 'Kpoints [' // trim(units_out%length%abbrev) // '^-1]'
          call write_info(1, iunit)
        end if
      end if

      ALLOCATE(ang (1:st%nst, st%d%nik, 3), st%nst*st%d%nik*3)
      ALLOCATE(ang2(1:st%nst, st%d%nik), st%nst*st%d%nik)
      do ik = 1, st%d%nik
        do ist = st%st_start, st%st_end
          if (st%wfs_type == M_REAL) then
            call dstates_angular_momentum(gr, st%dpsi(:, :, ist, ik), ang(ist, ik, :), ang2(ist, ik))
          else
            call zstates_angular_momentum(gr, st%zpsi(:, :, ist, ik), ang(ist, ik, :), ang2(ist, ik))
          end if
        end do
      end do
      angular(1) =  states_eigenvalues_sum(st, ang(st%st_start:st%st_end, :, 1))
      angular(2) =  states_eigenvalues_sum(st, ang(st%st_start:st%st_end, :, 2))
      angular(3) =  states_eigenvalues_sum(st, ang(st%st_start:st%st_end, :, 3))
      lsquare    =  states_eigenvalues_sum(st, ang2(st%st_start:st%st_end, :))

      do ik = 1, st%d%nik, ns
        if(st%d%nik > ns) then
          write(message(1), '(a,i4,3(a,f12.6),a)') '#k =',ik,', k = (',  &
            st%d%kpoints(1, ik)*units_out%length%factor, ',',            &
            st%d%kpoints(2, ik)*units_out%length%factor, ',',            &
            st%d%kpoints(3, ik)*units_out%length%factor, ')'
          call write_info(1, iunit)
        end if

        ! Exchange ang and ang2.
#if defined(HAVE_MPI)
        if(st%parallel_in_states) then
          do j = 1, 3
            lang = ang(st%st_start:st%st_end, ik, j)
            call lmpi_gen_alltoallv(st%lnst, lang, tmp, ang(:, ik, j), st%mpi_grp)
          end do
          lang = ang2(st%st_start:st%st_end, ik)
          call lmpi_gen_alltoallv(st%lnst, lang, tmp, ang2(:, ik), st%mpi_grp)
        end if
#endif
        write(message(1), '(a4,1x,a5,4a12,4x,a12,1x)')       &
          '#st',' Spin','        <Lx>', '        <Ly>', '        <Lz>', '        <L2>', 'Occupation '
        call write_info(1, iunit)

        if(mpi_grp_is_root(mpi_world)) then
          do j = 1, st%nst
            do is = 0, ns-1

              if(j > st%nst) then
                o = M_ZERO
              else
                o = st%occ(j, ik+is)
              end if

              if(is.eq.0) cspin = 'up'
              if(is.eq.1) cspin = 'dn'
              if(st%d%ispin.eq.UNPOLARIZED.or.st%d%ispin.eq.SPINORS) cspin = '--'

              write(tmp_str(1), '(i4,3x,a2)') j, trim(cspin)
              write(tmp_str(2), '(1x,4f12.6,3x,f12.6)') &
                ang(j, ik+is, 1:3), ang2(j, ik+is), o
              message(1) = trim(tmp_str(1))//trim(tmp_str(2))
              call write_info(1, iunit)
            end do
          end do
        end if
        write(message(1),'(a)') ''
        call write_info(1, iunit)

      end do

      write(message(1),'(a)') 'Total Angular Momentum L [dimensionless]'
      write(message(2),'(10x,4f12.6)') angular(1:3), lsquare
      call write_info(2, iunit)

      deallocate(ang, ang2)

      call pop_sub()
    end subroutine write_angular_momentum


    ! ---------------------------------------------------------
    subroutine write_momentum(iunit)
      integer,        intent(in) :: iunit

      integer           :: ik, j, is, ns, iunit2
      character(len=80) :: cspin
      FLOAT             :: o

      call push_sub('scf.write_momentum')   

      ns = 1
      if(st%d%nspin == 2) ns = 2

      write(message(1),'(a)') 'Momentum of the KS states [a.u.]:'
      call write_info(1, iunit)      
      if (st%d%nik > ns) then
        message(1) = 'Kpoints [' // trim(units_out%length%abbrev) // '^-1]'
        call write_info(1, iunit)
      end if

      do ik = 1, st%d%nik, ns
        if(st%d%nik > ns) then
          write(message(1), '(a,i4,3(a,f12.6),a)') '#k =',ik,', k = (',  &
            st%d%kpoints(1, ik)*units_out%length%factor, ',',            &
            st%d%kpoints(2, ik)*units_out%length%factor, ',',            &
            st%d%kpoints(3, ik)*units_out%length%factor, ')'
          call write_info(1, iunit)
        end if

        write(message(1), '(a4,1x,a5,3a12,4x,a12,1x)')       &
          '#st',' Spin','       <px>', '        <py>', '        <pz>', 'Occupation '
        call write_info(1, iunit)

        do j = 1, st%nst
          do is = 0, ns-1

            if(j > st%nst) then
              o = M_ZERO
            else
              o = st%occ(j, ik+is)
            end if
            
            if(is.eq.0) cspin = 'up'
            if(is.eq.1) cspin = 'dn'
            if(st%d%ispin.eq.UNPOLARIZED.or.st%d%ispin.eq.SPINORS) cspin = '--'

            write(message(1), '(i4,3x,a2,1x,3f12.6,3x,f12.6)')        &
                j, trim(cspin), st%momentum(:, j, ik), o
            call write_info(1, iunit)

          end do
        end do
        
        write(message(1),'(a)') ''
        call write_info(1, iunit)      

      end do

      ! also write to disk for further processing
      iunit2 = io_open('static/momentum', action='write')

      do ik = 1, st%d%nik
        do j = 1, st%nst
          write(message(1), '(2i4,3x, 3f12.6,3x,f12.6)') &
            j, ik, st%momentum(:, j, ik), st%occ(j, ik)
          call write_info(1, iunit2)
        end do
      end do

      call io_close(iunit2)

      call pop_sub()
    end subroutine write_momentum


    ! ---------------------------------------------------------
    subroutine write_magnetic_moments(iunit, m, st)
      integer,        intent(in) :: iunit
      type(mesh_t),   intent(in) :: m
      type(states_t), intent(in) :: st

      integer :: i
      FLOAT :: mm(MAX_DIM)
      FLOAT, allocatable :: lmm(:,:)

      call push_sub('scf.write_magnetic_moments')

      call magnetic_moment(m, st, st%rho, mm)
      ALLOCATE(lmm(3, geo%natoms), 3*geo%natoms)
      call magnetic_local_moments(m, st, geo, st%rho, scf%lmm_r, lmm)

      if(mpi_grp_is_root(mpi_world)) then

        write(iunit, '(a)') 'Total Magnetic Moment:'
        if(st%d%ispin == SPIN_POLARIZED) then ! collinear spin
          write(iunit, '(a,f10.6)') ' mz = ', mm(3)
        else if(st%d%ispin == SPINORS) then ! non-collinear
          write(iunit, '(1x,3(a,f10.6,3x))') 'mx = ',mm(1),'my = ',mm(2),'mz = ',mm(3)
        end if

        write(iunit, '(a,a,a,f7.3,a)') 'Local Magnetic Moments (sphere radius [', &
             trim(units_out%length%abbrev),'] = ', scf%lmm_r/units_out%length%factor, '):'
        if(st%d%ispin == SPIN_POLARIZED) then ! collinear spin
          write(iunit,'(a,6x,14x,a)') ' Ion','mz'
          do i = 1, geo%natoms
            write(iunit,'(i4,a10,f15.6)') i, trim(geo%atom(i)%spec%label), lmm(3, i)
          end do
        else if(st%d%ispin == SPINORS) then ! non-collinear
          write(iunit,'(a,8x,13x,a,13x,a,13x,a)') ' Ion','mx','my','mz'
          do i = 1, geo%natoms
            write(iunit,'(i4,a10,3f15.6)') i, trim(geo%atom(i)%spec%label), lmm(1, i), lmm(2, i), lmm(3, i)
          end do
        end if

      end if
      
      deallocate(lmm)

      call pop_sub()
    end subroutine write_magnetic_moments

  end subroutine scf_run

end module scf_m


!! Local Variables:
!! mode: f90
!! coding: utf-8
!! End:
