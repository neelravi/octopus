!! Copyright (C) 2002-2006 M. Marques, A. Castro, A. Rubio, G. Bertsch
!!
!! This program is free software; you can redistribute it and/or modify
!! it under the terms of the GNU General Public License as published by
!! the Free Software Foundation; either version 2, or (at your option)
!! any later version.
!!
!! This program is distributed in the hope that it will be useful,
!! but WITHOUT ANY WARRANTY; without even the implied warranty of
!! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!! GNU General Public License for more details.
!!
!! You should have received a copy of the GNU General Public License
!! along with this program; if not, write to the Free Software
!! Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
!! 02111-1307, USA.
!!
!! $Id$

! ---------------------------------------------------------
! conjugate-gradients method.
subroutine X(eigen_solver_cg2) (gr, st, h, pre, tol, niter, converged, diff, reorder, verbose)
  type(grid_t),        intent(inout) :: gr
  type(states_t),      intent(inout) :: st
  type(hamiltonian_t), intent(inout) :: h
  type(preconditioner_t), intent(in) :: pre
  FLOAT,               intent(in)    :: tol
  integer,             intent(inout) :: niter
  integer,             intent(inout) :: converged
  FLOAT,     optional, intent(out)   :: diff(1:st%nst,1:st%d%nik)
  logical,   optional, intent(in)    :: reorder
  logical,   optional, intent(in)    :: verbose

  R_TYPE, allocatable :: h_psi(:,:), g(:,:), g0(:,:), &
    cg(:,:), ppsi(:,:)

  R_DOUBLE :: es(2), a0, b0, gg, gg0, gg1, gamma, theta, norma
  real(8) :: cg0, e0, res
  integer  :: ik, p, iter, maxter, conv, conv_, idim, ns
  logical  :: reord = .true., verbose_

  call push_sub('eigen_cg.eigen_solver_cg2')

  verbose_ = .false.; if(present(verbose)) verbose_ = verbose
  if(verbose_) then
    call messages_print_stress(stdout, "CG Info")
    message(1) = "Diagonalization with the conjugate gradients algorithm."
    write(message(2),'(a,e8.2)') '  Tolerance: ',tol
    write(message(3),'(a,i6)')   '  Maximum number of iterations per eigenstate:', niter
    message(4) = ''
    call write_info(4)
  end if

  if(present(reorder)) reord = reorder
  conv_ = 0
  maxter = niter
  niter = 0

  ALLOCATE(h_psi(NP_PART, st%d%dim), NP_PART*st%d%dim)
  ALLOCATE( ppsi(NP_PART, st%d%dim), NP_PART*st%d%dim)
  ALLOCATE(    g(NP_PART, st%d%dim), NP_PART*st%d%dim)
  ALLOCATE(   g0(NP_PART, st%d%dim), NP_PART*st%d%dim)
  ALLOCATE(   cg(NP_PART, st%d%dim), NP_PART*st%d%dim)

  do idim = 1, st%d%dim
    !$omp parallel workshare
    cg(1:NP, idim) = R_TOTYPE(M_ZERO)
    cg(NP+1:NP_PART, idim) = R_TOTYPE(M_ZERO)
    !$omp end parallel workshare
  end do

  ! Set the diff to zero, since it is intent(out)
  if(present(diff)) then 
    diff(1:st%nst,1:st%d%nik) = M_ZERO
  end if

  ! Start of main loop, which runs over all the eigenvectors searched
  ns = 1
  if(st%d%nspin == 2) ns = 2
  ik_loop: do ik = 1, st%d%nik
    conv = converged

    if(verbose_) then
      if(st%d%nik > ns) then
	write(message(1), '(a,i4,3(a,f12.6),a)') '#k =',ik,', k = (',  &
	  st%d%kpoints(1, ik)*units_out%length%factor, ',',            &
	  st%d%kpoints(2, ik)*units_out%length%factor, ',',            &
	  st%d%kpoints(3, ik)*units_out%length%factor, ')'
	call write_info(1)
      end if
    end if
    
    eigenfunction_loop : do p = conv + 1, st%nst

      if(verbose_) then
        write(message(2),'(a,i4,a)') ' Eigenstate # ',p,':'
      end if

      ! Orthogonalize starting eigenfunctions to those already calculated...
      call X(states_gram_schmidt_full)(st, p, gr%m, st%d%dim, st%X(psi)(:, 1:st%d%dim, 1:p, ik), start=p)

      ! Calculate starting gradient: |hpsi> = H|psi>
      call X(Hpsi)(h, gr, st%X(psi)(:,:, p, ik) , h_psi, p, ik)

      ! Calculates starting eigenvalue: e(p) = <psi(p)|H|psi>
      st%eigenval(p, ik) = R_REAL(X(states_dotp) (gr%m, st%d%dim, st%X(psi)(:,:, p, ik), h_psi))

      ! Starts iteration for this band
      iter_loop: do iter = 1, maxter

        ! inverse preconditioner....
        call  X(preconditioner_apply)(pre, gr, h, h_psi(:,:), g(:,:))
        call  X(preconditioner_apply)(pre, gr, h, st%X(psi)(:,:, p, ik), ppsi(:,:))

        es(1) = X(states_dotp) (gr%m, st%d%dim, st%X(psi)(:,:, p, ik), g)
        es(2) = X(states_dotp) (gr%m, st%d%dim, st%X(psi)(:,:, p, ik), ppsi)
        es(1) = es(1)/es(2)

        !this does: g(1:NP, 1:st%d%dim) = g(1:NP, 1:st%d%dim) - es(1)*ppsi(1:NP, 1:st%d%dim)
        do idim = 1, st%d%dim
          call lalg_axpy(NP, R_TOPREC(-es(1)), ppsi(:, idim), g(:, idim))
        end do

        ! Orthogonalize to lowest eigenvalues (already calculated)
        if(p > 1) call X(states_gram_schmidt)(st, p - 1, gr%m, st%d%dim, st%X(psi)(:, :, :, ik), g, &
                                              normalize = .false.)

        if(iter .ne. 1) gg1 = X(states_dotp) (gr%m, st%d%dim, g, g0)

        ! Approximate inverse preconditioner...
        call  X(preconditioner_apply)(pre, gr, h, g(:,:), g0(:,:))

        gg = X(states_dotp) (gr%m, st%d%dim, g, g0)
        if( abs(gg) < M_EPSILON ) then
          conv = conv + 1
          st%eigenval(p, ik) = es(1)
          res = sqrt(abs(gg))
          exit
        end if

        ! Starting or following iterations...
        if(iter .eq. 1) then
          gg0 = gg

          !this does: cg(1:NP, 1:st%d%dim) = g(1:NP, 1:st%d%dim)
          do idim = 1, st%d%dim
            call lalg_copy(NP, g(:,idim), cg(:, idim))
          end do
        else
          !gamma = gg/gg0        ! (Fletcher-Reeves)
          gamma = (gg - gg1)/gg0   ! (Polack-Ribiere)
          gg0 = gg

          !$omp parallel workshare
          cg(1:NP, 1:st%d%dim) = gamma*cg(1:NP, 1:st%d%dim) + g(1:NP, 1:st%d%dim)
          !$omp end parallel workshare

          norma = gamma*cg0*sin(theta)

          !this does: cg(1:NP, 1:st%d%dim) = cg(1:NP, 1:st%d%dim) - norma * st%X(psi)(1:NP, 1:st%d%dim, p, ik)
          do idim = 1, st%d%dim 
            call lalg_axpy(NP, R_TOPREC(-norma), st%X(psi)(:, idim, p, ik), cg(:, idim))
          end do
        end if

        ! cg contains now the conjugate gradient
        cg0 = X(states_nrm2) (gr%m, st%d%dim, cg(:,:))
        call X(Hpsi) (h, gr, cg, ppsi, p, ik)

        ! Line minimization.
        a0 = X(states_dotp) (gr%m, st%d%dim, st%X(psi)(:,:, p, ik), ppsi)
        a0 = M_TWO * a0 / cg0
        b0 = X(states_dotp) (gr%m, st%d%dim, cg(:,:), ppsi)
        b0 = b0/cg0**2
        e0 = st%eigenval(p, ik)
        theta = atan(R_REAL(a0/(e0 - b0)))/M_TWO
        es(1) = ((e0-b0)*cos(M_TWO*theta) + a0*sin(M_TWO*theta) + e0 + b0) / M_TWO
        es(2) =(-(e0-b0)*cos(M_TWO*theta) - a0*sin(M_TWO*theta) + e0 + b0) / M_TWO

        ! Choose the minimum solutions.
        if (R_REAL(es(2)) < R_REAL(es(1))) then
          theta = theta + M_PI/M_TWO
        end if
        st%eigenval(p, ik) = min(R_REAL(es(1)), R_REAL(es(2)))

        ! Upgrade psi...
        a0 = cos(theta)
        b0 = sin(theta)/cg0

        !$omp parallel workshare
        st%X(psi)(1:NP, 1:st%d%dim, p, ik) = a0*st%X(psi)(1:NP, 1:st%d%dim, p, ik) + b0*cg(1:NP, 1:st%d%dim)
        h_psi(1:NP, 1:st%d%dim) = a0*h_psi(1:NP, 1:st%d%dim) + b0*ppsi(1:NP, 1:st%d%dim)
        !$omp end parallel workshare

        res = X(states_residue)(gr%m, st%d%dim, h_psi, st%eigenval(p, ik), st%X(psi)(:, :, p, ik))
        ! Test convergence.
        if(res < tol) then
          conv = conv + 1
          exit iter_loop
        end if

      end do iter_loop

      if(verbose_) then
        if(res<tol) then
          write(message(1),'(a,a,i5,a,e8.2,a)') trim(message(2)),"     converged. Iterations:", iter, '   [Res = ',res,']'
        else
          write(message(1),'(a,a,i5,a,e8.2,a)') trim(message(2))," not converged. Iterations:", iter, '   [Res = ',res,']'
        end if
        call write_info(1)
      end if

      niter = niter + iter + 1

      if(present(diff)) then
        diff(p, ik) = res
      end if

      if(p>1 .and. reord) call sort(st%eigenval(1:p, ik), st%X(psi)(1:NP, :, 1:p, ik))

    end do eigenfunction_loop

    conv_ = conv_ + conv

  end do ik_loop

  converged = conv_
  ! Deallocation of variables
  deallocate(h_psi, g, g0, cg, ppsi)

  if(verbose_) call messages_print_stress(stdout)

  call pop_sub()
end subroutine X(eigen_solver_cg2)

! ---------------------------------------------------------
! The algorithm is essentially taken from Jiang et al. Phys. Rev. B 68, 165337 (2003).
subroutine X(eigen_solver_cg2_new) (gr, st, h, tol, niter, converged, diff, reorder, verbose)
  type(grid_t),        intent(inout) :: gr
  type(states_t),      intent(inout) :: st
  type(hamiltonian_t), intent(inout) :: h
  FLOAT,               intent(in)    :: tol
  integer,             intent(inout) :: niter
  integer,             intent(inout) :: converged
  FLOAT,     optional, intent(out)   :: diff(1:st%nst,1:st%d%nik)
  logical,   optional, intent(in)    :: reorder
  logical,   optional, intent(in)    :: verbose

  integer :: nik, nst, dim, ik, ist, maxter, i, conv, conv_
  logical :: verbose_, reorder_
  R_TYPE, allocatable :: psi(:,:), phi(:, :), hpsi(:, :), hcgp(:, :), cg(:, :), sd(:, :), cgp(:, :)
  FLOAT :: ctheta, stheta, ctheta2, stheta2, mu, lambda, dump, &
           gamma, sol(2), alpha, beta, theta, theta2, res ! Could be complex?
  logical, allocatable :: orthogonal(:)

  call push_sub('eigen_cg.eigen_solver_cg2_new')

  verbose_ = .false.; if(present(verbose)) verbose_ = verbose
  reorder_ = .true. ; if(present(reorder)) reorder_ = reorder
  if(verbose_) then
    call messages_print_stress(stdout, "CG Info")
    message(1) = "Diagonalization with the conjugate gradients algorithm [new]."
    write(message(2),'(a,e8.2)') '  Tolerance: ', tol
    write(message(3),'(a,i6)')   '  Maximum number of iterations per eigenstate:', niter
    message(4) = ""
    call write_info(4)
  end if

  dim = st%d%dim; nik = st%d%nik; nst = st%nst

  conv_ = 0
  maxter = niter
  niter = 0

  ALLOCATE( phi(NP_PART, dim), NP_PART*dim)
  ALLOCATE( psi(NP_PART, dim), NP_PART*dim)
  ALLOCATE(hpsi(NP_PART, dim), NP_PART*dim)
  ALLOCATE(  cg(NP_PART, dim), NP_PART*dim)
  ALLOCATE(hcgp(NP_PART, dim), NP_PART*dim)
  ALLOCATE(  sd(NP_PART, dim), NP_PART*dim)
  ALLOCATE( cgp(NP_PART, dim), NP_PART*dim)
  ALLOCATE(orthogonal(nst), nst)

  psi(1:NP_PART, 1:dim) = M_ZERO
  cgp(1:NP_PART, 1:dim) = M_ZERO

  ! Set the diff to zero, since it is intent(out)
  if(present(diff)) then 
    diff(1:st%nst,1:st%d%nik) = M_ZERO
  end if

  kpoints: do ik = 1, nik
    conv = converged
    states: do ist = conv + 1, nst

      ! Orthogonalize starting eigenfunctions to those already calculated...
      call X(states_gram_schmidt_full)(st, ist, gr%m, dim, st%X(psi)(:, 1:dim, 1:ist, ik), start=ist)
      psi(1:NP, 1:dim) = st%X(psi)(1:NP, 1:dim, ist, ik)

      ! Calculate starting gradient: |hpsi> = H|psi>
      call X(Hpsi)(h, gr, psi, phi, ist, ik); niter = niter + 1

      ! Initial settings for scalar variables.
      ctheta = M_ONE
      stheta = M_ZERO
      mu     = M_ONE

      ! Initialize to zero the vector variables.
      hcgp = R_TOTYPE(M_ZERO)
      cg   = R_TOTYPE(M_ZERO)

      orthogonal = .false.

      band: do i = 1, maxter - 1 ! One operation has already been made.

         if(mod(i, 5).eq.0) orthogonal = .false.

         ! Get H|psi> (through the linear formula)
         phi(1:NP, 1:dim) = ctheta*phi(1:NP, 1:dim) + stheta*hcgp(1:NP, 1:dim)

         ! lambda = <psi|H|psi> = <psi|phi>
         lambda = X(states_dotp)(gr%m, dim, psi, phi)

         ! Check convergence
         res = X(states_residue)(gr%m, dim, phi, lambda, psi)
         if(present(diff)) diff(ist, ik) = res
         if(res < tol) then
           conv = conv + 1
           exit band
         end if

         ! Get steepest descent vector
         sd(1:NP, 1:dim) = lambda*psi(1:NP, 1:dim) - phi(1:NP, 1:dim)
         if(ist > 1) call X(states_gram_schmidt)(st, ist - 1, gr%m, dim, st%X(psi)(:, :, :, ik), sd, &
                                                 normalize = .false., mask = orthogonal)

         ! Get conjugate-gradient vector
         gamma = X(states_dotp)(gr%m, dim, sd, sd)/mu
         mu    = X(states_dotp)(gr%m, dim, sd, sd)
         cg(1:NP, 1:dim) = sd(1:NP, 1:dim) + gamma*cg(1:NP, 1:dim)

         !
         dump = X(states_dotp)(gr%m, dim, psi, cg)
         cgp(1:NP, 1:dim) = cg(1:NP, 1:dim) - dump*psi(1:NP, 1:dim)
         dump = sqrt(X(states_dotp)(gr%m, dim, cgp, cgp))
         cgp(1:NP, 1:dim) = cgp(1:NP, 1:dim)/dump

         call X(Hpsi)(h, gr, cgp, hcgp, ist, ik); niter = niter + 1

         alpha = - lambda + X(states_dotp)(gr%m, dim, cgp, hcgp)
         beta  = M_TWO*X(states_dotp)(gr%m, dim, cgp, phi)
         theta = M_HALF*atan(-beta/alpha)
         ctheta = cos(theta)
         stheta = sin(theta)

         ! This checks wether we are picking the maximum, or the minimum.
         theta2 = theta + M_PI/M_TWO
         ctheta2 = cos(theta2)
         stheta2 = sin(theta2)
         sol(1) = lambda + stheta**2*alpha + beta*stheta*ctheta
         sol(2) = lambda + stheta2**2*alpha + beta*stheta2*ctheta2

         if(sol(2) < sol(1)) then
            theta = theta2
            stheta = stheta2
            ctheta = ctheta2
         end if

         psi(1:NP, 1:dim) = ctheta*psi(1:NP, 1:dim) + stheta*cgp(1:NP, 1:dim)

      end do band

      st%X(psi)(1:NP, 1:dim, ist, ik) = psi(1:NP, 1:dim)
      st%eigenval(ist, ik) = lambda

      if(verbose_) then
        if(res<tol) then
          write(message(1),'(a,a,i5,a,e8.2,a)') trim(message(2)),"     converged. Iterations:", i, '   [Res = ',res,']'
        else
          write(message(1),'(a,a,i5,a,e8.2,a)') trim(message(2))," not converged. Iterations:", i, '   [Res = ',res,']'
        end if
        call write_info(1)
      end if

    end do states

    ! Reordering.
    if(reorder_) call sort(st%eigenval(1:nst, ik), st%X(psi)(:, :, 1:nst, ik))

    conv_ = conv_ + conv

  end do kpoints

  converged = conv_

  deallocate(phi, psi, hpsi, cg, hcgp, sd, cgp, orthogonal)
  if(verbose_) call messages_print_stress(stdout)

  call pop_sub()
end subroutine X(eigen_solver_cg2_new)

!! Local Variables:
!! mode: f90
!! coding: utf-8
!! End:
