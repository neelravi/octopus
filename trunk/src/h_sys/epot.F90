!! Copyright (C) 2002-2006 M. Marques, A. Castro, A. Rubio, G. Bertsch
!!
!! This program is free software; you can redistribute it and/or modify
!! it under the terms of the GNU General Public License as published by
!! the Free Software Foundation; either version 2, or (at your option)
!! any later version.
!!
!! This program is distributed in the hope that it will be useful,
!! but WITHOUT ANY WARRANTY; without even the implied warranty of
!! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!! GNU General Public License for more details.
!!
!! You should have received a copy of the GNU General Public License
!! along with this program; if not, write to the Free Software
!! Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
!! 02111-1307, USA.
!!
!! $Id$

#include "global.h"

module external_pot_m
  use datasets_m
  use double_grid_m
  use functions_m
  use global_m
  use grid_m
  use io_m
  use lib_oct_parser_m
  use lib_oct_gsl_spline_m
  use magnetic_m
  use mesh_function_m
  use mesh_m
  use messages_m
  use multicomm_m
  use simul_box_m
  use units_m
  use logrid_m
  use poisson_cutoffs_m
  use ps_m
  use specie_m
  use specie_pot_m
  use solids_m
  use geometry_m
  use states_m
  use submesh_m
  use lasers_m
  use profiling_m
  use mpi_m
  use mpi_debug_m
  use varinfo_m
  use poisson_m
  use projector_m

  implicit none

  private
  public ::                    &
    epot_t,                    &
    epot_init,                 &
    epot_end,                  &
    epot_generate,             &
    epot_generate_gauge_field, &
    epot_forces,               &
    ion_ion_energy,            &
    dconmut_vnl_r,             &
    zconmut_vnl_r,             &
    build_local_part_in_real_space


  type epot_t
    ! Classic charges:
    integer :: classic_pot        ! How to include the classic charges
    FLOAT, pointer :: vclassic(:) ! We use it to store the potential of the classic charges

    ! Ions
    FLOAT,       pointer :: vpsl(:)       ! the local part of the pseudopotentials
    integer :: nvnl                       ! number of nonlocal operators
    type(projector_t), pointer :: p(:)    ! non-local projectors
    integer, pointer :: atomproj(:,:)     ! the range of projectors
                                          ! corresponding to an atom
    ! External e-m fields
    integer :: no_lasers                   ! number of laser pulses used
    type(laser_t), pointer :: lasers(:)    ! lasers stuff
    FLOAT, pointer :: E_field(:)           ! static electric field
    FLOAT, pointer :: v_static(:)          ! static scalar potential
    FLOAT, pointer :: B_field(:)           ! static magnetic field
    FLOAT, pointer :: A_static(:,:)        ! static vector potential
    FLOAT, pointer :: A_gauge(:)           ! gauge vector potential
    FLOAT, pointer :: A_gauge_dot(:)       ! dA_gauge/dt
    FLOAT, pointer :: A_gauge_ddot(:)      ! d^2A_gauge/dt^2
    logical :: with_gauge_field            ! true if A_gauge(:) is used
    
    ! The gyromagnetic ratio (-2.0 for the electron, but different if we treat
    ! *effective* electrons in a quantum dot. It affects the spin Zeeman term.
    FLOAT :: gyromagnetic_ratio
#ifdef HAVE_MPI
    logical :: parallel_generate
#endif
  end type epot_t

contains

  ! ---------------------------------------------------------
  subroutine epot_init(ep, gr, geo)
    type(epot_t), intent(out) :: ep
    type(grid_t), intent(in)  :: gr
    type(geometry_t), intent(inout) :: geo

    integer :: i, nvl
    C_POINTER :: blk
    FLOAT, allocatable :: x(:)
    logical :: filter

    call push_sub('epot.epot_init')

    call loct_parse_logical(check_inp('FilterPotentials'), .false., filter)

    if(filter) then
      message(1) = 'Info: filtering the potentials.'
      call write_info(1)
    end if
    
    do i = 1, geo%nspecies
      call specie_pot_init(geo%specie(i), gr, filter)
    end do

    ! Local part of the pseudopotentials
    ALLOCATE(ep%vpsl(NP), NP)
    !$omp parallel workshare
    ep%vpsl(1:NP) = M_ZERO
    !$omp end parallel workshare

    ep%classic_pot = 0
    if(geo%ncatoms > 0) then

      !%Variable ClassicPotential
      !%Type integer
      !%Default 0
      !%Section Hamiltonian
      !%Description
      !% If <tt>true</tt>, add to the external potential the potential generated by 
      !% the point charges read from the PDB input (see <tt>PBDCoordinates</tt>).
      !%End
      call loct_parse_int(check_inp('ClassicPotential'), 0, ep%classic_pot)
      if(ep%classic_pot > 0) then
        message(1) = 'Info: generating classic external potential'
        call write_info(1)

        ALLOCATE(ep%Vclassic(NP), NP)
        call epot_generate_classic(ep, gr%m, geo)
      end if
    end if

    ! lasers
    call laser_init(ep%no_lasers, ep%lasers, gr%m)
    if(ep%no_lasers>0.and.mpi_grp_is_root(mpi_world)) then
      message(1) = 'Info: Lasers'
      call write_info(1)

      call laser_write_info(ep%no_lasers, ep%lasers, stdout)
    end if

    call obsolete_variable('UserDefinedTDPotential', 'TDExternalFields')

    !%Variable StaticElectricField
    !%Type block
    !%Section Hamiltonian
    !%Description
    !% A static constant electrical field may be added to the usual Hamiltonian,
    !% by setting the block StaticElectricField. Atomic units will be assumed
    !% always for its magnitude, regardless of the unit system specified.
    !% The three possible components of the block (which should only have one
    !% line) are the three components of the electrical field vector.
    !%End
    nullify(ep%E_field, ep%v_static)
    if(loct_parse_block(check_inp('StaticElectricField'), blk)==0) then
      ALLOCATE(ep%E_field(NDIM), NDIM)
      do i = 1, NDIM
        call loct_parse_block_float(blk, 0, i-1, ep%E_field(i))
      end do
      call loct_parse_block_end(blk)
      
      ! Compute the scalar potential
      ALLOCATE(ep%v_static(NP), NP)
      do i = 1, NP
        ep%v_static(i) = sum(gr%m%x(i,:)*ep%E_field(:))
      end do
    end if

    !%Variable StaticMagneticField
    !%Type block
    !%Section Hamiltonian
    !%Description
    !% A static constant magnetic field may be added to the usual Hamiltonian,
    !% by setting the block StaticMagneticField. 
    !% The three possible components of the block (which should only have one
    !% line) are the three components of the magnetic field vector. Note that
    !% if you are running the code in 1D mode this will not work, and if you
    !% are running the code in 2D mode the magnetic field will have to be in
    !% the z-direction, so that the first two columns should be zero.
    !%
    !% The magnetic field should always be entered in atomic units, regardless
    !% of the "Units" variable. Note that we use the "Gaussian" system
    !% meaning 1 au[B] = 1.7152553 * 10^7 gauss, which corresponds to
    !% 1.7152553 * 10^3 Tesla.
    !%End
    nullify(ep%B_field, ep%A_static)
    if(loct_parse_block(check_inp('StaticMagneticField'), blk)==0) then

      ALLOCATE(ep%B_field(3), 3)
      do i = 1, 3
        call loct_parse_block_float(blk, 0, i-1, ep%B_field(i))
      end do
      select case(calc_dim)
      case(1)
        call input_error('StaticMagneticField')
      case(2)
        if(ep%B_field(1)**2+ep%B_field(2)**2 > M_ZERO) call input_error('StaticMagneticField')
      end select
      call loct_parse_block_end(blk)

      ! Compute the vector potential
      ALLOCATE(ep%A_static(NP, NDIM), NP*NDIM)
      ALLOCATE(x(NDIM), NDIM)
      do i = 1, NP
        x(1:NDIM) = gr%m%x(i, 1:NDIM)
        select case (NDIM)
        case (2)
          ep%A_static(i, :) = (/x(2), -x(1)/)*ep%B_field(3)
        case (3)
          ep%A_static(i, :) = (/x(2)*ep%B_field(3) - x(3)*ep%B_field(2), &
            x(3)*ep%B_field(1) - x(1)*ep%B_field(3), x(1)*ep%B_field(2) - x(2)*ep%B_field(1)/)
        end select
      end do
      deallocate(x)
      ep%A_static = -M_HALF/P_c*ep%A_static

    end if
    
    !%Variable GaugeVectorField
    !%Type block
    !%Section Hamiltonian
    !%Description
    !% The gauge vector field is used to include a uniform (but time dependent)
    !% external electric field in a time dependent run for a periodic system
    !% By default this field is kept null.
    !%End
    ! Read the initial gauge vector field
    ep%with_gauge_field = .false.
    nullify(ep%A_gauge, ep%A_gauge_dot, ep%A_gauge_ddot)
    if(simul_box_is_periodic(gr%sb)) then
      if(loct_parse_block(check_inp('GaugeVectorField'), blk) == 0) then
        ep%with_gauge_field = .true.
        ALLOCATE(ep%A_gauge(NDIM), NDIM)
        ALLOCATE(ep%A_gauge_dot(NDIM), NDIM)
        ALLOCATE(ep%A_gauge_ddot(NDIM), NDIM)
        ep%A_gauge = M_ZERO
	ep%A_gauge_dot = M_ZERO
	ep%A_gauge_ddot = M_ZERO
	do i = 1, NDIM
          call loct_parse_block_float(blk, 0, i-1, ep%A_gauge(i))
	end do
	call loct_parse_block_end(blk)
      end if
    end if
    
    !%Variable GyromagneticRatio
    !%Type float
    !%Default 2.0023193043768
    !%Section Hamiltonian
    !%Description
    !% The gyromagnetic ratio of the electron. This is of course a physical 
    !% constant, and the default value is the exact one that you should not 
    !% touch, unless : 
    !% 
    !% (i)  You want to disconnect the anomalous Zeeman term in the Hamiltonian 
    !% (then set it to zero, this number only affects this term);
    !% 
    !% (ii) You are using an effective Hamiltonian, as it is the case when
    !% you calculate a 2D electron gas, in which case you have an effective
    !% gyromagnetic factor that depends on the material.
    !%End
    call loct_parse_float(check_inp('GyromagneticRatio'), P_g, ep%gyromagnetic_ratio)

#ifdef HAVE_MPI
    !%Variable ParallelPotentialGeneration
    !%Type logical
    !%Default false
    !%Section Generalities::Parallel
    !%Description
    !% If <tt>true</tt> and parallelization in states is used, the
    !% generation of the potential it is done in parallel. This is
    !% still expertimental so it is disabled dy default.
    !%End

    call loct_parse_logical(check_inp('ParallelPotentialGeneration'), .false., ep%parallel_generate)
#endif

    ! The projectors
    ep%nvnl = geometry_nvnl(geo, nvl)

    !also the local potential
    ep%nvnl = ep%nvnl + nvl
    
    nullify(ep%p)
    
    if(ep%nvnl > 0) then
      ALLOCATE(ep%p(ep%nvnl), ep%nvnl)
      ALLOCATE(ep%atomproj(1:2, geo%natoms), 2*geo%natoms)
      do i = 1, ep%nvnl
        call projector_null(ep%p(i))
      end do
    end if

    call pop_sub()
  end subroutine epot_init


  ! ---------------------------------------------------------
  subroutine epot_end(ep, gr, geo)
    type(epot_t),      intent(inout) :: ep
    type(grid_t),      intent(in)    :: gr
    type(geometry_t),  intent(inout) :: geo

    integer :: i, iproj

    call push_sub('epot.epot_end')

    do i = 1, geo%nspecies
      call specie_pot_end(geo%specie(i), gr)
    end do

    if(associated(ep%vpsl)) then
      deallocate(ep%vpsl)
      nullify(ep%vpsl)
    end if

    if(ep%classic_pot > 0) then
      ep%classic_pot = 0
      ! sanity check
      ASSERT(associated(ep%Vclassic)) 
      deallocate(ep%Vclassic)         ! and clean up
      nullify(ep%Vclassic)
    end if

    ! the external laser
    call laser_end(ep%no_lasers, ep%lasers)

    ! the macroscopic fields
    if(associated(ep%E_field))  deallocate(ep%E_field)
    if(associated(ep%v_static)) deallocate(ep%v_static)
    if(associated(ep%B_field))  deallocate(ep%B_field)
    if(associated(ep%A_static)) deallocate(ep%A_static)
    if(associated(ep%A_gauge)) deallocate(ep%A_gauge)
    if(associated(ep%A_gauge_dot)) deallocate(ep%A_gauge_dot)
    if(associated(ep%A_gauge_ddot)) deallocate(ep%A_gauge_ddot)

    if(ep%nvnl>0) then
      do iproj = 1, ep%nvnl
        call projector_end(ep%p(iproj))
      end do

      ASSERT(associated(ep%p))
      deallocate(ep%p)
      deallocate(ep%atomproj)
    end if

    call pop_sub()

  end subroutine epot_end

  ! ---------------------------------------------------------
  subroutine epot_generate_gauge_field(ep, gr, st)
    type(epot_t),      intent(inout) :: ep
    type(grid_t),      intent(inout) :: gr
    type(states_t),    intent(inout) :: st
    
    integer :: ispin
    FLOAT :: n_el, omega2

    call push_sub('epot.epot_generate_gauge_field')
    
    ASSERT(st%wfs_type == M_CMPLX)
    
    ! Integrate the charge density
    n_el = M_ZERO
    do ispin = 1, st%d%spin_channels
      n_el = n_el + dmf_integrate(gr%m, st%rho(1:NP,ispin))
    end do
    
    omega2 = M_FOUR*M_PI*P_c*n_el/gr%sb%rcell_volume
    !call calc_paramagnetic_current(gr, st, jp)
    
    ! DEBUG
    ! Harmonic oscillator
    ep%A_gauge_ddot(1:NDIM) = -omega2*ep%A_gauge(1:NDIM)
    !write(*,'(a,3f12.6)')'OUT: A = ',ep%A_gauge(1:NDIM)
    !write(*,'(a,3f12.6)')'OUT: dA/dt = ',ep%A_gauge_dot(1:NDIM)
    !write(*,'(a,3f12.6)')'OUT: d^2A/dt^2 = ',ep%A_gauge_ddot(1:NDIM)
    ! END DEBUG
       
    call pop_sub()
  
  end subroutine epot_generate_gauge_field
  
  ! ---------------------------------------------------------
  subroutine epot_generate(ep, gr, geo, mc, st, reltype, time)
    type(epot_t),      intent(inout) :: ep
    type(grid_t), target,  intent(inout) :: gr
    type(geometry_t),  intent(inout) :: geo
    type(multicomm_t), intent(in)    :: mc
    type(states_t),    intent(inout) :: st
    integer,           intent(in)    :: reltype
    FLOAT,   optional, intent(in)    :: time

    FLOAT   :: time_
    integer :: ia, l, lm, iproj
    type(atom_t),   pointer :: atm

    type(mesh_t),      pointer :: m
    type(simul_box_t), pointer :: sb
    type(submesh_t)  :: nl_sphere
    type(profile_t), save :: projector_build_prof, epot_generate_prof

    call profiling_in(epot_generate_prof, "EPOT_GENERATE")
    call push_sub('epot.epot_generate')

    sb  => gr%sb
    m   => gr%m

    time_ = M_ZERO
    if (present(time)) time_ = time

    ! Local.
    ep%vpsl = M_ZERO
    do ia = 1, geo%natoms
      call build_local_part_in_real_space(ep, gr, geo, geo%atom(ia), ep%vpsl, time_, st%rho_core)
    end do

    ! we assume that we need to recalculate the ion_ion energy
    geo%eii = ion_ion_energy(gr, sb, geo, ep%vpsl)

    ! Local.
    ! the pseudo potential part.
    iproj = 1
    do ia = 1, geo%natoms
      atm => geo%atom(ia)

      if(.not. specie_is_ps(atm%spec)) cycle

      ep%atomproj(1, ia) = iproj
      
      call submesh_init_sphere(nl_sphere, sb, m, atm%x, atm%spec%ps%rc_max)

      do l = 0, atm%spec%ps%l_max
        if(atm%spec%ps%l_loc == l) cycle
        do lm = -l, l

          call projector_end(ep%p(iproj))
          call submesh_copy(nl_sphere, ep%p(iproj)%sphere)
          call projector_init(ep%p(iproj), atm, reltype, l, lm)

          if(simul_box_is_periodic(sb)) &
            call projector_init_phases(ep%p(iproj), gr%m, st%d%nik, st%d%kpoints)

          ep%p(iproj)%iatom = ia
          iproj = iproj + 1
        end do
      end do

      call submesh_end(nl_sphere)

      !the local-localized part
      ep%p(iproj)%iatom = ia
      
      call projector_end(ep%p(iproj))
      call submesh_init_sphere(ep%p(iproj)%sphere, &
        sb, m, atm%x, double_grid_get_rmax(gr%dgrid, atm%spec, m))
      call projector_init(ep%p(iproj), atm, force_type = M_LOCAL)

      iproj = iproj + 1
      
      ep%atomproj(2, ia) = iproj - 1

    end do

    call projector_build_all

    if (ep%classic_pot > 0) then
      ep%vpsl(1:m%np) = ep%vpsl(1:m%np) + ep%vclassic(1:m%np)
    end if

    call pop_sub()
    call profiling_out(epot_generate_prof)

  contains

    subroutine projector_build_all
#ifdef HAVE_MPI
      integer :: rank, size, ini, fin, mpi_err
      integer, allocatable :: rep(:)
#endif
      
      call profiling_in(projector_build_prof, "PROJECTOR_BUILD")

#ifdef HAVE_MPI      
      if (.not. (ep%parallel_generate .and. multicomm_strategy_is_parallel(mc, P_STRATEGY_STATES))) then
#endif

        do iproj = 1, ep%nvnl
          call projector_build(ep%p(iproj), gr, geo%atom(ep%p(iproj)%iatom))
        end do
        
#ifdef HAVE_MPI
      else
        
        size = mc%group_sizes(P_STRATEGY_STATES)
        
        ALLOCATE(rep(1:ep%nvnl), ep%nvnl)
        
        do rank = 0, size-1
          ini = rank * ep%nvnl / size + 1
          fin = min((rank + 1 )* ep%nvnl / size, ep%nvnl)
          rep(ini:fin) = rank
        end do
        
        rank = mc%who_am_i(P_STRATEGY_STATES)
        
        do iproj = 1, ep%nvnl
          if ( rep(iproj) == rank ) then 
            call projector_build(ep%p(iproj), gr, geo%atom(ep%p(iproj)%iatom))
          end if
        end do
        
        do iproj = 1, ep%nvnl
          call projector_broadcast(ep%p(iproj), gr, mc, geo%atom(ep%p(iproj)%iatom), rep(iproj))
        end do
        
      deallocate(rep)

    end if

#endif
    call profiling_out(projector_build_prof)
    end subroutine projector_build_all

  end subroutine epot_generate

  subroutine build_local_part_in_real_space(ep, gr, geo, a, vpsl, time, rho_core)
    type(epot_t),             intent(in)    :: ep
    type(grid_t),             intent(inout) :: gr
    type(geometry_t),         intent(in)    :: geo
    type(atom_t),             intent(inout) :: a
    FLOAT,                    intent(inout) :: vpsl(:)
    FLOAT,                    intent(in)    :: time
    FLOAT, optional,          intent(inout) :: rho_core(:)
 
    integer :: i
    FLOAT :: x(MAX_DIM), xx(MAX_DIM), r, pot_re, pot_im
    FLOAT, allocatable  :: rho(:), vl(:)

    call push_sub('epot.build_local_part_in_real_space')

    ALLOCATE(vl(1:NP_PART), NP_PART)
#ifdef USE_OMP
    !$omp parallel workshare
    vl(1:NP) = M_ZERO
    !$omp end parallel workshare
#endif

    !Local potential, we can get it by solving the poisson equation
    !(for all electron species or pseudopotentials in periodic
    !systems) or by applying it directly to the grid

    if(a%spec%has_density .or. (specie_is_ps(a%spec) .and. simul_box_is_periodic(gr%sb))) then

      ALLOCATE(rho(1:NP), NP)

      !this has to be optimized so the poisson solution is made once
      !for all species, perhaps even include it in the hartree term
      call specie_get_density(a%spec, a%x, gr, geo, rho)
      call dpoisson_solve(gr, vl, rho)

      deallocate(rho)

    else

      !Local potential
      call specie_get_local(a%spec, gr, a%x(1:NDIM), vl, time)

    end if

    !$omp parallel workshare
    vpsl(1:NP) = vpsl(1:NP) + vl(1:NP)
    !$omp end parallel workshare

    !Non-local core corrections
    if(present(rho_core) .and. a%spec%nlcc .and. specie_is_ps(a%spec)) then
      do i = 1, NP
        x(1:NDIM) = gr%m%x(i, 1:NDIM) - a%x(1:NDIM)
        rho_core(i) = rho_core(i) + specie_get_nlcc(a%spec, x)
      end do
    end if

    deallocate(vl)

    call pop_sub()
  end subroutine build_local_part_in_real_space


  ! ---------------------------------------------------------
  subroutine epot_generate_classic(ep, m, geo)
    type(epot_t),     intent(inout) :: ep
    type(mesh_t),     intent(in)    :: m
    type(geometry_t), intent(in)    :: geo

    integer i, ia
    FLOAT :: r, rc

    call push_sub('epot.epot_generate_classic')

    ep%Vclassic = M_ZERO
    do ia = 1, geo%ncatoms
      do i = 1, m%np
        call mesh_r(m, i, r, a=geo%catom(ia)%x)
        select case(ep%classic_pot)
        case(1) ! point charge
          if(r < r_small) r = r_small
          ep%Vclassic(i) = ep%Vclassic(i) - geo%catom(ia)%charge/r
        case(2) ! gaussion smeared charge
          select case(geo%catom(ia)%label(1:1)) ! covalent radii
          case('H')
            rc = CNST(0.4)*P_Ang
          case('C')
            rc = CNST(0.8)*P_Ang
          case default
            rc = CNST(0.7)*P_Ang
          end select
          if(abs(r - rc) < r_small) r = rc + sign(r_small, r-rc)
          ep%Vclassic(i) = ep%Vclassic(i) - geo%catom(ia)%charge*(r**4 - rc**4)/(r**5 - rc**5)
        end select
      end do
    end do

    call pop_sub()
  end subroutine epot_generate_classic


  ! ---------------------------------------------------------
  subroutine epot_forces(gr, geo, ep, st, t)
    type(grid_t),     intent(inout) :: gr
    type(geometry_t), intent(inout)  :: geo
    type(epot_t),     intent(in)     :: ep
    type(states_t),   intent(inout)     :: st
    FLOAT,     optional, intent(in)    :: t

    integer :: i, j, l
    FLOAT :: d, r, zi, zj, x(MAX_DIM), time
    type(atom_t), pointer :: atm
    
    type(profile_t), save :: forces_prof

#if defined(HAVE_MPI)
    FLOAT :: f(MAX_DIM)
#endif

    call profiling_in(forces_prof, "FORCES")
    call push_sub('epot.epot_forces')

    time = M_ZERO
    if(present(t)) time = t

    ! init to 0
    do i = 1, geo%natoms
      geo%atom(i)%f = M_ZERO
    end do
    
    if (wfs_are_real(st) ) then 
      call dcalc_forces_from_potential(gr, geo, ep, st, time)
    else
      call zcalc_forces_from_potential(gr, geo, ep, st, time)
    end if

#if defined(HAVE_MPI)
    if(st%parallel_in_states) then
      do i = 1, geo%natoms
        atm => geo%atom(i)
        call MPI_Allreduce(atm%f(1), f(1), NDIM, MPI_FLOAT, MPI_SUM, st%mpi_grp%comm, mpi_err)
        atm%f = f
      end do
    end if
#endif

    if(.not.geo%only_user_def) then ! exclude user defined species for the moment
      ! Now the ion, ion force term
      do i = 1, geo%natoms
        zi = geo%atom(i)%spec%Z_val
        do j = 1, geo%natoms
          if(i .ne. j) then
            zj = geo%atom(j)%spec%Z_val
            r = sqrt(sum((geo%atom(i)%x(1:NDIM) - geo%atom(j)%x(1:NDIM))**2))
            d = zi * zj/r**3

            geo%atom(i)%f(1:NDIM) = geo%atom(i)%f(1:NDIM) + &
                 d*(geo%atom(i)%x(1:NDIM) - geo%atom(j)%x(1:NDIM))
          end if
        end do
      end do
    end if

    !TODO: forces due to the magnetic fields (static and time-dependent)
    if(present(t)) then
      do j = 1, ep%no_lasers
        select case(ep%lasers(j)%field)
        case(E_FIELD_ELECTRIC)
          call laser_field(gr%sb, ep%lasers(j), x, t)
          do i = 1, geo%natoms
            geo%atom(i)%f(1:NDIM) = geo%atom(i)%f(1:NDIM) + &
              geo%atom(i)%spec%Z_val * x(1:NDIM)
          end do
        case(E_FIELD_MAGNETIC, E_FIELD_VECTOR_POTENTIAL, E_FIELD_SCALAR_POTENTIAL)
          write(message(1),'(a)') 'The forces are currently not properly calculated if time-dependent'
          write(message(2),'(a)') 'magnetic fields are present.'
          call write_fatal(2)
        end select
      end do
    end if

    if(associated(ep%E_field)) then
      do i = 1, geo%natoms
        geo%atom(i)%f(1:NDIM) = geo%atom(i)%f(1:NDIM) + &
             geo%atom(i)%spec%Z_val * ep%E_field(1:NDIM)
      end do
    end if


    call pop_sub()
    call profiling_out(forces_prof)

  end subroutine epot_forces

  ! ---------------------------------------------------------
  FLOAT function ion_ion_energy(gr, sb, geo, vpsl)
    type(grid_t),              intent(in) :: gr
    type(simul_box_t), target, intent(in) :: sb
    type(geometry_t),  target, intent(in) :: geo
    FLOAT,                     intent(in) :: vpsl(:)

    type(specie_t), pointer :: s
    FLOAT :: r, rc, xi(1:MAX_DIM)
    integer :: iatom, jatom, icopy
    type(periodic_copy_t) :: pc

    ! Note that a possible jellium-jellium interaction (the case where more
    ! than one jellium species is present) is not properly calculated.
    ! But if only one jellium sphere is present, it correctly calculates its
    ! electrostatic energy. I do not know right now if there is a closed
    ! analytical expression for the electrostatic energy of a system of two
    ! uniformly charged spheres.
    ion_ion_energy = M_ZERO

    ! interaction inside the cell
    do iatom = 1, geo%natoms
      s => geo%atom(iatom)%spec
      if(s%type .eq. SPEC_JELLI) then
        ion_ion_energy = ion_ion_energy + (M_THREE/M_FIVE)*s%z_val**2/s%jradius
      end if

      do jatom = 1, iatom - 1
        r = sqrt(sum((geo%atom(iatom)%x - geo%atom(jatom)%x)**2))
        if (specie_is_ps(geo%atom(jatom)%spec)) then
          ion_ion_energy = ion_ion_energy + (-s%z_val)*loct_splint(geo%atom(jatom)%spec%ps%vion, r)
        else
          ion_ion_energy = ion_ion_energy + s%z_val*geo%atom(jatom)%spec%z_val/r
        end if
      end do

    end do

    if(simul_box_is_periodic(sb)) then

      ! If the system is periodic add the interaction of the copies

      do iatom = 1, geo%natoms
        s => geo%atom(iatom)%spec
        if (.not. specie_is_ps(s)) cycle

        rc = loct_spline_cutoff_radius(s%ps%vion, s%ps%projectors_sphere_threshold)
        call periodic_copy_init(pc, sb, geo%atom(iatom)%x, rc)

        do icopy = 1, periodic_copy_num(pc)
          ! the interaction between atoms in the cell was already considered
          if (periodic_copy_is_original_point(pc, sb, icopy)) cycle

          xi = periodic_copy_position(pc, sb, icopy)

          do jatom = 1, iatom
            r = sqrt( sum( (xi - geo%atom(jatom)%x)**2 ) )
            ion_ion_energy = ion_ion_energy + (-geo%atom(jatom)%spec%z_val)*loct_splint(s%ps%vion, r)
          end do
          
        end do
        
        call periodic_copy_end(pc)
        
      end do

      do iatom = 1, geo%natoms
        s => geo%atom(iatom)%spec
        if (.not. specie_is_ps(s)) cycle
        ion_ion_energy = ion_ion_energy + (-s%z_val)*dmf_interpolate_point(gr%m, vpsl, geo%atom(iatom)%x)
        
        !remove the self interaction term
        ion_ion_energy = ion_ion_energy - s%ps%a_erf/sqrt(M_PI)*s%z_val**2
        
      end do

    end if

  end function ion_ion_energy

#include "undef.F90"
#include "real.F90"
#include "epot_inc.F90"

#include "undef.F90"
#include "complex.F90"
#include "epot_inc.F90"

end module external_pot_m



!! Local Variables:
!! mode: f90
!! coding: utf-8
!! End:
