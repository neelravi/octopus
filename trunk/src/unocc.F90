!! Copyright (C) 2002 M. Marques, A. Castro, A. Rubio, G. Bertsch
!!
!! This program is free software; you can redistribute it and/or modify
!! it under the terms of the GNU General Public License as published by
!! the Free Software Foundation; either version 2, or (at your option)
!! any later version.
!!
!! This program is distributed in the hope that it will be useful,
!! but WITHOUT ANY WARRANTY; without even the implied warranty of
!! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!! GNU General Public License for more details.
!!
!! You should have received a copy of the GNU General Public License
!! along with this program; if not, write to the Free Software
!! Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
!! 02111-1307, USA.

#include "config_F90.h"

module unocc
use liboct
use io
use states
use eigen_solver

implicit none

type unocc_type
  integer  :: max_iter ! maximum number of iterations
  real(r8) :: conv     ! convergence criterium for the eigenvectors

  type(states_type), pointer :: st
end type unocc_type

contains

subroutine unocc_init(u, m, st, sys)
  type(unocc_type), intent(out) :: u
  type(mesh_type), intent(IN)   :: m
  type(states_type), intent(IN) :: st
  type(system_type), intent(IN) :: sys

  sub_name = 'unocc_init'; call push_sub()

  call oct_parse_int(C_string("UnoccMaximumIter"), 200, u%max_iter)
  call oct_parse_double(C_string("UnoccConv"), 1e-4_r8, u%conv)
  if(u%max_iter <= 0 .and. u%conv <= 0.0_r8) then
    message(1) = "Input: Not all occ convergence criteria can be <= 0"
    message(2) = "Please set one of the following:"
    message(3) = "UnoccMaximumIter | UnoccConv"
    call write_fatal(3)
  end if
  if(u%max_iter <= 0) u%max_iter = huge(u%max_iter)

  ! allocate states structure
  allocate(u%st)
  call states_init(u%st, m, sys%val_charge)

  call oct_parse_int(C_string("UnoccNumberStates"), 5, u%st%nst)
  if(u%st%nst <= 0) then
    message(1) = "Input: UnoccNumberStates must be > 0"
    call write_fatal(1)
  end if

  ! setup variables
  u%st%nst = u%st%nst + st%nst
  u%st%st_end = u%st%nst
  allocate(u%st%R_FUNC(psi) (0:m%np, u%st%dim, u%st%nst, u%st%nik))
  allocate(u%st%eigenval(u%st%nst, u%st%nik), u%st%occ(u%st%nst, u%st%nik))
  u%st%eigenval = 0._r8
  u%st%occ      = 0._r8

  call pop_sub(); return
end subroutine unocc_init

subroutine unocc_end(u)
  type(unocc_type), intent(out) :: u
  
  if(associated(u%st)) then
    call states_end(u%st)
    deallocate(u%st)
    nullify   (u%st)
  end if

end subroutine unocc_end

subroutine unocc_run(u, sys, h)
  type(unocc_type), intent(inout) :: u
  type(system_type), intent(inout) :: sys
  type(hamiltonian_type), intent(inout) :: h

  type(eigen_solver_type) :: eigens
  integer :: iunit
  logical :: converged
  real(r8) :: diff(u%st%nst, u%st%nik)

  sub_name = 'unocc_run'; call push_sub()

  ! Initialize eigens (not necessary to call eigen_init)
  eigens%es_type        = ES_NEW_CG
  eigens%init_tol       = u%conv 
  eigens%final_tol      = u%conv
  eigens%final_tol_iter = 1
  eigens%es_maxiter     = u%max_iter

  call eigen_solver_run(eigens, u%st, sys, h, 1, diff, converged)
  call R_FUNC(hamiltonian_eigenval) (h, u%st, sys)

  ! write output file
  call io_assign(iunit)
  call oct_mkdir(C_string("static"))
  open(iunit, status='unknown', file='eigenvalues')
  if(converged) then
    write(iunit,'(a)') 'Occupation analysis converged.'
  else
    write(iunit,'(a)') 'Occupational analysis did *not* converge!'
  end if
  write(iunit,'(a, e17.6)') 'Criterium = ', u%conv
  write(iunit,'(1x)')
  call states_write_eigenvalues(iunit, u%st%nst, u%st, diff)
  call io_close(iunit)

  ! write restart information.
  call R_FUNC(states_write_restart)("tmp/restart.occ", sys%m, u%st) 

  ! output wave-functions
  call R_FUNC(states_output) (u%st, sys%m, "static", sys%outp)

  call pop_sub(); return
end subroutine unocc_run

end module unocc
