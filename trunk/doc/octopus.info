This is octopus.info, produced by makeinfo version 4.4 from
octopus.texi.

This manual is for octopus 1.1, a first principles, electronic
structure, excited states, Time-dependent density functional theory
program.

   *Warning: this is not yet the final version of the manual for the
1.1 version.*

   Copyright (C) 2002, 2003 Miguel A. L. Marques, Alberto Castro and
Angel Rubio

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.1 or any later version published by the Free Software
     Foundation.
   

File: octopus.info,  Node: Top,  Next: Copying,  Prev: (dir),  Up: (dir)

octopus
*******

This manual is for octopus 1.1, a first principles, electronic
structure, excited states, Time-dependent density functional theory
program.

   *Warning: this is not yet the final version of the manual for the
1.1 version.*

   Copyright (C) 2002, 2003 Miguel A. L. Marques, Alberto Castro and
Angel Rubio

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.1 or any later version published by the Free Software
     Foundation.
   
* Menu:

* Copying::
* Authors::
* Introduction::
* Installation::
* The input file::
* External utilities::
* Examples::
* Options Index::

 --- The Detailed Node Listing ---

Introduction

* Description of octopus::
* Time dependent density functional theory::

Installation

* Quick instructions::
* Long instructions::
* Troubleshooting::

Description of input options

* The parser::
* Input file options::

Input file options

* Generalities::
* Species::
* Coordinates::
* Velocities::
* Mesh::
* States::
* Hamiltonian::
* Exchange and correlation::
* SCF::
* Unoccupied States::
* Time Dependent::
* Photo-electron spectrum::
* Geometry optimization::
* Function output for visualization::
* Spectrum calculations::
* Varia::

External utilities

* strength-function::
* hs-from-mult::
* hs-from-acc::
* function-to-dx::
* nbo2xyz::

Examples

* Hello world::
* Benzene::


File: octopus.info,  Node: Copying,  Next: Authors,  Prev: Top,  Up: Top

Copying
*******

   This program is "free"; this means that everyone is free to use it
and free to redistribute it on a free basis.  What is not allowed is to
try to prevent others from further sharing any version of this program
that they might get from you.

   Specifically, we want to make sure that you have the right to give
away copies of the program, that you receive source code or else can
get it if you want it, that you can change this program or use pieces
of them in new free programs, and that you know you can do these things.

   To make sure that everyone has such rights, we have to forbid you to
deprive anyone else of these rights.  For example, if you distribute
copies of the program, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must tell them their rights.

   Also, for our own protection, we must make certain that everyone
finds out that there is no warranty for this program.  If these
programs are modified by someone else and passed on, we want their
recipients to know that what they have is not what we distributed, so
that any problems introduced by others will not reflect on our
reputation.

   The precise conditions of the license are found in the General Public
Licenses that accompany it.


File: octopus.info,  Node: Authors,  Next: Introduction,  Prev: Copying,  Up: Top

Authors, Collaborators and Acknowledgements.
********************************************

   The main developing team of this program is composed by Miguel A. L.
Marques and Angel Rubio, working at the Donostia International Physics
Center and Department of Materials Science UPV/EHU (San Sebastian,
Espan~a), and Alberto Castro, who works at the University of
Valladolid, Departamento de Fi'sica Teo'rica (Valladolid, Espan~a).

   `octopus' is based on a fixed-nucleus code written by George F.
Bertsch, K. Yabana to perform real-time dynamics in clusters (Phys Rev
B *54*, 4484 (1996)) and on a condensed matter real-space plane-wave
based code written by A. Rubio, X. Blase and S.G. Louie (Phys. Rev.
Lett. *77*, 247 (1996)).  The code was afterwards extended to handle
periodic systems by G.F. Bertsch, J.I. Iwata, A. Rubio, and K. Yabana
(Phys. Rev. B, *62*, 7998 (2000)). Contemporaneously there was a major
rewrite of the original cluster code to handle a vast majority of
finite systems. At this point the cluster code was named "tddft".

   This version was consequently enhanced and beautified by A. Castro
(at the time Ph.D. student of A. Rubio), originating a fairly verbose
15,000 lines of Fortran 90/77. In the year 2000, M. Marques (aka
Hyllios, aka Anto'nio de Faria, corsa'rio portugue^s), joins the A.
Rubio group in Valladolid as a postdoc. Having to use "tddft" for his
work, and being petulant enough to think he could structure the code
better than his predecessors, starts a major rewrite of the code
together with A. Castro, finishing version 0.2 of "tddft." But things
were still not perfect: due to their limited experience in Fortran 90,
and due to the inadequacy of this language for anything beyond a HELLO
WORLD program, several parts of the code were still clumsy. Also the
idea of GPLing the almost 20,000 lines arose during an alcoholic
evening. So after several weeks of frantic coding and after getting rid
of the Numerical Recipes code that still lingered around, `octopus' was
born.

   The present released version has been completely rewritten and keeps
very little relation to the old version (even input and output files)
and has been enhanced with major new flags to perform various
excited-state dynamics in finite and extended systems (one-dimensional
periodic chains). The code will be updated frequently and new versions
can be found here (http://www.tddft.org/programs/octopus).

   The main features of the present version are described in detail in
_octopus: a first principles tool for excited states electron-ion
dynamics_, Comp. Phys. Comm. *151*, 60 (2003).  Updated references as
well as results obtained with octopus will be posted regularly to the
`octopus' web page. If you find the code useful for you research we
would appreciate if you give reference to this work and previous ones.

   If you have some free time, and if you feel like taking a joy ride
with Fortran 90, just drop us an email <octopus@tddft.org>. You can
also send us patches, comments, ideas, wishes, etc. They will be
included in new releases of octopus.


File: octopus.info,  Node: Introduction,  Next: Installation,  Prev: Authors,  Up: Top

Introduction
************

* Menu:

* Description of octopus::
* Time dependent density functional theory::


File: octopus.info,  Node: Description of octopus,  Next: Time dependent density functional theory,  Prev: Introduction,  Up: Introduction

Description of `octopus'
========================

   `octopus' (1) is a program aimed at the ab initio virtual
experimentation on electron/ion dynamics in external electromagnetic
fields of arbitrary intensity, shape and frequency in a hopefully ever
increasing range of systems types. Its main characteristics are:

   * Electrons are described quantum-mechanically within the
     Density-Functional Theory (DFT) for the ground-state whereas the
     excitation spectra is computed using time-dependent form (TDDFT)
     by performing simulations in time.

   * The electron-nucleus interaction is described within the
     pseudo-potential approximation. Nuclei are described classically
     as point particles.

   * Wave-functions are expanded in a real-space grid. The kinetic
     energy operator is computed with a high-order finite difference
     method.  FFTs are used in part of the calculations.  Time and grid
     spacing are related by imposing a stable time-evolution.

   * Forces on the ions are computed through the Ehrenfest theorem.
     Extension to quantum mechanical nuclear dynamics is in progress.

   * Allows for spin-polarised calculations as well as non-collinear
     magnetism and spin-orbit effects.

   * Computes photo-electron (energy and angle resolved) and
     photo-absorption spectra for different polarised external
     electromagnetic fields. Linear response calculations are a simple
     case of this general time-evolution procedure (see below).

   * Includes non-linear electronic effects: high-harmonic generation,
     interaction with a laser pulse of arbitrary intensity. For the
     time being only time- and spatially-dependent electric fields are
     included, in the future magnetic fields will be incorporated.

   * Reads different geometry files including protein-data-base (PDB)
     for biological calculations (interaction of biomolecules with
     electromagnetic fields).

   * It allows for one and two dimesional modes, by using for example
     the soft-coulomb potential or any other given as input.

   * Laser-pulse optimisation using genetic algorithms (to be done).

   * Utilities to analyse the computed spectra.

   * A very effective and easy-to-use parser to handle the input file.


   ---------- Footnotes ----------

   (1) _octopus_: Etymology: New Latin _Octopod-_, _Octopus_, from
Greek _oktOpous_.  Any of a genus (_Octopus_) of cephalopod mollusks
that have eight muscular arms equipped with two rows of suckers;
broadly, any octopod excepting the paper nautilus.  Something that
resembles an octopus especially in having many centrally directed
branches.  (taken from the Merryam-Webster's dictionary.)


File: octopus.info,  Node: Time dependent density functional theory,  Prev: Description of octopus,  Up: Introduction

Time dependent density functional theory
========================================

   Several reviews of time dependent density function theory (TDDFT)
and its applications have appeared recently, like the works by Gross et
al. (1), Casida (2), Dobson et al, (3) , and Burke et al (4).

   Please visit the printed version of this manual for a brief of
review of TDDFT.

   ---------- Footnotes ----------

   (1)   Gross, E.K.U., C.A. Ullricht and U.J. Grossmann, 1994, in
_Density Functional Theory_, (NATOP ASI Series), p.194;   Gross,
E.K.U., F. J. Dobson, and M. Petersilka, 1996,   _Density Functional
Theory_ (Springer, New York).

   (2)   Casida, M.E., 1995, in _Recent Advances in Density Functional
Methods_,   Part I, ed. D.P. Chong (World Scientific, Singapore), p.155;
 Casida, M.E., 1996, in _Recent Developments and Applications of Modern
 Density Functional Theory_, ed. J.M. Seminario (Elsevier Science,
Amsterdam), p.391

   (3)   Dobson, J , G. Vignale and M.P. Das (Eds), 1997a,
_Electronic Density Functional Theory: Recent Progress and New
Directions_   (Plenum, New York)

   (4)   Burke, K., M. Petersilka and E.K.U. Gross, 2001, in   _Recent
Advances in Density Functional Methods_, edited by P.    Fantucci and
A. Bencini (World Scientific, Singapure).


File: octopus.info,  Node: Installation,  Next: The input file,  Prev: Introduction,  Up: Top

Installation
************

* Menu:

* Quick instructions::
* Long instructions::
* Troubleshooting::


File: octopus.info,  Node: Quick instructions,  Next: Long instructions,  Prev: Installation,  Up: Installation

Quick instructions
==================

   For the inpatients, here goes the quick-start:
     prompt> gzip -cd octopus<-version>.tar.gz | tar xvf -
     prompt> cd octopus-<version>
     prompt> ./configure
     prompt> make
     prompt> make install

   This will probably *not* work, so before giving up, just read the
following paragraphs.

   Also, rpm binaries for linux are supplied in the web-page.


File: octopus.info,  Node: Long instructions,  Next: Troubleshooting,  Prev: Quick instructions,  Up: Installation

Long instructions
=================

   The code is written in standard Fortran 90, with some routines
written in C (and in bison, if we count the input parser). To build it
you will need both a C compiler (`gcc' works just fine), and a Fortran
90 compiler. No free-software Fortran 90 compiler is available yet, so,
if you want to chew the `octopus', you will have either to help the g95
(http://g95.sourceforge.net) project or use any of the available
comercial compilers.

   Besides the compiler, you will also need:
  1. `make' :  most computers have it installed, otherwise just grab
     the GNU `make' and install it.

  2. `cpp' : The C preprocessor is heavily used in `octopus'.  GNU
     `cpp' is just fine, but any `cpp' that accepts the `-C' flag
     (preserve comments) should work just as well.

  3. FFTW : Just grab this great library from here
     (http://www.fftw.org/)

  4. LAPACK/BLAS : Not heavily used, but required. If you are running
     Linux, there is a fair chance they are already installed in your
     system. The same goes to the more heavyweight machines (alphas,
     IBMs, SGIs, etc). Otherwise, just grab the source from here
     (http://www.netlib.org).

  5. GSL : Finally that someone had the nice idea of making a public
     scientific library! GSL still needs to grow, but it is already
     quite useful and impressive.  `octopus' uses splines, complex
     numbers, special functions, etc. from GSL, so it is a must! If you
     don't have it already installed in your system, you can obtain GSL
     from here (http://sources.redhat.com/gsl/). You will need version
     1.0 or higher.

  6. MPI : If you want to run `octopus' in multi-tentacle (parallel)
     mode, you will need an implementation of MPI.  `mpich'
     (http://www-unix.mcs.anl.gov/mpi/mpich/) works just fine in our
     Linux boxes.


   First you should obtain the code gzipped-tarred file
`octopus<-version>.tar.gz' (this you probably have already done). The
code is freely available, and can be downloaded from
`http://www.tddft.org/programs/octopus'. There exists a `cvs' server,
which you can browse at
`http://nautilus.fis.uc.pt/cgi-bin/cvsweb.cgi/marques/octopus/'.  The
sources of the cvs version (in general more unstable the the _official_
distribution) may be downloaded by anonymous cvs access:

     prompt> cvs -d :pserver:anonymousnautilus.fis.uc.pt:/server/cvsroot
             login
     
     prompt> cvs -d :pserver:anonymousnautilus.fis.uc.pt:/server/cvsroot
             co marques/octopus

   Uncompress and untar it (`gzip -cd octopus<-version>.tar.gz | tar
-xvf -').  In the following, `OCTOPUS-HOME' denotes the home directory
of octopus, created by the `tar' command.

   The `OCTOPUS-HOME' contains the following subdirectories:
   * `build': contains files related to the building system. Not of
     real interest     for the plain user.

   * `CVS': May actually not be there; contains files related to the
     CVS - the     user does not need to know anything about it.

   * `doc' : The documentation of `octopus' in _texinfo_ format.

   * `faq' : Will contain a list of frequently asked questions - very
     small list     for the moment.

   * `liboct' : Small C library that handles the interface to     GSL
     and the parsing of the input file. It also contains some assorted
       routines that we didn't want to write in boring Fortran.

   * `samples' : Sample input files for `octopus'.

   * `share': Made to contain "auxiliary" files eventually used by the
     code;     in practice now it contains the Troullier-Martins and
     Hartwigsen-Goedecker-Hutter     pseudopotential files.

   * `src' : Fortran 90 source files. Note that these have to be
     preprocessed     before being fed to the Fortran compiler, so do
     not be scared by     all the # directives.

   Before configuring you can (should) setup a couple of options.
Although the configure script tries to guess your system settings for
you, we recommend that you set explicitly the default Fortran 90
compiler and the compiler options. In `bash' you would typically do:
     export F90=abf90
     export F90FLAGS="-O -YEXT_NAMES=LCS -YEXT_SFX=_"
   if you are using the Absoft Fortran 90 compiler on a linux machine.

   You can now run the configure script (`./configure').  (1) You can
use a fair amount of options to spice (`octopus') to your own taste.
To obtain a full list just type `./configure --help'. Some commonly
used options include:
   * `--prefix=PREFIX' : Change the base installation dir of `octopus'
     to `PREFIX'. The executable will be installed in `PREFIX/bin',
     the libraries in `PREFIX/lib' and the documentation in
     `PREFIX/info'.    `PREFIX' defaults to the home directory of the
     user who runs `configure'.

   * `--with-fftw=DIR' : Installation directory of the FFTW library.

   * `--with-lapack=DIR' : Installation directory of the LAPACK and
     BLAS libraries.

   * `--with-gsl-prefix=DIR' : Installation directory of the GSL
     library. The   libraries are expected to be in `DIR/lib' and the
     include   files in `DIR/include'. The value of `DIR' is usually
     found by   issuing the command `gsl-config --prefix'. (If the GSL
     library is   installed, the program `gsl-config' should be
     somewhere).

   * `--enable-1d' : Build the 1d version of `octopus'.

   * `--enable-2d' : Build the 2d version of `octopus'.

   * `--enable-3d' : Build the 3d version of `octopus'. This is the
     default behaviour.

   * `--enable-mpi' : Builds the parallel version (MPI) of `octopus'.

   * `--enable-complex' : Builds a version with complex wave-functions
     for the ground-state calculations (wave-functions are always
     complex for the evolution). This is needed when spinors are needed
     -- e.g. noncollinear magnetism is going to be considered, or the
     spin-orbit coupling term will be used.

   Run `make', and then `make install'. If everything went fine, you
should now be able to taste `octopus'. Depending on the options passed
to the configure script, some suffixes or prefixes could be added to
the generic name `octopus' -- i.e. `octopus-1d' for the 1D version,
`zoctopus' for the code compiled with complex wave-functions,
`zoctopus-mpi' for a parallel version of the code compiled with complex
wave-function, and so on.

   The program has been tested in the following platforms:
   * `i686*-linux-gnu' : with the Absoft (http://www.absoft.com),   and
     the Intel (http://www.intel.com/software/products/compilers/)
     compiler.

   * `alphae*' : both in Linux and in OSF with Compac's `fort' compiler.

   * `powerpc-ibm-aix4.3.3.0': with native `xlf90' compiler.
   If you manage to compile/run `octopus' in a different platform or
with a different compiler, please let us know so we can update the
list. Patches to solve compiler issues are also welcomed.

   Build the documentation in the format you prefer. Since you are
reading this, you already have it in some format. Due to the power of
`texinfo', a series of formats are available, namely `dvi', `html',
`pdf' and `info'. The `octopus.texi' source code of this document is in
the `OCTOPUS-HOME/doc' directory.

   ---------- Footnotes ----------

   (1) If you downloade the cvs version, no `configure' script is
present. In the development version, some previous work has to be done:
running the GNU autotools to generate this script. This may be done by
issuing the short script `./autogen.sh'. Note that you need to have
working versions of the `automake', `autoconf' and `libtool' programs.


File: octopus.info,  Node: Troubleshooting,  Prev: Long instructions,  Up: Installation

Troubleshooting
===============

   If you are reading this it is because something went wrong. Let us
see if we can fix it ;)

   *Could not find library...*: This is probably the most common error
you can get. `octopus' uses three different libraries, `GSL', `FFTW',
and `BLAS'/`LAPACK'. We assume that you have already installed these
libraries but, for some reason, you were not able to compile the code.
So, what went wrong?
   * Did you pass the correct `--with-XXXX' (where XXXX is gsl, fftw or
      lapack in lowercase) to the configure script? If your libraries
     are   installed in an non-standard directory (like `/opt/lapack'),
     you will   have to pass the script the location of the library (in
     this example,   you could try `./configure
     --with-lapack=/opt/lapack'.

   * If you are working in an alpha station, do not forget that the
     `CXML'   library includes `BLAS' and `LAPACK', so it can be used by
      `octopus'. If needed, just set the correct path with
     `--with-lapack'.

   * If the configuration script can not find `FFTW', it is probable
     that   you did not compile `FFTW' with the same Fortran compiler
     or with the   same compiler options. The basic problem is that
     Fortran some times converts   the function names to uppercase,
     other times to lowercase, and it can   add an "_" to them, or even
     two. Obviously all libraries and the program have   to use the
     same convention, so the best is to compile everything with   the
     same Fortran compiler/options. If you are a power user, you can
     check the   convention used by your compiler using the command `nm
     <library>'.


   *Whatever went wrong...*: Up to now, we cannot really make a list of
commonly found problems. So if something else went wrong, please
subscribe to `octopus-users' mailing list, and ask.


File: octopus.info,  Node: The input file,  Next: External utilities,  Prev: Installation,  Up: Top

Description of input options
****************************

* Menu:

* The parser::
* Input file options::


File: octopus.info,  Node: The parser,  Next: Input file options,  Prev: The input file,  Up: The input file

The parser
==========

   All input options should be in a file called '`inp'', in the
directory `octopus' is run from. Alternatively, if this file is not
found, standard input is read. For a fairly comprehensive example, just
look at the file `OCTOPUS_HOME/samples/inp'

   At the beginning of the program `liboct' reads the `inp' file,
parses it, and generates a list of variables that will be read by
`octopus' (note that the input is case independent).  There are two
kind of variables, scalar values (strings or numbers), and blocks (that
you may view as matrices). A scalar variable `var' can be defined by:
     var = exp
   `var' can contain any alphanumeric character plus "_", and `exp' can
be a quote delimited string, a number (integer, real, or complex), a
variable name, or a mathematical expression.  In the expressions all
arithmetic operators are supported ("a+b", "a-b", "a*b", "a/b"; for
exponentiation the C syntax "a^b" is used), and the following functions
can be use:
   * `sqrt(x)' : The square root of `x'.

   * `exp(x)' : The exponential of `x'.

   * `log(x)' or `ln(x)': The natural logarithm of `x'.

   * `log10(x)' : Base 10 logarithm of `x'.

   * `sin(x)', `cos(x)', `tan(x)', `cot(x)',   `sec(x)', `csc(x)': The
     sinus, co-sinus, tangent, co-tangent,   secant and co-secant of
     `x'.

   * `asin(x)', `acos(x)', `atan(x)', `acot(x)',   `asec(x)',
     `acsc(x)': The inverse (arc-) sinus, co-sinus, tangent, co-tangent,
      secant and co-secant of `x'.

   * `sinh(x)', `cosh(x)', `tanh(x)', `coth(x)',   `sech(x)',
     `csch(x)': The hyperbolic sinus, co-sinus, tangent, co-tangent,
     secant and co-secant of `x'.

   * `asinh(x)', `acosh(x)', `atanh(x)', `acoth(x)',   `asech(x)',
     `acsch(x)': The inverse hyperbolic sinus, co-sinus, tangent,
     co-tangent,   secant and co-secant of `x'.
   You can also use any of the predefined variables:
   * `pi' : 3.141592653589793, what else is there to say?

   * `e' : The base of the natural logarithms.

   * `false' or `f' or `no' : False in all its flavors. For the
     curious, `false' is defined as 0.

   * `true' or `t' or `yes' : The truthful companion of `false'. For the
      curious, `true' is defined as 1.

   Blocks are defined as a collection of values, organised in row and
column format.  The syntax is the following:
     %var
       exp | exp | exp | ...
       exp | exp | exp | ...
       ...
     %
   Rows in a block are separated by a newline, while columns are
separated by the character "|". There may be any number of lines and any
number of columns in a block. Note also that each line can have a
different number of columns.

   If `octopus' tries to read a variable that is not defined in the
`inp' file, it automatically assigns to it a default value. All
variables read are output to the file '`out.oct''. If you are not sure
of what the program is reading, just take a look at it.  Everything
following the character "#" until the end of the line is considered a
comment and is simply cast into oblivion.


File: octopus.info,  Node: Input file options,  Prev: The parser,  Up: The input file

Input file options
==================

   `octopus' has quite a few options, that we will subdivide in
different groups.  After the name of the option, its type and default
value (when applicable) are given in parenthesis.

* Menu:

* Generalities::
* Species::
* Coordinates::
* Velocities::
* Mesh::
* States::
* Hamiltonian::
* Exchange and correlation::
* SCF::
* Unoccupied States::
* Time Dependent::
* Photo-electron spectrum::
* Geometry optimization::
* Function output for visualization::
* Spectrum calculations::
* Varia::


File: octopus.info,  Node: Generalities,  Next: Species,  Prev: Input file options,  Up: Input file options

Generalities
------------

   *   `Verbose' (integer, 30) : Verbosity level of the program. The
     higher, the more verbose `octopus' is. Current levels are:
        - `verbose <=  0' : Silent mode. No output except fatal errors.

        - `verbose >   0' : Warnings only.

        - `verbose >  20' : Normal program info.

        - `verbose > 999' : Debug mode. Issues a message every time the
          program enters a (important) subroutine, and prints the time
          it spend upon return.

   *   `SystemName' (string, 'system') : A string that identifies the
     current run. This parameter is used to build the names of some
     files generated by `octopus'.

   *   `CalculationMode' (integer, 1) : It defines the type of
     simulation to perform. Options are:
        - `1' : Start static calculation.

        - `2' : Resume static calculation.

        - `3' : Calculate unoccuppied states.

        - `4' : Resume calculation of unoccupied states.

        - `5' : Start time-dependent propagation.

        - `6' : Resume time-dependent propagation.

        - `7' : Start static polarizability calculation.

        - `8' : Resume static polarizability calculation.

        - `10': Perform geometry minimization.

        - `11': Calculates the phonon spectrum of the system.

        - `12': _Optimum control_ mode.

        - `99' : Print out an octopus recipe.

   * `Units' (string, 'a.u'): Atomic units seem to be the preferred
     system in the atomic and molecular physics community (despite the
     opinion of some of the authors of this program). Accordingly,
     atomic units can be used both for input and output. However, some
     people like using eV for energies and AA for lengths. This other
     system of units (the _convenient system_, in words of Prof. George
     F. Bertsch), can also be used. See the Frequently Asked Questions
     for some more details.  Valid options are:
        - `'a.u'' : atomic units

        - `'eVA'' : electron-volts/amstrongs

   * `UnitsInput' (string, 'a.u.'): Same as `Units', but only refers to
     the values in the input file.

   * `UnitsOutput' (string, 'a.u.'): Same as `Units', but only refers
     to the values in the output files.



File: octopus.info,  Node: Species,  Next: Coordinates,  Prev: Generalities,  Up: Input file options

Species
-------

   * `Species' (block data) : A specie is by definition an ion (nucleus
     + core electrons) described through a pseudo-potential, or a model
     potential.  The format of this block is different for 1, 2 or 3
     dimensions, and can be best understood through examples.

        * In 1D, or 2D, e.g.
                 %Species
                   'H'  | 1.0079 | 1 | "-1/sqrt(x^2 + 1)"
                 %
          This defines a species labelled '`H'' of weight `1.0079', and
          valence charge `1'. This 'valence charge' is used to calculate
          the number of electrons present in the calculation: as many
          as indicated by the valence charges of the species, plus any
          extra charge specified by the user (*note States::). Last
          field may be any user defined potetial - use `x' (and `y' in
          the 2D case) for the position of the electron relative to the
          species center.  For example. the potential often used in 1D
          calculations is the soft-Coulomb potential -Z/sqrt(x*x + 1).

        * In 3D, e.g.
                 %Species
                   'O'       | 15.9994 | 8   | "tm2"  | 1 | 1
                   'H'       |  1.0079 | 1   | "hgh"  | 0 | 0
                   'jelli01' | 23.2    | 8.0 |  5.0
                   'point01' | 32.3    | 2.0
                   'usdef'   | 1 | 8 | "1/2*r^2"
                 %
          In this case, we have 4 "species" present:
             - Oxygen labelled '`O''. Next number is the atomic mass
               (in atomic mass units), and third field, the atomic
               number (8, in this case).  Afterwards, "tm2" is the
               flavour of the pseudopotential: "tm2" stands for
               Troullier-Martins. This means the pseudopotential will be
               read from an `O.ascii' or `O.vps' file, either in the
               working directory or in the `OCTOPUS-HOME/share/PP/TM2'
               directory.  Next two numbers are the maximum
               _l_-component of the pseudo-potential to consider in the
               calculation, and the _l_-component to consider as local.

             - Hydrogen defined in the same way as Oxygen. In this
               case, however, the flavour is "hgh" standing for
               Hartwigsen-Goedecker-Hutter. Last two numbers are
               irrelevant.

             - All species whose label starts by 'jelli' are jellium
               spheres.  The other parameters are the weight, the
               nuclear charge, and the valence charge of the sphere.

             - All species whose label starts by 'point' are point
               charges.  The other parameters are the weight and the
               nuclear charge. In fact, point charges are implemented
               as _rather small_ jellium spheres, with zero valence
               charge.

             - All species whose label starts by 'usdef' are user
               defined potentials. The second parameter is the mass
               (irrelevant in this case, for these species are not
               allowed to move), whereas the third parameter is the
               'valence charge', used to calculate the number of
               electrons.  Finally, the potential itself is defined by
               the fourth argument.  Use any of the `x', `y', `z' or
               `r' variables to define position.



File: octopus.info,  Node: Coordinates,  Next: Velocities,  Prev: Species,  Up: Input file options

Coordinates
-----------

   `octopus' successively tries to read the atomic coordinates from a
PDB file, a XYZ file, or else directly from the `inp' file.
   * `PDBCoordinates' (string, 'coords.pdb') :   Tries to read the
     atomic coordinates from the file `PDBCoordinates'.    The PDB
     (Protein Data Bank (http://www.rcsb.org/pdb/)) format is   quite
     complicated, and it goes well beyond the scope of this manual. You
      can find a comprehensive description in
     `http://www.rcsb.org/pdb/docs/format/pdbguide2.2/guide2.2_frame.html'.
      From the plethora of instructions defined in the PDB standard,
     `octopus'   only reads 2, `ATOM' and `HETATOM'. From these fields,
     it reads:
        - columns 13-16 : The specie; in fact `octopus' only cares
          about the first     letter - 'CA' and 'CB' will both refer to
          Carbon - so elements whose     chemical symbol has more than
          one letter can not be represented in this way.      So, if
          you want to run mercury ('Hg') please use one of the other
          two methods     to input the atomic coordinates,
          `XYZCoordinates' or `Coordinates'.

        - columns 18-21 : The residue. If residue is 'QM', the atom is
          treated     in Quantum Mechanics, otherwise it is simply
          treated as an external classical     point charge. Its charge
          will be given by columns 61-65.

        - columns 31-54 : The Cartesian coordinates. The Fortran format
          is     `'(3f8.3)''.

        - columns 61-65 : Classical charge of the atom. The Fortran
          format is     `'(f6.2)''.

   * `XYZCoordinates' (string, 'coords.xyz') :   If `PDBCoordinates' is
     not present, reads the atomic coordinates   from the XYZ file
     `XYZCoordinates'. The XYZ format is very simple,   as can be seem
     from this example for the CO molecule (in AA).
              2
                CO molecule in equilibrium
              C  -0.56415   0.0   0.0
              O   0.56415   0.0   0.0
       The first line of the file has an integer indicating the number
     of   atoms. The second can contain comments that are simply
     ignored by   `octopus'. Then there follows one line per each atom,
     containing   the chemical species and the Cartesian coordinates of
     the atom.

   * `Coordinates' (block data) :   If neither a `XYZCoordinates' or a
     `PDBCoordinates' was found,   `octopus' tries to read the
     coordinates for the atoms from the   block `Coordinates'. The
     format is quite straightforward:
              %Coordinates
                'C' | -0.56415 | 0.0 | 0.0 | no
                'O' |  0.56415 | 0.0 | 0.0 | no
              %
       The first line defines a Carbon atom at coordinates (`-0.56415',
      `0.0', `0.0'), that is _not_ allowed to move during   dynamical
     simulations. The second line has a similar meaning. This   block
     obviously defines a Carbon monoxide molecule, if the input   units
     are AA. Note that this in this way, as opposed to specifying   the
     `PDBCoordinates' or `XYZCoordinates' file, it is possible   to fix
     some of the atom (fixing all the atoms is always possible trough
     the `MoveIons' variable).

   * `AdjustCoordinates' (logical, false) :   If true, translates the
     atom coordinates so that the   geometrical centre of the molecule
     coincides with the zero of   the mesh, and rotates them, fixing
     the largest dimension   of the molecule to the axis defined
     through `MainAxis'.    Very useful when handling large and
     elongated molecules - try   it out!

   * `MainAxis' (block data) :   Defines the axis to be used if
     `AdjustCoordinates' is true.    If not set defaults to the z axis.

   * `OutputCoordinates' (logical, false) :   If true `octopus' outputs
     a XYZ file called   '`SystemName'.xyz' containing the coordinates
     of the atoms   treated within Quantum Mechanics. If point charges
     were defined   in the PDB file (see `PDBCoordinates'), they will
     be output   in the file '`SystemName_classical.xyz''.


File: octopus.info,  Node: Velocities,  Next: Mesh,  Prev: Coordinates,  Up: Input file options

Velocities
----------

   * `XYZVelocities' (string, 'velocities.xyz') :   `octopus' will try
     to read the starting velocities of the atoms from the XYZ file
     `XYZVelocities'.

   * `Velocities' (block data) :   If `XYZVelocities' is not present,
     `octopus' will try fetch the initial   atomic velocities from this
     block. If this block is not present, `octopus'   will reset the
     initial velocities to zero. The format of this block can be
     illustrated by this example:
              %Velocities
                'C'  | -1.7 | 0.0 | 0.0
                'O'  |  1.7 | 0.0 | 0.0
              %
       It describes one Carbon and one Oxygen moving at the relative
     velocity of `3.4', velocity units.
   Note: it is important to maintain for the velocities the ordering in
which the species were defined in the coordinates specifications.


File: octopus.info,  Node: Mesh,  Next: States,  Prev: Velocities,  Up: Input file options

Mesh
----

   `octopus' uses a grid in real space to solve the Kohn-Sham equations.
The grid is equally-spaced, but the spacings can be different for each
Cartesian direction. The shape of the simulation region may also be
tuned to suit the geometric configuration of the system.

   * `BoxShape' (integer, sphere) : It is the shape of the simulation
     box. The allowed values are:
        - `sphere' or `1': A sphere

        - `cylinder' or `2': A cylinder. The cylinder axis will be in
          the z direction

        - `minimum' or `3': Sum of spheres around each atom.

        - `parallelepiped' or `4': As the name indicates.
     For a 1D calculation, it would obviously always be a 1D "sphere".

   * `Radius' (double, 20.0 a.u.) : If `BoxShape != parallelepiped'
     defines the radius of the spheres or of the cylinder.

   * `Lsize' (block data) : In case `BoxShape = parallelepiped', this
     is assumed to be a block of the form:
              %Radius
                sizex | sizey | sizez
              %
     where the `size*' are half of the lengths of the box in each
     direction.

   * `ZLength' (double, 1.0 a.u.) : If `BoxShape == cylinder' is half
     the total length of the cylinder.

   * `Spacing' (double, 0.6 a.u.) or (block data) : If the code is
     compiled in 1D mode or if `BoxShape != parallelepiped' defines the
     (constant) spacing between points in the grid. Otherwise, it is
     assumed to be a block of the form:
              %Spacing
                spacingx | spacingy | spacingz
              %

   * `DerivativesSpace' (integer, real_space) Defines in which space
     gradients and the laplacian are calculated. Allowed values are:
        - `real_space' or `0' : Derivatives are calculated in real-space
               using finite differences. The order of the derivative
          can be set with       `OrderDerivatives'.

        - `fourier_space' or `1' : Derivatives are calculated in
          reciprocal space. Obviously this case implies cyclic boundary
          conditions,       so be careful.

   * `OrderDerivatives' (integer, 4) : If `DerivativesSpace ==
     real_space' use a finite difference discretisation of this order
     for the derivatives, that is a `OrderDerivatives*2 + 1' formula.
     See (MISSING ARTICLE) for details.

   * `DoubleFFTParameter' (real, 2.0): For solving Poisson equation in
     Fourier space, and for applying the local potential in Fourier
     space, an auxiliary cubic mess is built. This mesh will be larger
     than the circunscript cube to the usual mesh by a factor
     `DoubleFFTParameter'. See the section that refers to Poisson
     equation, and to the local potential for details.



File: octopus.info,  Node: States,  Next: Hamiltonian,  Prev: Mesh,  Up: Input file options

States
------

   * `SpinComponents' (integer, 1) : Defines the spin mode `octopus'
     will run in. Valid modes are:
        - `1' : Spin-unpolarised calculation.

        - `2' : Spin-polarised calculation (collinear spin). This mode
          will double the number of wave-functions necessary for a
          spin-unpolarised calculation.

        - `3' : Non-collinear spin. This mode will double the number of
          wave-functions necessary for a spin-unpolarised calculation,
          and each of the wave-functions will be a 2-spinor.

   * `NumberKPoints' (integer, 1) : If `octopus' was compiled for
     periodic systems, the number of _k_ points to use in the
     calculation. If `NumberKPoints == 1', use only the Gamma point.
     (Note: current version in fact does not implement this
     possibility. Setting this variable to more that 1 may lead to
     erroneous results).

   * `ExcessCharge' (double, 1) : The net charge of the system. A
     negative value means that we are adding electrons, while a
     positive value means we are taking electrons from the system.

   * `ExtraStates' (integer, 1) : How many unoccupied states to use in
     the ground-state calculation. Note that this number is unrelated
     to `CalculationMode == 4'.

   * `Occupations' (blockdata) : The occupation numbers of the orbitals
     can be fixed through the use of this variable. For example:
              %Occupations
                2.0 | 2.0 | 2.0 | 2.0 | 2.0
              %
     would fix the occupations of the five states to `2.0'. There must
     be as many columns as states in the calculation. If
     `SpinComponents == 2' this block should contain two lines, one for
     each spin channel.  This variable is very useful when dealing with
     highly symmetric small systems (like an open shell atom), for it
     allows us to fix the occupation numbers of degenerate states in
     order to help `octopus' to converge. This is to be used in
     conjuction with `ExtraStates'. For example, to calculate the
     carbon atom, one would do:
            ExtraStates=2
            %Occupations
                2 | 2/3 | 2/3 | 2/3
              %

   * `ElectronicTemperature' (double, 0.0) If `Occupations' is not set,
     `ElectronicTemperature' is the temperature in the Fermi-Dirac
     function used to distribute the electrons among the existing
     states.



File: octopus.info,  Node: Hamiltonian,  Next: Exchange and correlation,  Prev: States,  Up: Input file options

Hamiltonian
-----------

   * `NonInteractingElectrons' (logical, false) :   If `true', treat
     the electrons as non-interacting, i.e. neglect both   Hartree and
     exchange-correlation contributions to the Kohn-Sham potential.
     A probable choice for one-electron problems.

   * `ClassicPotential' (logical, false) : If `true', add to the
     external potential the potential generated by the point charges
     read from the PDB input (see `PBDCoordinates').

   * `LocalPotentialSpace' (integer, fourier_space) : If
     `fourier_space', generate the local part of the pseudo-potential
     in Fourier space; Otherwise do it directly in real space. The
     auxiliary box defined via the `DoubleFFTParameter' is used for
     this purpose.

   * `NonLocalPotentialSpace' (integer, real_space) : If
     `fourier_space' generate the non-local part of the pseudo-potential
     in Fourier space; Otherwise do it directly in real space.
     _Generating the potential in Fourier space seems to reduce the
     egg-box effect but this option has not been extensively tested._

   * `GridRefinement' (integer, 3) : If `NonLocalPotentialSpace ==
     fourier_space', a grid refinement technique is applied to reduce
     the error in the calculation of the nonlocal projectors. This
     variable defines the number of points to interpolate between the
     normal mesh points, in order to apply this  method. _This seems to
     reduce the egg-box effect but this option has not been extensively
     tested._



File: octopus.info,  Node: Exchange and correlation,  Next: SCF,  Prev: Hamiltonian,  Up: Input file options

Exchange and correlation
------------------------

   The exchange-correlation functional is controlled by the 4
parameters `XFamily', `XFunctional', `CFamily' and `CFunctional'.
Obviously, the `X' parameters control the exchange part of the
functional, while the `C' parameters control the correlation. The
possible values are:

   * `XFamily == 'ZER'' : No exchange.

   * `XFamily == 'LDA'' : Local density approximation.
        - `XFunctional == 'NREL'' : Non-relativistic exchange.

        - `XFunctional ==  'REL'' : Relativistic exchange.

   * `XFamily == 'GGA'' : Generalised gradient approximations.
        - `XFunctional ==  'PBE'' :  J.P.Perdew, K.Burke and
          M.Ernzerhof,     	PRL *77*, 3865 (1996)

        - `XFunctional == 'PBER'' : PBE with some relativistic
          corrections.

        - `XFunctional == 'LB94'' : van Leeuwen and Baerends functional.

   * `XFamily == 'KLI'' : Optimised effective potential method within
     the Krieger, Lee and Iafrate approximation.
        - `XFunctional ==   'X'' : Exact exchange functional.

        - `XFunctional == 'SIC'': Self interaction corrected LDA.

   And now comes the correlation variables:

   * `CFamily == 'ZER'' : No correlation

   * `CFamily == 'LDA'' : Local density approximation.
        - `CFunctional ==   'PZ81'' :  Perdew and Zunger,       PRB
          *23*, 5075 (1981)

        - `CFunctional == 'PW92'' : J.P.Perdew and Y.Wang,       PRB
          *45*, 13244 (1992)

   * `CFamily == 'GGA'' : Generalised gradient approximations.
        - `CFunctional == 'PBE'' : J.P.Perdew, K.Burke and M.Ernzerhof,
             	PRL *77*, 3865 (1996)

   * `CFamily == 'KLI'': Optimised effective potential method within
     the Krieger, Lee and Iafrate approximation.
        - `CFunctional == 'SIC'': Self interaction corrected LDA.


File: octopus.info,  Node: SCF,  Next: Unoccupied States,  Prev: Exchange and correlation,  Up: Input file options

SCF
---

   The self consistent procedure will stop when the first of the
convergence criteria is fulfilled.
   * `MaximumIter' (integer, 200) : Maximum number of SCF iterations.
     `0' means unlimited.

   * `ConvAbsDens' (double, 1e-5) : Absolute convergence of the
     density. `0' means do not use this criterion.

   * `ConvRelDens' (double, 0.0) : Relative convergence of the density.
     `0' means do not use this criterion.

   * `ConvAbsEnergy' (double, 0.0) : Absolute convergence of the total
     energy. `0' means do not use this criterion.

   * `ConvRelEnergy' (double, 0.0) : Relative convergence of the total
     energy. `0' means do not use this criterion.

   There are some more variables controlling the SCF cycle:
   * `LCAOStart' (logical, true) : Before starting a SCF calculation,
     performs a LCAO calculation. these should provide `octopus' with a
     good set of initial wave-functions, and help the convergence of
     the SCF cycle.  (Up to current version, only a minimal basis set
     used).

   * `SCFinLCAO' (logical, false) : Performs all the SCF cycle
     restricting the calculation to the LCAO subspace.  This may be
     useful for systems with convergence problems (first do a
     calculation within the LCAO subspace, then restart from that point
     for an unrestricted calculation).

   * `EigenSolver' (integer, 0) : At each SCF cycle step, a
     diagonalisation of the Hamiltonian is performed.  This variables
     tells which eigensolver to use to diagonalise the Kohn-Sham
     Hamiltonian.  Possible values are:
        - `0' : Conjugated Gradients method I.

        - `1' : Conjugated Gradients method II.
     Method I should be better. Look up the source to know what the
     differences are.

     In both cases, for the first iterations of the cycle there is no
     need to perform a very precise diagonalisation. Because of this,
     we may define a varying tolerance, so that at the first iteration
     a given small tolerance is achieved, and then this tolerance is
     linearly increased until a given iteration, after which a maximum
     tolerance is always asked.  Next variables take care of this
     process. This possiblity is only available when method 0 is used.

   * `EigenSolverInitTolerance' (double, 1.0e-10) : When `EigenSolver
     == 0' is the initial tolerance for the eigenvectors.

   * `EigenSolverFinalTolerance' (double, 1.0e-14) : When `EigenSolver
     == 0' is the final tolerance for the eigenvectors.

   * `EigenSolverFinalToleranceIteration' (integer, 7) : When
     `EigenSolver == 0' determines how many interactions are needed to
     go from `EigenSolverInitTolerance' to `EigenSolverFinalTolerance'.

   * `EigenSolverMaxIter' (integer, 25) : When `EigenSolver == 0'
     determines the maximum number of iterations for the eigensolver --
     that is, if this number is reached, the diagonalisation is stopped
     even if the desired tolerance was not achieved.

   * `NumberCG' (integer, 3) : When `EigenSolver == 1' determines the
     number of conjugated gradient steps per iteration.

   * `TypeOfMixing' (integer, 0) : Selects the mixing procedure for the
     density during the SCF cycle. Possible values are:
        - `0' : Linear mixing.

        - `1' : Reserved for Anderson-Pulay mixing; currently not
          implemented.

        - `2' : Broyden mixing.

   * `Mixing' (double, 0.3) : Determines the amount of the new density
     which is to be mixed with the old density.

   * `BroydenNumber' (integer, 3) : Number of steps used by Broyden
     mixing to extrapolate the new density.



File: octopus.info,  Node: Unoccupied States,  Next: Time Dependent,  Prev: SCF,  Up: Input file options

Unoccupied States
-----------------

   These variables are only used in `CalculationMode == 3, 4' (or in 5
and 6 if `TDOccupationalAnalysis == 1'.)
   * `UnoccNumberStates' (integer, 5) :   How many unoccupied states to
     compute.

   * `UnoccMaximumIter' (integer, 200) :   Maximum number of iterations
     while calculating the unoccupied states.    Note that this are
     _not_ SCF iterations, for the density and the   Hamiltonian are
     not updated!

   * `UnoccConv' (double, 1e-4) :   Absolute convergence in the
     eigenvectors. So don't try to put it too   good or else you won't
     converge.


File: octopus.info,  Node: Time Dependent,  Next: Photo-electron spectrum,  Prev: Unoccupied States,  Up: Input file options

Time Dependent
--------------

   * `TDMaximumIter' (integer, 1500) : Number of time steps.

   * `TDSaveIter' (integer, 100) : Output stuff every `TDSaveIter'
     steps.

   * `TDEvolutionMethod' (integer, 3) : Method used to perform the time
     propagation. Authorised values are:
        - `1' : "Old-Style" method. One should check carefully the
          time-step, and it only works with density based functionals.
          It is quick per time step, but allows for very small
          time-steps.

        - `2' : Method designed to enforce the time-reversal symmetry.
          Better time steps. Default.

        - `3' : A modification of previous method to make it faster.
          It is based on extrapolation of the time dependent
          potentials. Due to some unknown problems, currently being
          investigated, it is not the default method.

        - `4' : Exponential midpoint rule. In principle, it should  also
          respect the time-reversal symmetry.

   * `TDExponentialMethod' (integer, 1) : Method used to numerically
     calculate the exponential of the hamiltonian, a core part of the
     calculation in any of the previously described methods to perform
     the evolution.
        - `1' : N-th order expansion of the exponential.

        - `2' : Lanczos approximation. Allows for larger time-steps.
          However, the larger the time-step, the longer the time per
          time-step. In certain cases, if the time-step is too large,
          the code will emit a warning whenever it considers that the
          evolution may not be proberly proceeding - the Lanczos
          process did not converge. This possibility is still somehow
          experimental. (REFERENCE MISSING).

        - `3' : Split-operator.

        - `4' : Suzuki-Trotter (REFERENCE MISSING). This is a
          higher-order split-operator based method.

        - `5' : N-th order Chebyshev expansion. In principle, the
          Chebyshev expansion of the exponential represents it more
          accurately than the canonical expansion (method 1). This is
          only true for high orders, though.

   * `TDExpOrder' (integer, 4) : For `TDExponentialMethod' equal `1' or
     `5', the order to which the exponential is expanded. For the
     Lanczos approximation, it is the maximum Lanczos-subspace
     dimension.

   * `TDLanczosTol' (real, 1e-4) : An internal tolerance variable for
     the Lanczos method. The smaller, the more precise the exponential
     is calculated.

   * `TDTimeStep' (double, 0.07 a.u.) :   Time step for the propagation.

   * `TDLasers' (block data) : Each line of the block describes a laser
     pulse applied to the system.  The syntax is:
              %Lasers
                polx | poly | polz | A0 | omega0 | envelope | tau0 | t0
              %
     where `pol' is the (complex) polarisation of the laser field, `A0'
     the amplitude, `envelope' the envelope function, `t0' the middle
     (maximum) of the pulse and `omega0' the frequency of the pulse.
     The meaning of `tau0' depends on the envelope function.  The
     possible values for `envelope' are:
        - `1' : Gaussian envelope. `tau0' is the standard deviation
           of the pulse.

        - `2' : Cosinoidal envelope. `tau0' is half the total length
            of the pulse.

        - `3' : Ramp. In this case there is an extra parameter
          `tau1'. `tau0' is the length of the constant part of the ramp,
               and `tau1' is the raising (decaying) time. `tau1'
          should be       an extra field after `t0'

        - `4' : Shape is read from a file.

     If `envelope=4', the `t0' parameter is substituted by a string that
     determines the name of the file. The format of this file should be
     three columns of real numbers: time, field and phase. Atomic units
     are assumed. The values for the laser field that the program will
     use are interpolated / extrapolated from this numerically defined
     function.

   * `TDGauge' (integer, 0) : In which gauge to treat the laser.
     Options are:
        - `1' : Length gauge.

        - `2' : Velocity gauge.

   * `TDOutputLaser' (logical, false) : If `true', `octopus' outputs
     the laser field to the file '`laser.out''.

   * `TDDeltaStrength' (double, 0.0 a.u.)  When no laser is applied, a
     delta (in time) electric field with strength `TDDeltaStrength' is
     applied. This is used to calculate the linear optical spectra.

   * `TDPolarization' (block data) The (real) polarisation of the delta
     electric field. The format of the block is:
              %TDPolarization
                polx | poly | polz
              %

   * `TDAbsorbingBoundaries' (integer, 0) : To improve the quality of
     the spectra by avoiding the formation of standing density waves,
     one can make the boundaries of the simulation box absorbing. The
     possible values for this parameter are:
        - `0' : No absorbing boundaries.

        - `1' : A sin^2 imaginary potential is added at the boundaries.

        - `2' : A mask is applied to the wave-functions at the
          boundaries.

   * `TDABWidth' (real, 0.4 a.u.) : Width of the region used to apply
     the absorbing boundaries.

   * `TDABHeight' (real, -0.2 a.u.) : When `TDAbsorbingBoundaries ==
     1', is the height of the imaginary potential.

   * `TDDipoleLmax' (integer , 1) : Maximum multi-pole of the density
     output to the file '`Sysname'.mult' during a time-dependent
     simulation.

   * `TDOccupationalAnalysis' (logical, false) : If true, outputs the
     projections of the time-dependent Kohn-Sham wave-functions onto
     the static (zero time) wave-functions to the file '`Sysname'.proj'.

   * `MoveIons' (integer, 0) : What kind of simulation to perform.
     Possible values are:
        - `0' : Do not move the ions.

        - `1' : Steepest descents.

        - `2' : Damped Newtonian dynamics using Verlet.

        - `3' : Newtonian dynamics using Verlet.

        - `4' : Newtonian dynamics using velocity Verlet.

        - `5' : Minimisation using conjugated gradients.
     But in fact, for a time-dependent simulation can only takes the
     values `0', `3', and `4'. The rest are ignored in present version.



File: octopus.info,  Node: Photo-electron spectrum,  Next: Geometry optimization,  Prev: Time Dependent,  Up: Input file options

Photo-electron spectrum
-----------------------

   * `CalcPES_rc' (logical, false) :   If `true', store the wave
     functions in specific points in order to calculate the
     photo-electron spectrum in a point far in the box as proposed in
     A. Pohl, P.-G. Reinhard, and E. Suraud Phys. Rev. Lett. *84*, 5090
     (2000).

   * `PES_rc_points' (block data) :   List of points where to calculate
     the photo-electron spectrum a la Suraud.    The exact syntax is:
              %TDPES_rc_points
                x1 | y1 | z1
              %

   * `CalcPES_mask' (logical, false)   If `true', calculate the
     photo-electron spectrum using the mask method   (M. Marques, D.
     Varsano, H. Appel, E.K.U. Gross and A. Rubio to be submitted).
     In order for this to work, masking boundaries are necessary
     (`TDAbsorbingBoundaries == 2').



File: octopus.info,  Node: Geometry optimization,  Next: Function output for visualization,  Prev: Photo-electron spectrum,  Up: Input file options

Geometry optimization
---------------------

   * `GOMethod' (integer, 1)   Method by which the minimization is
     performed. Its possible values are   `1' for a simple steepest
     descent, `2' for   Polak-Ribiere conjugate-gradients, `3' for
     Fletcher-Reeves conjugate gradient   and `4' for
     Broyden-Fletcher-Goldfarb-Shanno conjugate gradient. This latter
     one should be the most sophisticated and fast one.

   * `GOTolerance' (real, 0.0001)   Convergence criterium to stop the
     minimization. In units of force; minimization   is stopped when
     all forces on ions are smaller.

   * `GOMaxIter' (integer, 200)   Even if previous convergence
     criterium is not satisfied, minimization will stop   after this
     number of iterations.



File: octopus.info,  Node: Function output for visualization,  Next: Spectrum calculations,  Prev: Geometry optimization,  Up: Input file options

Function output for visualization
---------------------------------

   Every given number of time iterations, or after ground-state
calculations, some of the functions that characterise the system may be
written to disk so that they may be analized. Files are written within
"static" output directory after the self-consistent field, or within
"td.x" directories, during evolution, where "x" stands for the
iteration number at which each write is done.
   * `OutputKSPotential' (logical, false)  Prints out Kohn-Sham
     potential, separated by parts. File names would be "v0" for  the
     local part, "vc" for the classical potential (if it exists), "vh"
     for the  Hartree potential, and "vxc-x" for each of the exchange
     and correlation potentials  of a give spin channel, where "x"
     stands for the spin channel.

   * `OutputDensity' (logical, false)  Prints out the density. Filename
     would be "density-x", where "x" stands for  the spin channel.

   * `OutputWfs' (logical, false)  Prints out wave-functions. Which
     wavefunctions are to be printed is specified  by the variable
     `OutputWfsNumber' - see below. Filenames would be  "wf-k-p-i",
     where k stands for the _k_ number, p for the state, and  i for the
     spin channel.

   * `OutputWfsNumber' (string, "1-1024")   Which wavefunctions to
     print, in list form, i.e., "1-5" to print the first five states,
     "2,3" to print the second and the third state, etc.

   * `OutputELF' (logical, false)  Prints out the electron localization
     function, ELF. Filename would be "elf-i", where  i stands for the
     spin channel.


   How are they printed? This is controlled by the next set of
variables:

   * `OutputPlaneX' (logical, false) A plane slice at x=0 is printed.
     The string ".x=0" is appended to previous file names.

   * `OutputPlaneY' (logical, false) A plane slice at y=0 is printed.
     The string ".y=0" is appended to previous file names.

   * `OutputPlaneZ' (logical, false) A plane slice at y=0 is printed.
     The string ".z=0" is appended to previous file names.

   * `OutputDX' (logical, false) For printing all the three dimensional
     information, the open source program visualization tool OpenDX
     (http://www.opendx.org/) is used. The string ".general" is
     appended to previous file names. However, this feature is still in
     developing proccess. More information in future releases of this
     manual, or else ask directly to `octopus-users@tddft.org'.


   How often are they printed? At a given time-step, two conditions
must be fulfilled in order to output the desired functions. First, the
iteration number must be a multiple of `TDSaveIter'. Second, it must be
a multiple of:

   * `OutputEvery' (integer, 1000)



File: octopus.info,  Node: Spectrum calculations,  Next: Varia,  Prev: Function output for visualization,  Up: Input file options

Spectrum calculations
---------------------

   Once `octopus' has been run, results must be analyzed somehow. The
most common thing is to Fourier-transform something to calculate
spectra. This may be done through some utilities (`strength-function',
`hs-from-mult', `hs-from-acc' which are described in section "External
utilities." Common options read by these utilities are:
   * `SpecTransMode' (string, 'sin')   What kind of Fourier transform
     is calculated. 'sin' and 'cos' are the valid options,   with
     obvious meanings.

   * `SpecDampMode' (string, 'exp')   A damping function may be applied
     to the input fuction before processing the Fourier   transform.
     This function may be an exponential or a polynomial: 'exp' or
     'pol'. If   this variable is not present or has any other value,
     no damping function is applied.

   * `SpecDampFactor' (real, 0.0)   If `SpecDampMode' is set to `exp',
     the damping parameter of the exponential   is fixed through this
     variable.

   * `SpecStartTime' (real, 0.0)   Processing is done for the given
     function in a time-window that starts at the   value of this
     variable.

   * `SpecEndTime' (real, -1.0)   Processing is done for the given
     function in a time-window that ends at the   value of this
     variable.

   * `SpecEnergyStep' (real, 0.05)   Sampling rate for the spectrum.

   * `SpecMinEnergy' (real, 0.0)   The Fourier transform is calculated
     for energies bigger than this value.

   * `SpecMaxEnergy' (real, 20.0)   The Fourier transform is calculated
     for energies smaller than this value.

   * `HSPolarization' (string, 'z')   For the utilities `hs-from-acc',
     and `hs-from-mult', the polarization   of the laser pulse must be
     specified. Valid values are 'x', 'y' and 'z' for   lasers linearly
     polarized along the respective axis, or '+' or '-' for lasers
     circularly polarized. See the description of `hs-from-acc' and
     `hs-from-mult'   for more details.



File: octopus.info,  Node: Varia,  Prev: Spectrum calculations,  Up: Input file options

Varia
-----

   * `PoissonSolver' (integer, 3) :   In 3D defines which method to use
     in order to solve the Poisson equation.    Allowed values are:
        - `1' : Conjugated gradient method.

        - `3' : FFTs with spherical cutoff.
       The value of variable `DoubleFFTParameter' is used in case `3'
     method   is used.

   * `POLStaticField' (double, 0.001 a.u.) :   Magnitude of the static
     field used to calculate the static polarizability   in
     `CalculationMode = 7, 8'.

   * `RecipeLang' (string, 'en') :   In `CalculationMode = 99' defines
     the language in which to print   the recipe. Allowed values are
     (for now) `'en'' and `'es''.



File: octopus.info,  Node: External utilities,  Next: Examples,  Prev: The input file,  Up: Top

External utilities
******************

   A few small programs are generated along with `octopus', for the
purpose of post-processing the generated information. These utilities
should all be run from the directory where `octopus' was run, so that
it may see the `inp' file, and the directories created by it.

* Menu:

* strength-function::
* hs-from-mult::
* hs-from-acc::
* function-to-dx::
* nbo2xyz::


File: octopus.info,  Node: strength-function,  Next: hs-from-mult,  Prev: External utilities,  Up: External utilities

`strength-function'
===================

   This utility generates the dipole strength function of the given
system.  Its main input is the `td.general/multipoles' file. Output is
written to a file called `system.spectrum' where `system' is the system
name, as defined in `SystemName' variable. This file is made of two
columns: energy (in eV or a.u., depending on the units specified in
`inp'), and dipole strength function (in 1/eV, or 1/a.u., idem).

   In the `inp' file, the user may set the `SpecTransformMode' - this
should be set to 'sin' for proper use -, the `SpecDampMode' -
recommended value is 'pol', which ensures fulfilling of the N-sum rule,
the `SpecStartTime', the `SpecEndTime', the `SpecEnergyStep', the
`SpecMinEnergy' and the `SpecMaxEnergy'.


File: octopus.info,  Node: hs-from-mult,  Next: hs-from-acc,  Prev: strength-function,  Up: External utilities

`hs-from-acc'
=============

   Calculates the harmonic spectrum, out of the acceleration file. To
do.


File: octopus.info,  Node: hs-from-acc,  Next: function-to-dx,  Prev: hs-from-mult,  Up: External utilities

`hs-from-mult'
==============

   Calculates the harmonic spectrum, out of the multipoles file. To do.


File: octopus.info,  Node: function-to-dx,  Next: nbo2xyz,  Prev: hs-from-acc,  Up: External utilities

`function-to-dx'
================

   Outputs functions in OpenDX format, from restart files. To do.


File: octopus.info,  Node: nbo2xyz,  Prev: function-to-dx,  Up: External utilities

`nbo2xyz'
=========

   Reads out the `td.general/coordinates' file, and makes a movie in
XYZ format. To do.


File: octopus.info,  Node: Examples,  Next: Options Index,  Prev: External utilities,  Up: Top

Examples
********

* Menu:

* Hello world::
* Benzene::


File: octopus.info,  Node: Hello world,  Next: Benzene,  Prev: Examples,  Up: Examples

Hello world
-----------

   As a first example, we will take a sodium atom.  With your favourite
text editor, create the following input 'inp'.
       SystemName = 'Na'
       CalculationMode = 1
       %Species
         'Na' | 22.989768 | 11 | "tm" | 0 | 0
       %
       %Coordinates
         'Na' | 0.0 | 0.0 | 0.0 | no
       %
       Radius = 12.0
       Spacing = .6
       TypeOfMixing = 2

   This input file should be essentially self-explanatory.  Note that a
Troullier-Martins pseudopotential file ('Na.vps', or 'Na.ascii') should
be accesible to the program. A sample 'Na.ascii' may be found in
`OCTOPUS-HOME/share/PP/TM2'. If `octopus' was installed (`make install'
was issued after `make'), there should be no need to do anything - the
program should find it. Otherwise, you may as well place it in the
working directory.  Then run `octopus' - for example, do `> octopus >
out ', so that the output is stored in "out" file. If everything goes
OK, "out" should look like (1):
     Info: Calculation started on 2002/07/10 at 12:35:12
     Info: Reading pseudopotential from file:
           '/home/alberto/share/octopus/PP/TM2/Na.ascii'
     Info: l =  0 component used as local potential
     
     **********   Pseudopotential Information for: Na   **********
     **********   FLAVOUR: TROULLIER-MARTINS.
     Z    :    11.0000
     Z_val:     1.0000
     Exchange/correlation used in generation: ca
     Relativistic character of calculations: nrl
     Type of core corrections: nc
     Signature of pseudopotential:
           ATM3      no_date   Troullier-Martins
     Valence configuration in calculations:
      (orbital - occupancy - core radius)
       3s 1.00  r= 2.94
       3p 0.00  r= 2.94
       3d 0.00  r= 2.94
       4f 0.00  r= 2.94
     Maximum L-component to consider:  0
     Maximum L-component in file:  3
     Radial grid parameters ( R(I) = B*[ EXP(A*(I-1)) -1 ] )
                  A =   1.250000E-02
                  B =   2.253411E-04
     Number of radial points:  1054
     nrval:  1055
     PS-generation cut-off radii: [b]  2.94000  2.94000  2.94000  2.94000
     KB-spheres radii:            [b]  0.00000
     KB-cosines: [H]
                         0.000000
     KB-norms: [1/H]
                         0.000000
     Eigenvalues of pseudo-eigenfunctions [H]
                        -0.103582
     Atomic radius: [b]          0.000000
     *************************************************************
     
       Type = sphere           Radius [b] =  12.000
       Spacing [b] = ( 0.600, 0.600, 0.600)    volume/point [b^3] =  0.21600
       # inner mesh =  33401   # outer mesh =  18896
     Info: Derivatives calculated in real-space
     Info: FFTs used in a double box (for poisson | local potential)
           box size = (  81,  81,  81)
           alpha =      2.00000
     Info: Using FFTs to solve poisson equation with spherical cutoff.
     Info: Exchange and correlation
           Exchange    family    : LDA
                       functional: non-relativistic
           Correlation family    : LDA
                       functional: Perdew-Zunger
     Info: Allocating rpsi.
     Info: Random generating starting wavefunctions.
     Info: Unnormalized total charge =      0.998807
     Info: Setting up Hamiltonian.
     Info: Performing LCAO calculation.
     Info: LCAO basis dimension:      1
     Info: SCF using real wavefunctions.
     Eigenvalues [H]
        #  Eigenvalue   Occupation      Error (1)
        1    -0.103155     1.000000 (  0.03163190)
     Info: iter =    1 abs_dens = 0.52967163E-03 abs_ener = 0.60356585E+00
     Eigenvalues [H]
        #  Eigenvalue   Occupation      Error (1)
        1    -0.102979     1.000000 (  0.00157339)
     Info: iter =    2 abs_dens = 0.43190643E-03 abs_ener = 0.19440656E-04
     Eigenvalues [H]
        #  Eigenvalue   Occupation      Error (1)
        1    -0.102509     1.000000 (  0.00047779)
     Info: iter =    3 abs_dens = 0.60478810E-04 abs_ener = 0.57300542E-05
     Eigenvalues [H]
        #  Eigenvalue   Occupation      Error (1)
        1    -0.102419     1.000000 (  0.00011716)
     Info: iter =    4 abs_dens = 0.24075874E-04 abs_ener = 0.18799904E-06
     Eigenvalues [H]
        #  Eigenvalue   Occupation      Error (1)
        1    -0.102437     1.000000 (  0.00000170)
     Info: iter =    5 abs_dens = 0.24608978E-06 abs_ener = 0.26917229E-08
     Info: SCF converged in    5 iterations
     Info: Deallocating rpsi.
     Info: Calculation ended on 2002/07/10 at 12:35:34
      STOP
   Take now a look at the working directory. It should include the
following files:
     -rw-rw-r--    1 user  group       177 Jul 10 12:29 inp
     -rw-rw-r--    1 user  group      4186 Jul 10 12:35 out
     -rw-rw-r--    1 user  group      1626 Jul 10 12:35 out.oct
     drwxrwxr-x    2 user  group      4096 Jul 10 12:35 static
     drwxrwxr-x    2 user  group      4096 Jul 10 12:35 tmp

   Besides the initial file (`inp') and the `out' file, two new
directories appear. In `static', you will find the file `info', with
information about the static calculation (it should be hopefully
self-explanatory, otherwise please complain to the authors).  In `tmp',
you will find the `restart.static', a binary file containg restart
information about the ground-state, which is used if, for example, you
want to start a time-dependent calculation afterwards.  Finally, you
can safely ignore `out.oct': it is an output from the liboct library,
irrelevant in what concerns physics ;).

   *Exercises* :
   * Study how the total energy and eigenvalue of the sodium atom
     improve   with the mesh spacing.

   * Calculate the static polarizability of the sodium atom
     (`CalculationMode = 7').    Two new files will be generated:
     `restart.pol' that can be used to resume   the polarizability
     calculation, and `Na.pol' that contains the static polarizability
     tensor. Note that this calculation overwrites
     `tmp/restart.static', so that   what now is there is the ground
     state for the system _with_ an external static   electrical field
     applied. Delete it since it is useless.

   * Calculate a few unoccupied states (`CalculationMode = 3'). The
     eigenspectrum   will be in the file `eigenvalues'. Why don't we
     find a Rydberg series in the   eigenspectrum?

   * Repeat the previous calculation with PBE, LB94, and exact exchange.
      Don't forget to *move* the file `tmp/restart.static' when
     switching   between exchange-correlation functionals.

   * Perform a time-dependent evolution (`CalculationMode = 5'), to
     calculate   the optical spectrum of the Na atom. Use a
     `TDDeltaStrength = 0.05', polarised   in the `x' direction. The
     multipole moments of the density are output to   the file
     `td.general/multipoles'. You can process this file with the utility
      `strength-function' to obtain the optical spectrum.    If you
     have computer time to waste, re-run the time-dependent
     simulation for some other xc choices.


   ---------- Footnotes ----------

   (1) Before this output, a beautiful octopus ascii-art picture may be
printed...


File: octopus.info,  Node: Benzene,  Prev: Hello world,  Up: Examples

Benzene
-------

   Well, the sodium atom is a bit too trivial. Let's try something
harder: benzene.  you will just need the geometry for benzene to be
able to play. Here it is (in AA):
      C  0.000  1.396  0.000
      C  1.209  0.698  0.000
      C  1.209 -0.698  0.000
      C  0.000 -1.396  0.000
      C -1.209 -0.698  0.000
      C -1.209  0.698  0.000
      H  0.000  2.479  0.000
      H  2.147  1.240  0.000
      H  2.147 -1.240  0.000
      H  0.000 -2.479  0.000
      H -2.147 -1.240  0.000
      H -2.147  1.240  0.000

   Follow now the steps of the previous example. Carbon and Hydrogen
have a much harder pseudo-potential than Sodium, so you will probably
have to use a tighter mesh. It also takes much more time...


File: octopus.info,  Node: Options Index,  Prev: Examples,  Up: Top

Options Index
*************

* Menu:

* AdjustCoordinates:                     Coordinates.
* BoxShape:                              Mesh.
* BroydenNumber:                         SCF.
* CalcPES_mask:                          Photo-electron spectrum.
* CalcPES_rc:                            Photo-electron spectrum.
* CalculationMode:                       Generalities.
* CFamily:                               Exchange and correlation.
* CFunctional:                           Exchange and correlation.
* ClassicPotential:                      Hamiltonian.
* ConvAbsDens:                           SCF.
* ConvAbsEnergy:                         SCF.
* ConvRelDens:                           SCF.
* ConvRelEnergy:                         SCF.
* Coordinates:                           Coordinates.
* DerivativesSpace:                      Mesh.
* DoubleFFTParameter:                    Mesh.
* EigenSolver:                           SCF.
* EigenSolverFinalTolerance:             SCF.
* EigenSolverFinalToleranceIteration:    SCF.
* EigenSolverInitTolerance:              SCF.
* EigenSolverMaxIter:                    SCF.
* ElectronicTemperature:                 States.
* ExcessCharge:                          States.
* ExtraStates:                           States.
* GOMaxIter:                             Geometry optimization.
* GOMethod:                              Geometry optimization.
* GOTolerance:                           Geometry optimization.
* GridRefinement:                        Hamiltonian.
* HSPolarization:                        Spectrum calculations.
* LCAOStart:                             SCF.
* LocalPotentialSpace:                   Hamiltonian.
* Lsize:                                 Mesh.
* MainAxis:                              Coordinates.
* MaximumIter:                           SCF.
* Mixing:                                SCF.
* NonInteractingElectrons:               Hamiltonian.
* NonLocalPotentialSpace:                Hamiltonian.
* NumberCG:                              SCF.
* NumberKPoints:                         States.
* Occupations:                           States.
* OrderDerivatives:                      Mesh.
* OutputCoordinates:                     Coordinates.
* OutputDensity:                         Function output for visualization.
* OutputDX:                              Function output for visualization.
* OutputELF:                             Function output for visualization.
* OutputEvery:                           Function output for visualization.
* OutputKSPotential:                     Function output for visualization.
* OutputPlaneX:                          Function output for visualization.
* OutputPlaneY:                          Function output for visualization.
* OutputPlaneZ:                          Function output for visualization.
* OutputWfs:                             Function output for visualization.
* OutputWfsNumber:                       Function output for visualization.
* PDBCoordinates:                        Coordinates.
* PES_rc_points:                         Photo-electron spectrum.
* PoissonSolver:                         Varia.
* POLStaticField:                        Varia.
* Radius:                                Mesh.
* RecipeLang:                            Varia.
* SCFinLCAO:                             SCF.
* Spacing:                               Mesh.
* SpecDampFactor:                        Spectrum calculations.
* SpecDampMode:                          Spectrum calculations.
* SpecEndTime:                           Spectrum calculations.
* SpecEnergyStep:                        Spectrum calculations.
* Species:                               Species.
* SpecMaxEnergy:                         Spectrum calculations.
* SpecMinEnergy:                         Spectrum calculations.
* SpecStartTime:                         Spectrum calculations.
* SpecTransMode:                         Spectrum calculations.
* SpinComponents:                        States.
* SystemName:                            Generalities.
* TDABHeight:                            Time Dependent.
* TDAbsorbingBoundaries:                 Time Dependent.
* TDABWidth:                             Time Dependent.
* TDDeltaStrength:                       Time Dependent.
* TDDipoleLmax:                          Time Dependent.
* TDEvolutionMethod:                     Time Dependent.
* TDExponentialMethod:                   Time Dependent.
* TDExpOrder:                            Time Dependent.
* TDGauge:                               Time Dependent.
* TDLanczosTol:                          Time Dependent.
* TDLasers:                              Time Dependent.
* TDMaximumIter:                         Time Dependent.
* TDOccupationalAnalysis:                Time Dependent.
* TDOutputLaser:                         Time Dependent.
* TDPolarization:                        Time Dependent.
* TDSaveIter:                            Time Dependent.
* TDTimeStep:                            Time Dependent.
* TypeOfMixing:                          SCF.
* Units:                                 Generalities.
* UnitsInput:                            Generalities.
* UnitsOutput:                           Generalities.
* UnoccConv:                             Unoccupied States.
* UnoccMaximumIter:                      Unoccupied States.
* UnoccNumberStates:                     Unoccupied States.
* Velocities:                            Velocities.
* Verbose:                               Generalities.
* XFamily:                               Exchange and correlation.
* XFunctional:                           Exchange and correlation.
* XYZCoordinates:                        Coordinates.
* XYZVelocities ::                       Velocities.
* ZLength:                               Mesh.



Tag Table:
Node: Top607
Node: Copying2114
Node: Authors3515
Node: Introduction6687
Node: Description of octopus6886
Ref: Description of octopus-Footnote-19331
Node: Time dependent density functional theory9724
Ref: Time dependent density functional theory-Footnote-110252
Ref: Time dependent density functional theory-Footnote-210484
Ref: Time dependent density functional theory-Footnote-310786
Ref: Time dependent density functional theory-Footnote-410942
Node: Installation11126
Node: Quick instructions11325
Node: Long instructions11847
Ref: Long instructions-Footnote-119202
Node: Troubleshooting19551
Node: The input file21498
Node: The parser21708
Node: Input file options24861
Node: Generalities25486
Node: Species27827
Node: Coordinates31323
Node: Velocities35511
Node: Mesh36475
Node: States39278
Node: Hamiltonian41766
Node: Exchange and correlation43401
Node: SCF45342
Node: Unoccupied States49082
Node: Time Dependent49805
Node: Photo-electron spectrum56196
Node: Geometry optimization57182
Node: Function output for visualization58099
Node: Spectrum calculations61014
Node: Varia63146
Node: External utilities63912
Node: strength-function64417
Node: hs-from-mult65304
Node: hs-from-acc65522
Node: function-to-dx65737
Node: nbo2xyz65945
Node: Examples66141
Node: Hello world66296
Ref: Hello world-Footnote-173446
Node: Benzene73530
Node: Options Index74338

End Tag Table
