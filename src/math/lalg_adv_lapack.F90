!! Copyright (C) 2002-2006 M. Marques, A. Castro, A. Rubio, G. Bertsch
!!
!! This program is free software; you can redistribute it and/or modify
!! it under the terms of the GNU General Public License as published by
!! the Free Software Foundation; either version 2, or (at your option)
!! any later version.
!!
!! This program is distributed in the hope that it will be useful,
!! but WITHOUT ANY WARRANTY; without even the implied warranty of
!! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!! GNU General Public License for more details.
!!
!! You should have received a copy of the GNU General Public License
!! along with this program; if not, write to the Free Software
!! Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
!! 02111-1307, USA.
!!
!! $Id$

#if defined(SINGLE_PRECISION)
#  define DLAPACK(x) s ## x
#  define ZLAPACK(x) c ## x
#else
#  define DLAPACK(x) d ## x
#  define ZLAPACK(x) z ## x
#endif


! ---------------------------------------------------------
! Auxiliary functions.
FLOAT function sfmin()
  interface
    FLOAT function DLAPACK(lamch)(cmach)
      character(1), intent(in) :: cmach
    end function DLAPACK(lamch)
  end interface
  
  sfmin = DLAPACK(lamch)('S')
end function sfmin

  
! ---------------------------------------------------------
! Compute the Cholesky decomposition of real symmetric positive definite
! matrix a, dim(a) = n x n. On return a = u^T u with u upper triangular
! matrix.
subroutine dcholesky(n, a, bof, err_code)
  integer,           intent(in)    :: n
  FLOAT,             intent(inout) :: a(:, :)
  logical, optional, intent(inout) :: bof      ! Bomb on failure.
  integer, optional, intent(out)   :: err_code

  interface
    subroutine DLAPACK(potrf)(uplo, n, a, lda, info)
      character(1), intent(in)    :: uplo
      integer,      intent(in)    :: n
      FLOAT,        intent(inout) :: a
      integer,      intent(in)    :: lda
      integer,      intent(out)   :: info
    end subroutine DLAPACK(potrf)
  end interface
  
  integer :: info
  logical :: bof_

  bof_ = .true.
  if(present(bof)) then
    bof_ = bof
  end if

  call DLAPACK(potrf)('U', n, a(1, 1), n, info)
  if(info.ne.0) then
    if(bof_) then
      write(message(1), '(a,i5)') 'In dcholesky, LAPACK Xpotrf returned error message ', info
      call write_fatal(1)
    else
      if(present(bof)) then
        bof = .true.
      end if
    end if
  else
    if(present(bof)) then
      bof = .false.
    end if
  end if
  if(present(err_code)) then
    err_code = info
  end if
end subroutine dcholesky


! ---------------------------------------------------------
! Compute the Cholesky decomposition of a complex Hermitian positive definite
! matrix a, dim(a) = n x n. On return a = u^+ u with u upper triangular
! matrix.
subroutine zcholesky(n, a, bof, err_code)
  integer,           intent(in)    :: n
  CMPLX,             intent(inout) :: a(:, :)
  logical, optional, intent(inout) :: bof     ! Bomb on failure.
  integer, optional, intent(out)   :: err_code

  interface
    subroutine ZLAPACK(potrf)(uplo, n, a, lda, info)
      character(1), intent(in)    :: uplo
      integer,      intent(in)    :: n
      CMPLX,        intent(inout) :: a
      integer,      intent(in)    :: lda
      integer,      intent(out)   :: info
    end subroutine ZLAPACK(potrf)
  end interface
  
  integer :: info
  logical :: bof_

  bof_ = .true.
  if(present(bof)) then
    bof_ = bof
  end if

  call ZLAPACK(potrf)('U', n, a(1, 1), n, info)

  if(info.ne.0) then
    if(bof_) then
      write(message(1), '(a,i5)') 'In zcholesky, LAPACK Xpotrf returned error message ', info
      call write_fatal(1)
    else
      if(present(bof)) then
        bof = .true.
      end if
    end if
  else
    if(present(bof)) then
      bof = .false.
    end if
  end if
  if(present(err_code)) then
    err_code = info
  end if
end subroutine zcholesky


! ---------------------------------------------------------
! Computes all the eigenvalues and the eigenvectors of a real
! generalized symmetric-definite eigenproblem, of the form  A*x=(lambda)*B*x
! A*Bx=(lambda)*x, or B*A*x=(lambda)*x.
! Here A and B are assumed to be symmetric and B is also positive definite.
subroutine dgeneigensolve(n, a, b, e, bof, err_code)
  integer,           intent(in)    :: n
  FLOAT,             intent(inout) :: a(n,n)
  FLOAT,             intent(in)    :: b(n,n)
  FLOAT,             intent(out)   :: e(n)
  logical, optional, intent(inout) :: bof      ! Bomb on failure.
  integer, optional, intent(out)   :: err_code

  interface
    subroutine DLAPACK(sygv) (itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork, info)
      character(1), intent(in)    :: jobz, uplo
      integer,      intent(in)    :: itype, n, lda, ldb, lwork
      FLOAT,        intent(inout) :: a, b    ! a(lda,n), b(ldb,n)
      FLOAT,        intent(out)   :: w, work ! w(n), work(lwork)
      integer,      intent(out)   :: info
    end subroutine DLAPACK(sygv)
  end interface

  integer :: info, lwork
  logical :: bof_
  FLOAT, allocatable :: bp(:,:), work(:)

  bof_ = .true.
  if(present(bof)) then
    bof_ = bof
  end if

  lwork = 5*n
  ALLOCATE(bp(n, n), n*n)
  ALLOCATE(work(lwork), lwork)
  bp = b
  call DLAPACK(sygv) (1, 'V', 'U', n, a(1, 1), n, bp(1, 1), n, e(1), work(1), lwork, info)
  deallocate(bp, work)

  if(info.ne.0) then
    if(bof_) then
      write(message(1),'(a,i5)') 'In dgeneigensolve, LAPACK Xsygv returned error message ', info
      call write_fatal(1)
    else
      if(present(bof)) then
        bof = .true.
      end if
    end if
  else
    if(present(bof)) then
      bof = .false.
    end if
  end if
  if(present(err_code)) then
    err_code = info
  end if
end subroutine dgeneigensolve


! ---------------------------------------------------------
! Computes all the eigenvalues and the eigenvectors of a complex
! generalized Hermitian-definite eigenproblem, of the form  A*x=(lambda)*B*x,
! A*Bx=(lambda)*x, or B*A*x=(lambda)*x.
! Here A and B are assumed to be Hermitian and B is also positive definite.
subroutine zgeneigensolve(n, a, b, e, bof, err_code)
  integer,           intent(in)    :: n
  CMPLX,             intent(inout) :: a(n,n)
  CMPLX,             intent(in)    :: b(n,n)
  FLOAT,             intent(out)   :: e(n)
  logical, optional, intent(inout) :: bof      ! Bomb on failure.
  integer, optional, intent(out)   :: err_code

  interface
    subroutine ZLAPACK(hegv) (itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork, rwork, info)
      character(1), intent(in)    :: jobz, uplo
      integer,      intent(in)    :: n, itype, lda, ldb, lwork
      CMPLX,        intent(inout) :: a, b     ! a(lda,n), b(ldb,n)
      FLOAT,        intent(out)   :: w, rwork ! w(n), rwork(max(1,3*n-2))
      CMPLX,        intent(out)   :: work     ! work(lwork)
      integer,      intent(out)   :: info
    end subroutine ZLAPACK(hegv)
  end interface

  integer            :: info, lwork
  logical            :: bof_
  FLOAT, allocatable :: rwork(:)
  CMPLX, allocatable :: bp(:,:), work(:)

  bof_ = .true.
  if(present(bof)) then
    bof_ = bof
  end if

  lwork = 5*n
  ALLOCATE(bp(n, n),    n*n)
  ALLOCATE(work(lwork), lwork)
  ALLOCATE(rwork(max(1, 3*n-2)), max(1, 3*n-2))
  bp = b
  call ZLAPACK(hegv) (1, 'V', 'U', n, a(1, 1), n, bp(1, 1), n, e(1), work(1), lwork, rwork(1), info)
  deallocate(bp, work, rwork)

  if(info.ne.0) then
    if(bof_) then
      write(message(1),'(a,i5)') 'In zgeneigensolve, LAPACK Xhegv returned error message ', info
      call write_fatal(1)
    else
      if(present(bof)) then
        bof = .true.
      end if
    end if
  else
    if(present(bof)) then
      bof = .false.
    end if
  end if
  if(present(err_code)) then
    err_code = info
  end if
end subroutine zgeneigensolve


! ---------------------------------------------------------
! Computes all the eigenvalues and the eigenvectors of a complex
! generalized (non hermitian) eigenproblem, of the form  A*x=(lambda)*x
subroutine zgeneigensolve_nonh(n, a, e, err_code)
  integer,           intent(in)    :: n
  CMPLX,             intent(inout) :: a(n,n)
  CMPLX,             intent(out)   :: e(n)
  integer, optional, intent(out)   :: err_code

  interface
    subroutine ZLAPACK(geev) (jobvl, jobvr, n, a, lda, w, vl, ldvl, vr, ldvr, work, lwork, rwork, info)
      character(1), intent(in)    :: jobvl, jobvr
      integer,      intent(in)    :: n, lda, ldvl, ldvr, lwork
      CMPLX,        intent(inout) :: a ! a(lda,n)
      CMPLX,        intent(out)   :: w, vl, vr ! w(n), vl(ldvl,n), vl(ldvr,n)
      FLOAT,        intent(out)   :: rwork ! rwork(max(1,2n))
      CMPLX,        intent(out)   :: work  ! work(lwork)
      integer,      intent(out)   :: info
    end subroutine ZLAPACK(geev)
  end interface

  integer            :: info, lwork
  FLOAT, allocatable :: rwork(:)
  CMPLX, allocatable :: work(:), vl(:, :) ,vr(:, :)

  lwork = -1
  ALLOCATE(work(1), 1)
  ALLOCATE(vl(1, 1), 1)
  ALLOCATE(vr(1, 1), 1)
  ALLOCATE(rwork(1), 1)
  call ZLAPACK(geev) ('N', 'V', n, a(1, 1), n, e(1), vl(1, 1), 1, vr(1, 1), n, work(1), lwork, rwork(1), info)
  lwork = int(real(work(1)))
  deallocate(work, vl, vr, rwork)
  

  ALLOCATE(vr(n,n), n*n)
  ALLOCATE(work(lwork), lwork)
  ALLOCATE(rwork(max(1, 2*n)), max(1, 2*n))
  ALLOCATE(vl(1, 1), 1)
  call ZLAPACK(geev) ('N', 'V', n, a(1, 1), n, e(1), vl(1, 1), 1, vr(1,1), n, work(1), lwork, rwork(1), info)
  a(:, :) = vr(:, :)
  deallocate(work, rwork, vr, vl)

  if(info.ne.0) then
    write(message(1),'(a,i5)') 'In zgeneigensolve_nonh, LAPACK Xgeev returned error message ', info
    call write_fatal(1)
  end if
  if(present(err_code)) then
    err_code = info
  end if
end subroutine zgeneigensolve_nonh


! ---------------------------------------------------------
! Computes the k lowest eigenvalues and the eigenvectors of a real
! generalized symmetric-definite eigenproblem, of the form  A*x=(lambda)*B*x.
! Here A and B are assumed to be symmetric and B is also positive definite.
subroutine dlowest_geneigensolve(k, n, a, b, e, v, bof, err_code)
  integer,           intent(in)    :: k, n
  FLOAT,             intent(in)    :: a(n,n)
  FLOAT,             intent(in)    :: b(n,n)
  FLOAT,             intent(out)   :: e(n)
  FLOAT,             intent(out)   :: v(n, k)
  logical, optional, intent(inout) :: bof      ! Bomb on failure.
  integer, optional, intent(out)   :: err_code

  interface
    subroutine DLAPACK(sygvx)(itype, jobz, range, uplo, n, a, lda, b, ldb, &
      vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, iwork, ifail, info)
      integer,      intent(in)  :: itype, n, lda, ldb, il, iu, ldz, lwork
      character(1), intent(in)  :: jobz, range, uplo
      integer,      intent(out) :: m, iwork, ifail, info
      FLOAT,        intent(in)  :: vl, vu, abstol
      FLOAT,        intent(in)  :: a, b
      FLOAT,        intent(out) :: w, z, work
    end subroutine DLAPACK(sygvx)
  end interface
  
  integer            :: m, iwork(5*n), ifail(n), info, lwork
  logical            :: bof_
  FLOAT              :: abstol
  FLOAT, allocatable :: work(:)
  
  bof_ = .true.
  if(present(bof)) then
    bof_ = bof
  end if

  abstol = 2*sfmin()

  ! Work size query.
  ALLOCATE(work(1), 1)
  call DLAPACK(sygvx)(1, 'V', 'I', 'U', n, a(1, 1), n, b(1, 1), n, M_ZERO, M_ZERO, &
    1, k, abstol, m, e(1), v(1, 1), n, work(1), -1, iwork(1), ifail(1), info)
  lwork = int(work(1))
  deallocate(work)

  ALLOCATE(work(lwork), lwork)

  call DLAPACK(sygvx)(1, 'V', 'I', 'U', n, a(1, 1), n, b(1, 1), n, M_ZERO, M_ZERO, &
    1, k, abstol, m, e(1), v(1, 1), n, work(1), lwork, iwork(1), ifail(1), info)

  deallocate(work)

  if(info.ne.0) then
    if(bof_) then
      write(message(1),'(a,i5)') 'In dlowest_geneigensolve, LAPACK Xsygvx returned error message ', info
      call write_fatal(1)
    else
      if(present(bof)) then
        bof = .true.
      end if
    end if
  else
    if(present(bof)) then
      bof = .false.
    end if
  end if
  if(present(err_code)) then
    err_code = info
  end if
end subroutine dlowest_geneigensolve


! ---------------------------------------------------------
! Computes the k lowest eigenvalues and the eigenvectors of a complex
! generalized Hermitian-definite eigenproblem, of the form  A*x=(lambda)*B*x.
! Here A and B are assumed to be Hermitian and B is also positive definite.
subroutine zlowest_geneigensolve(k, n, a, b, e, v, bof, err_code)
  integer,           intent(in)    :: k, n
  CMPLX,             intent(in)    :: a(n,n)
  CMPLX,             intent(in)    :: b(n,n)
  FLOAT,             intent(out)   :: e(n)
  CMPLX,             intent(out)   :: v(n, k)
  logical, optional, intent(inout) :: bof      ! Bomb on failure.
  integer, optional, intent(out)   :: err_code

  interface
    subroutine ZLAPACK(hegvx)(itype, jobz, range, uplo, n, a, lda, b, ldb, &
      vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, rwork, iwork, ifail, info)
      integer,      intent(in)    :: itype, n, lda, ldb, il, iu, ldz, lwork
      character(1), intent(in)    :: jobz, range, uplo
      integer,      intent(out)   :: m, iwork, ifail, info
      FLOAT,        intent(in)    :: vl, vu, abstol
      FLOAT,        intent(out)   :: w, rwork
      CMPLX,        intent(in)    :: a, b
      CMPLX,        intent(out)   :: z, work
    end subroutine ZLAPACK(hegvx)
  end interface

  integer            :: m, iwork(5*n), ifail(n), info, lwork
  logical            :: bof_
  FLOAT              :: abstol
  FLOAT              :: rwork(7*n)
  CMPLX, allocatable :: work(:)

  bof_ = .true.
  if(present(bof)) then
    bof_ = bof
  end if

  abstol = 2*sfmin()

  ! Work size query.
  ALLOCATE(work(1), 1)
  call ZLAPACK(hegvx)(1, 'V', 'I', 'U', n, a(1, 1), n, b(1, 1), n, M_ZERO, M_ZERO, &
    1, k, abstol, m, e(1), v(1, 1), n, work(1), -1, rwork(1), iwork(1), ifail(1), info)
  lwork = int(real(work(1)))
  deallocate(work)


  ALLOCATE(work(lwork), lwork)

  call ZLAPACK(hegvx)(1, 'V', 'I', 'U', n, a(1, 1), n, b(1, 1), n, M_ZERO, M_ZERO, &
    1, k, abstol, m, e(1), v(1, 1), n, work(1), lwork, rwork(1), iwork(1), ifail(1), info)

  deallocate(work)

  if(info.ne.0) then
    if(bof_) then
      write(message(1),'(a,i5)') 'In zlowest_geneigensolve, LAPACK Xhegvx returned error message ', info
      call write_fatal(1)
    else
      if(present(bof)) then
        bof = .true.
      end if
    end if
  else
    if(present(bof)) then
      bof = .false.
    end if
  end if
  if(present(err_code)) then
    err_code = info
  end if
end subroutine zlowest_geneigensolve


! ---------------------------------------------------------
! Computes all eigenvalues and eigenvectors of a real symmetric square matrix A.
subroutine deigensolve(n, a, b, e, bof, err_code)
  integer, intent(in)              :: n
  FLOAT,   intent(in)              :: a(n,n)
  FLOAT,   intent(out)             :: b(n,n)
  FLOAT,   intent(out)             :: e(n)
  logical, optional, intent(inout) :: bof      ! Bomb on failure.
  integer, optional, intent(out)   :: err_code

  interface
    subroutine DLAPACK(syev) (jobz, uplo, n, a, lda, w, work, lwork, info)
      character(1), intent(in)    :: jobz, uplo
      integer,      intent(in)    :: n, lda, lwork
      FLOAT,        intent(inout) :: a       ! a(lda,n)
      FLOAT,        intent(out)   :: w, work ! w(n), work(lwork)
      integer,      intent(out)   :: info
    end subroutine DLAPACK(syev)
  end interface

  logical            :: bof_
  integer            :: info, lwork
  FLOAT, allocatable :: work(:)

  bof_ = .true.
  if(present(bof)) then
    bof_ = bof
  end if

  lwork = 6*n
  ALLOCATE(work(lwork), lwork)
  b = a
  call DLAPACK(syev) ('V', 'U', n, b(1,1), n, e(1), work(1), lwork, info)
  deallocate(work)

  if(info.ne.0) then
    if(bof_) then
      write(message(1),'(a,i5)') 'In deigensolve, LAPACK Xsyev returned error message ', info
      call write_fatal(1)
    else
      if(present(bof)) then
        bof = .true.
      end if
    end if
  else
    if(present(bof)) then
      bof = .false.
    end if
  end if
  if(present(err_code)) then
    err_code = info
  end if
end subroutine deigensolve


! ---------------------------------------------------------
! Computes all eigenvalues and eigenvectors of a complex Hermitian square matrix A.
subroutine zeigensolve(n, a, b, e, bof, err_code)
  integer, intent(in)  :: n
  CMPLX,   intent(in)  :: a(n,n)
  CMPLX,   intent(out) :: b(n,n)
  FLOAT,   intent(out) :: e(n)
  logical, optional, intent(inout) :: bof      ! Bomb on failure.
  integer, optional, intent(out)   :: err_code

  interface
    subroutine ZLAPACK(heev) (jobz, uplo, n, a, lda, w, work, lwork, rwork, info)
      character(1), intent(in)    :: jobz, uplo
      integer,      intent(in)    :: n, lda, lwork
      CMPLX,        intent(inout) :: a        ! a(lda,n)
      FLOAT,        intent(out)   :: w, rwork ! w(n), rwork(max(1,3*n-2))
      CMPLX,        intent(out)   :: work     ! work(lwork)
      integer,      intent(out)   :: info
    end subroutine ZLAPACK(heev)
  end interface

  integer            :: info, lwork
  logical            :: bof_
  CMPLX, allocatable :: work(:)
  FLOAT, allocatable :: rwork(:)

  bof_ = .true.
  if(present(bof)) then
    bof_ = bof
  end if

  lwork = 6*n
  ALLOCATE(work(lwork), lwork)
  ALLOCATE(rwork(max(1, 3*n-2)), max(1, 3*n-2))
  b = a
  call ZLAPACK(heev) ('V','U', n, b(1,1), n, e(1), work(1), lwork, rwork(1), info)
  deallocate(work, rwork)

  if(info.ne.0) then
    if(bof_) then
      write(message(1),'(a,i5)') 'In zeigensolve, LAPACK Xheev returned error message ', info
      call write_fatal(1)
    else
      if(present(bof)) then
        bof = .true.
      end if
    end if
  else
    if(present(bof)) then
      bof = .false.
    end if
  end if
  if(present(err_code)) then
    err_code = info
  end if
end subroutine zeigensolve


! ---------------------------------------------------------
! Computes the k lowest eigenvalues and the eigenvectors of a real
! standard symmetric-definite eigenproblem, of the form  A*x=(lambda)*x.
! Here A is assumed to be symmetric.
subroutine dlowest_eigensolve(k, n, a, e, v)
  integer, intent(in)  :: k, n
  FLOAT,   intent(in)  :: a(n, n)
  FLOAT,   intent(out) :: e(n)
  FLOAT,   intent(out) :: v(n, k)

  interface
    subroutine DLAPACK(syevx)(jobz, range, uplo, n, a, lda, &
      vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, iwork, ifail, info)
      integer,      intent(in)  :: n, lda, il, iu, ldz, lwork
      character(1), intent(in)  :: jobz, range, uplo
      integer,      intent(out) :: m, iwork, ifail, info
      FLOAT,        intent(in)  :: vl, vu, abstol
      FLOAT,        intent(in)  :: a
      FLOAT,        intent(out) :: w, z, work
    end subroutine DLAPACK(syevx)
  end interface
  
  integer            :: m, iwork(5*n), ifail(n), info, lwork
  FLOAT              :: abstol
  FLOAT, allocatable :: work(:)
  
  abstol = 2*sfmin()

  ! Work size query.
  ALLOCATE(work(1), 1)
  call DLAPACK(syevx)('V', 'I', 'U', n, a(1, 1), n, M_ZERO, M_ZERO, &
    1, k, abstol, m, e(1), v(1, 1), n, work(1), -1, iwork(1), ifail(1), info)
  lwork = int(work(1))
  deallocate(work)

  ALLOCATE(work(lwork), lwork)

  call DLAPACK(syevx)('V', 'I', 'U', n, a(1, 1), n, M_ZERO, M_ZERO, &
    1, k, abstol, m, e(1), v(1, 1), n, work(1), lwork, iwork(1), ifail(1), info)

  deallocate(work)

  if(info.ne.0) then
    write(message(1),'(a,i5)') &
      'In dlowest_eigensolve, LAPACK Xsygvx returned error message ', info
    call write_fatal(1)
  end if
end subroutine dlowest_eigensolve


! ---------------------------------------------------------
! Computes the k lowest eigenvalues and the eigenvectors of a complex
! standard Hermitian-definite eigenproblem, of the form  A*x=(lambda)*x.
! Here A is assumed to be Hermitian.
subroutine zlowest_eigensolve(k, n, a, e, v)
  integer, intent(in)  :: k, n
  CMPLX,   intent(in)  :: a(n, n)
  FLOAT,   intent(out) :: e(n)
  CMPLX,   intent(out) :: v(n, k)

  interface
    subroutine ZLAPACK(heevx)(jobz, range, uplo, n, a, lda, &
      vl, vu, il, iu, abstol, m, w, z, ldz, work, lwork, iwork, ifail, info)
      integer,      intent(in)  :: n, lda, il, iu, ldz, lwork
      character(1), intent(in)  :: jobz, range, uplo
      integer,      intent(out) :: m, iwork, ifail, info
      FLOAT,        intent(in)  :: vl, vu, abstol
      FLOAT,        intent(out) :: w
      CMPLX,        intent(in)  :: a
      CMPLX,        intent(out) :: z, work
    end subroutine ZLAPACK(heevx)
  end interface
  
  integer            :: m, iwork(5*n), ifail(n), info, lwork
  FLOAT              :: abstol
  CMPLX, allocatable :: work(:)
  
  abstol = 2*sfmin()

  ! Work size query.
  ALLOCATE(work(1), 1)
  call ZLAPACK(heevx)('V', 'I', 'U', n, a(1, 1), n, M_ZERO, M_ZERO, &
    1, k, abstol, m, e(1), v(1, 1), n, work(1), -1, iwork(1), ifail(1), info)
  lwork = int(work(1))
  deallocate(work)

  ALLOCATE(work(lwork), lwork)

  call ZLAPACK(heevx)('V', 'I', 'U', n, a(1, 1), n, M_ZERO, M_ZERO, &
    1, k, abstol, m, e(1), v(1, 1), n, work(1), lwork, iwork(1), ifail(1), info)

  deallocate(work)

  if(info.ne.0) then
    write(message(1),'(a,i5)') &
      'In zlowest_eigensolve, LAPACK Xsygvx returned error message ', info
    call write_fatal(1)
  end if
end subroutine zlowest_eigensolve


! ---------------------------------------------------------
! Invert a real symmetric square matrix a
FLOAT function ddeterminant(n, a, invert) result(d)
  integer, intent(in)           :: n
  FLOAT,   intent(inout)        :: a(n,n)
  logical, intent(in), optional :: invert

  interface
    subroutine DLAPACK(getrf) (m, n, a, lda, ipiv, info)
      integer,      intent(in)    :: m, n, lda
      FLOAT,        intent(inout) :: a          ! a(lda, n)
      integer,      intent(out)   :: ipiv       ! ipiv(min(m,n)
      integer,      intent(out)   :: info
    end subroutine DLAPACK(getrf)

    subroutine DLAPACK(getri) (n, a, lda, ipiv, work, lwork, info )
      integer,      intent(in)    :: n, lda, lwork
      FLOAT,        intent(inout) :: a       ! a(lda, n)
      integer,      intent(in)    :: ipiv    ! ipiv(n)
      FLOAT,        intent(inout) :: work    ! work(lwork)
      integer,      intent(out)   :: info
    end subroutine DLAPACK(getri)
  end interface

  integer :: info, i
  integer, allocatable :: ipiv(:)
  FLOAT, allocatable :: work(:)
  logical :: invert_

  ALLOCATE(work(n), n)
  ALLOCATE(ipiv(n), n)

  call DLAPACK(getrf)(n, n, a(1, 1), n, ipiv(1), info)
  if(info < 0) then
    write(message(1), '(a, i3)') 'In dinvert, LAPACK dgetrf returned info = ', info
    call write_fatal(1)
  end if

  d = M_ONE
  do i = 1, n
    if(ipiv(i).ne.i) then
      d = - d*a(i, i)
    else
      d = d*a(i, i)
    end if
  end do

  invert_ = .true.; if(present(invert)) invert_ = invert
  if(invert_) then
    call DLAPACK(getri)(n, a(1, 1), n, ipiv(1), work(1), n, info)
    if(info /= 0) then
      write(message(1), '(a, i3)') 'In dinvert, LAPACK dgetri returned info = ', info
      call write_fatal(1)
    end if
  end if

  deallocate(work, ipiv)
end function ddeterminant


! ---------------------------------------------------------
! Invert a complex Hermitian square matrix a
CMPLX function zdeterminant(n, a, invert) result(d)
  integer, intent(in)           :: n
  CMPLX,   intent(inout)        :: a(n,n)
  logical, intent(in), optional :: invert

  interface
    subroutine ZLAPACK(getrf) (m, n, a, lda, ipiv, info)
      integer,      intent(in)    :: m, n, lda
      CMPLX,        intent(inout) :: a          ! a(lda, n)
      integer,      intent(out)   :: ipiv       ! ipiv(min(m,n)
      integer,      intent(out)   :: info
    end subroutine ZLAPACK(getrf)

    subroutine ZLAPACK(getri) (n, a, lda, ipiv, work, lwork, info )
      integer,      intent(in)    :: n, lda, lwork
      CMPLX,        intent(inout) :: a       ! a(lda, n)
      integer,      intent(in)    :: ipiv    ! ipiv(n)
      CMPLX,        intent(inout) :: work    ! work(lwork)
      integer,      intent(out)   :: info
    end subroutine ZLAPACK(getri)
  end interface

  integer :: info, i
  integer, allocatable :: ipiv(:)
  CMPLX, allocatable :: work(:)
  logical :: invert_

  ALLOCATE(work(n), n)
  ALLOCATE(ipiv(n), n)

  call ZLAPACK(getrf)(n, n, a(1, 1), n, ipiv(1), info)
  if(info < 0) then
    write(message(1), '(a, i3)') 'In dinvert, LAPACK dgetrf returned info = ', info
    call write_fatal(1)
  end if

  d = M_ONE
  do i = 1, n
    if(ipiv(i).ne.i) then
      d = - d*a(i, i)
    else
      d = d*a(i, i)
    end if
  end do

  invert_ = .true.; if(present(invert)) invert_ = invert
  if(invert_) then
    call ZLAPACK(getri)(n, a(1, 1), n, ipiv(1), work(1), n, info)
    if(info /= 0) then
      write(message(1), '(a, i3)') 'In dinvert, LAPACK dgetri returned info = ', info
      call write_fatal(1)
    end if
  end if

  deallocate(work, ipiv)
end function zdeterminant

! ---------------------------------------------------------
! Invert a real symmetric square matrix a
subroutine dsym_inverter(uplo, n, a)
  character(1), intent(in)      :: uplo
  integer, intent(in)           :: n
  FLOAT,   intent(inout)        :: a(n,n)

  interface
    subroutine DLAPACK(sytrf) (uplo, n, a, lda, ipiv, work, lwork, info)
      character(1), intent(in)    :: uplo
      integer,      intent(in)    :: n, lda, lwork
      FLOAT,        intent(inout) :: a(n,n)
      integer,      intent(out)   :: ipiv(n)
      FLOAT,        intent(inout) :: work(n)
      integer,      intent(out)   :: info
    end subroutine DLAPACK(sytrf)

    subroutine DLAPACK(sytri) (uplo, n, a, lda, ipiv, work, info )
      character(1), intent(in)    :: uplo
      integer,      intent(in)    :: n, lda
      FLOAT,        intent(inout) :: a(n,n)
      integer,      intent(in)    :: ipiv(n)
      FLOAT,        intent(inout) :: work(n)
      integer,      intent(out)   :: info
    end subroutine DLAPACK(sytri)
  end interface

  integer :: info
  integer, allocatable :: ipiv(:)
  FLOAT, allocatable :: work(:)

  ALLOCATE(work(n), n)
  ALLOCATE(ipiv(n), n)

  call DLAPACK(sytrf)(uplo, n, a, n, ipiv, work, n, info)
  if(info < 0) then
    write(message(1), '(a, i3)') 'In dsym_inverter, LAPACK dsytrf returned info = ', info
    call write_fatal(1)
  end if

  call DLAPACK(sytri)(uplo, n, a, n, ipiv, work, info)
  if(info /= 0) then
    write(message(1), '(a, i3)') 'In dsym_inverter, LAPACK dsytri returned info = ', info
    call write_fatal(1)
  end if

  deallocate(work, ipiv)
end subroutine dsym_inverter

! ---------------------------------------------------------
! Invert a complex symmetric square matrix a
subroutine zsym_inverter(uplo, n, a)
  character(1), intent(in)      :: uplo
  integer, intent(in)           :: n
  CMPLX,   intent(inout)        :: a(n,n)

  interface
    subroutine ZLAPACK(sytrf) (uplo, n, a, lda, ipiv, work, lwork, info)
      character(1), intent(in)    :: uplo
      integer,      intent(in)    :: n, lda, lwork
      CMPLX,        intent(inout) :: a(n,n) 
      integer,      intent(out)   :: ipiv(n)
      CMPLX,        intent(inout) :: work(n)
      integer,      intent(out)   :: info
    end subroutine ZLAPACK(sytrf)

    subroutine ZLAPACK(sytri) (uplo, n, a, lda, ipiv, work, info )
      character(1), intent(in)    :: uplo
      integer,      intent(in)    :: n, lda
      CMPLX,        intent(inout) :: a(n,n)
      integer,      intent(in)    :: ipiv(n)
      CMPLX,        intent(inout) :: work(n)
      integer,      intent(out)   :: info
    end subroutine ZLAPACK(sytri)
  end interface

  integer :: info
  integer, allocatable :: ipiv(:)
  CMPLX, allocatable :: work(:)

  ALLOCATE(work(n), n)
  ALLOCATE(ipiv(n), n)
  call ZLAPACK(sytrf)(uplo, n, a, n, ipiv, work, n, info)
  if(info < 0) then
    write(message(1), '(a, i3)') 'In zsym_inverter, LAPACK zsytrf returned info = ', info
    call write_fatal(1)
  end if

  call ZLAPACK(sytri)(uplo, n, a, n, ipiv, work, info)
  if(info /= 0) then
    write(message(1), '(a, i3)') 'In zsym_inverter, LAPACK zsytri returned info = ', info
    call write_fatal(1)
  end if

  deallocate(work, ipiv)
end subroutine zsym_inverter

! ---------------------------------------------------------
! compute the solution to a real system of linear equations A*X = B,
!  where A is an N-by-N matrix and X and B are N-by-NRHS matrices.
subroutine dlinsyssolve(n, nhrs, a, b, x)
  integer, intent(in)    :: n, nhrs
  FLOAT,   intent(inout) :: a(n, n), b(n, nhrs)
  FLOAT,   intent(out)   :: x(n, nhrs)

  interface
    subroutine DLAPACK(gesvx) (fact, trans, n, nhrs, a, lda, af, ldaf, ipiv, equed, r, &
      c, b, ldb, x, ldx, rcond, ferr, berr, work, iwork, info)
      character(1), intent(in)    :: fact, trans
      integer,      intent(in)    :: n, nhrs, lda, ldaf, ldb, ldx
      FLOAT,        intent(inout) :: a, af, r, c, b      ! a(lda,n), af(ldaf,n), r(n), c(n), b(ldb,nhrs)
      integer,      intent(inout) :: ipiv                ! ipiv(n)
      FLOAT,        intent(out)   :: x, ferr, berr, work ! x(ldx,nhrs), ferr(nhrs), berr(nhrs), work(4*n)
      FLOAT,        intent(out)   :: rcond
      character(1), intent(inout) :: equed
      integer,      intent(out)   :: iwork               ! iwork(n)
      integer,      intent(out)   :: info
    end subroutine DLAPACK(gesvx)
  end interface

  integer :: info
  integer, allocatable :: ipiv(:), iwork(:)
  FLOAT :: rcond
  FLOAT, allocatable :: ferr(:), berr(:), work(:), r(:), c(:), af(:,:)
  character(1) :: equed

  ALLOCATE(ipiv(n),    n)
  ALLOCATE(iwork(n),   n)
  ALLOCATE(ferr(nhrs), nhrs)
  ALLOCATE(berr(nhrs), nhrs)
  ALLOCATE(work(4*n),  4*n)
  ALLOCATE(r(n),       n)
  ALLOCATE(c(n),       n)
  ALLOCATE(af(n, n),   n*n)

  call DLAPACK(gesvx) ("N", "N", n, nhrs, a(1, 1), n, af(1, 1), n, ipiv(1), equed, r(1), c(1), b(1, 1), n, x(1, 1), n, &
    rcond, ferr(1), berr(1), work(1), iwork(1), info)

  if(info /= 0) then
    write(message(1), '(a, i3)') 'In dlinsyssolve, LAPACK (d|s)gesvx returned info = ', info
    call write_fatal(1)
  end if

  deallocate(ipiv, iwork, ferr, berr, work, r, c, af)

end subroutine dlinsyssolve

! ---------------------------------------------------------
! compute the solution to a complex system of linear equations A*X = B,
!  where A is an N-by-N matrix and X and B are N-by-NRHS matrices.
subroutine zlinsyssolve(n, nhrs, a, b, x)
  integer, intent(in)    :: n, nhrs
  CMPLX,   intent(inout) :: a(n, n), b(n, nhrs)
  CMPLX,   intent(out)   :: x(n, nhrs)

  interface
    subroutine ZLAPACK(gesvx) (fact, trans, n, nhrs, a, lda, af, ldaf, ipiv, equed, r, &
      c, b, ldb, x, ldx, rcond, ferr, berr, work, rwork, info)
      character(1), intent(in)    :: fact, trans
      integer,      intent(in)    :: n, nhrs, lda, ldaf, ldb, ldx
      CMPLX,        intent(inout) :: a, af, b            ! a(lda, n), af(ldaf, n), b(ldb, nhrs)
      FLOAT,        intent(inout) :: r, c                ! r(n), c(n)
      integer,      intent(inout) :: ipiv                ! ipiv(n)
      FLOAT,        intent(out)   :: ferr, berr          ! ferr(nhrs), berr(nhrs)
      FLOAT,        intent(out)   :: rcond
      CMPLX,        intent(out)   :: x, work             ! x(ldx, nhrs), work(2*n)
      character(1), intent(inout) :: equed
      FLOAT,        intent(out)   :: rwork               ! rwork(2*n)
      integer,      intent(out)   :: info
    end subroutine ZLAPACK(gesvx)
  end interface

  integer              :: info
  integer, allocatable :: ipiv(:)
  FLOAT,   allocatable :: rwork(:), ferr(:), berr(:), r(:), c(:)
  FLOAT                :: rcond
  CMPLX, allocatable   :: work(:), af(:,:)
  character(1)         :: equed

  ALLOCATE(ipiv(n),    n)
  ALLOCATE(rwork(2*n), 2*n)
  ALLOCATE(ferr(nhrs), nhrs)
  ALLOCATE(berr(nhrs), nhrs)
  ALLOCATE(work(2*n),  2*n)
  ALLOCATE(r(n),       n)
  ALLOCATE(c(n),       n)
  ALLOCATE(af(n, n),   n*n)

  equed = 'N'

  call ZLAPACK(gesvx) ("N", "N", n, nhrs, a(1, 1), n, af(1, 1), n, ipiv(1), equed, r(1), c(1), b(1, 1), n, x(1, 1), n, &
    rcond, ferr(1), berr(1), work(1), rwork(1), info)
  if(info /= 0) then
    write(message(1), '(a, i3)') 'In zlinsyssolve, LAPACK zgesvx returned info = ', info
    call write_fatal(1)
  end if

  deallocate(ipiv)
  deallocate(rwork)
  deallocate(ferr)
  deallocate(berr)
  deallocate(work)
  deallocate(r)
  deallocate(c)
  deallocate(af)
end subroutine zlinsyssolve


! ---------------------------------------------------------
! computes the singular value decomposition of a complex NxN matrix a(:,:)
subroutine zsingular_value_decomp(n, a, u, vt, sg_values)
  integer, intent(in)    :: n
  CMPLX,   intent(inout) :: a(n, n)  
  CMPLX,   intent(out)   :: u(n, n), vt(n, n)  
  FLOAT,   intent(out)   :: sg_values(n)

  interface
    subroutine ZLAPACK(gesvd) ( jobu, jobvt, m, n, a, lda, s, u, ldu, &
      vt, ldvt, work, lwork, rwork, info )
      character(1), intent(in)    :: jobu, jobvt
      integer,      intent(in)    :: m, n
      CMPLX,        intent(inout) :: a, u, vt ! a(lda,n), b(ldu,n), b(ldvt,n)
      CMPLX,        intent(out)   :: work     ! work(lwork)
      integer,      intent(in)    :: lda, ldu, ldvt, lwork
      integer,      intent(out)   :: info
      FLOAT,        intent(out)   :: s        ! s(min(m,n))
      FLOAT,        intent(inout) :: rwork    ! rwork(5*min(m,n))
    end subroutine ZLAPACK(gesvd)
  end interface

  integer :: m, info, lwork
  CMPLX, allocatable :: work(:)
  FLOAT, allocatable :: rwork(:)

  ! for now we treat only square matrices
  m = n 

  ! double minimum lwork size to increase performance (see manpage)
  lwork = 2*( 2*min(m, n) + max(m, n) )

  ALLOCATE(work(lwork), lwork)
  ALLOCATE(rwork(5*min(m, n)), 5*min(m, n))

  call ZLAPACK(gesvd)( &
    'A', 'A', m, n, a(1, 1), m, sg_values(1), u(1, 1), m, vt(1, 1), n, work(1), lwork, rwork(1), info )

  if(info /= 0) then
    write(message(1), '(a, i3)') 'In zsingular_value_decomp, LAPACK zgesvd returned info = ', info
    call write_fatal(1)
  end if

  deallocate(rwork, work)

end subroutine zsingular_value_decomp


! ---------------------------------------------------------
! computes inverse of a complex NxN matrix a(:,:) using the SVD decomposition 
subroutine zsvd_inverse(n, a, threshold)
  integer, intent(in)           :: n
  CMPLX,   intent(inout)        :: a(n, n)    ! a will be replaced by its inverse
  FLOAT,   intent(in), optional :: threshold

  CMPLX, allocatable :: u(:,:), vt(:,:)
  FLOAT, allocatable :: sg_values(:)
  CMPLX   :: tmp
  FLOAT   :: sg_inverse, threshold_
  integer :: j, k, l

  ALLOCATE( u(n, n), n*n)
  ALLOCATE(vt(n, n), n*n)
  ALLOCATE(sg_values(n), n)

  call zsingular_value_decomp(n, a, u, vt, sg_values)

  threshold_ = CNST(1e-10); 
  if(present(threshold)) threshold_ = threshold

  ! build inverse
  do j = 1, n
    do k = 1, n
      tmp = M_ZERO
      do l = 1, n
        if (sg_values(l).lt.threshold_) then
          write(message(1), '(a)') 'In zsvd_inverse: singular value below threshold.'
          call write_warning(1)
          sg_inverse = M_ZERO
        else
          sg_inverse = M_ONE/sg_values(l)
        end if
        tmp = tmp + conjg(vt(l, k))*sg_inverse*conjg(u(j, l))
      end do
      a(j, k) = tmp
    end do
  end do

  deallocate(sg_values, vt, u)
end subroutine zsvd_inverse


! ---------------------------------------------------------
! Calculate the inverse of a real upper triangular matrix (in
! unpacked storage).
subroutine dinvert_upper_triangular(n, a)
  integer, intent(in)    :: n
  FLOAT,   intent(inout) :: a(n, n)

  integer :: info

  interface
    subroutine DLAPACK(trtri)(uplo, diag, n, a, lda, info)
      character(1), intent(in)    :: uplo
      character(1), intent(in)    :: diag
      integer,      intent(in)    :: n
      FLOAT,        intent(inout) :: a
      integer,      intent(in)    :: lda
      integer,      intent(out)   :: info
    end subroutine DLAPACK(trtri)
  end interface
  
  call DLAPACK(trtri)('U', 'N', n, a(1, 1), n, info)

  if(info.ne.0) then
    write(message(1), '(a,i5)') &
      'In dinvert_upper_triangular, LAPACK Xtrtri returned error message ', info
    call write_fatal(1)
  end if
end subroutine dinvert_upper_triangular


! ---------------------------------------------------------
! Calculate the inverse of a complex upper triangular matrix (in
! unpacked storage).
subroutine zinvert_upper_triangular(n, a)
  integer, intent(in)    :: n
  CMPLX,   intent(inout) :: a(n, n)

  integer :: info

  interface
    subroutine ZLAPACK(trtri)(uplo, diag, n, a, lda, info)
      character(1), intent(in)    :: uplo
      character(1), intent(in)    :: diag
      integer,      intent(in)    :: n
      CMPLX,        intent(inout) :: a
      integer,      intent(in)    :: lda
      integer,      intent(out)   :: info
    end subroutine ZLAPACK(trtri)
  end interface
  
  call ZLAPACK(trtri)('U', 'N', n, a(1, 1), n, info)

  if(info.ne.0) then
    write(message(1), '(a,i5)') &
      'In zinvert_upper_triangular, LAPACK Xtrtri returned error message ', info
    call write_fatal(1)
  end if
end subroutine zinvert_upper_triangular

! ---------------------------------------------------------
! Calculate the inverse of a real lower triangular matrix (in
! unpacked storage).
subroutine dinvert_lower_triangular(n, a)
  integer, intent(in)    :: n
  FLOAT,   intent(inout) :: a(n, n)

  integer :: info

  interface
    subroutine DLAPACK(trtri)(uplo, diag, n, a, lda, info)
      character(1), intent(in)    :: uplo
      character(1), intent(in)    :: diag
      integer,      intent(in)    :: n
      FLOAT,        intent(inout) :: a
      integer,      intent(in)    :: lda
      integer,      intent(out)   :: info
    end subroutine DLAPACK(trtri)
  end interface
  
  call DLAPACK(trtri)('L', 'N', n, a(1, 1), n, info)

  if(info.ne.0) then
    write(message(1), '(a,i5)') &
      'In dinvert_lower_triangular, LAPACK Xtrtri returned error message ', info
    call write_fatal(1)
  end if
end subroutine dinvert_lower_triangular

! ---------------------------------------------------------
! Calculate the inverse of a complex lower triangular matrix (in
! unpacked storage).
subroutine zinvert_lower_triangular(n, a)
  integer, intent(in)    :: n
  CMPLX,   intent(inout) :: a(n, n)

  integer :: info

  interface
    subroutine ZLAPACK(trtri)(uplo, diag, n, a, lda, info)
      character(1), intent(in)    :: uplo
      character(1), intent(in)    :: diag
      integer,      intent(in)    :: n
      CMPLX,        intent(inout) :: a
      integer,      intent(in)    :: lda
      integer,      intent(out)   :: info
    end subroutine ZLAPACK(trtri)
  end interface
  
  call ZLAPACK(trtri)('L', 'N', n, a(1, 1), n, info)

  if(info.ne.0) then
    write(message(1), '(a,i5)') &
      'In zinvert_lower_triangular, LAPACK Xtrtri returned error message ', info
    call write_fatal(1)
  end if
end subroutine zinvert_lower_triangular


!! Local Variables:
!! mode: f90
!! coding: utf-8
!! End:
