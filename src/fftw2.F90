!! Copyright (C) 2002-2006 M. Marques, A. Castro, A. Rubio, G. Bertsch
!!
!! This program is free software; you can redistribute it and/or modify
!! it under the terms of the GNU General Public License as published by
!! the Free Software Foundation; either version 2, or (at your option)
!! any later version.
!!
!! This program is distributed in the hope that it will be useful,
!! but WITHOUT ANY WARRANTY; without even the implied warranty of
!! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!! GNU General Public License for more details.
!!
!! You should have received a copy of the GNU General Public License
!! along with this program; if not, write to the Free Software
!! Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
!! 02111-1307, USA.
!!
!! -*- coding: utf-8 mode: f90 -*-
!! $Id$

! /* Note: in fftw2, the routines in single and double precision have the
! same name. From the manual:
!   "To work in single precision rather than double precision, #define the
!   symbol FFTW_ENABLE_FLOAT in fftw.h and then recompile the library. On
!   Unix systems, you can instead use configure --enable-float at installation_m
!   time" */

module fft_m
  use global_m
  use messages_m
  use datasets_m
  use lib_oct_m
  use lib_oct_parser_m
  use lib_basic_alg_m

  implicit none

  private
  
  public :: &
       fft_t, &
       pad_feq, &
       fft_real, fft_complex, &
       fft_all_init, fft_all_end, &
       fft_init, fft_end, &
       fft_copy, &
       dfft_forward, zfft_forward, &
       dfft_backward, zfft_backward
       
  ! global constants
  integer, parameter ::        &
    fft_real    = 0,           &
    fft_complex = 1

  ! fftw constants
  integer, parameter ::        &
    fftw_forward         = -1, &
    fftw_backward        =  1, &
    fftw_real_to_complex = -1, &
    fftw_complex_to_real =  1, &
    fftw_estimate        =  0, &
    fftw_measure         =  1, &
    fftw_in_place        =  8, &
    fftw_out_of_place    =  0, &
    fftw_use_wisdom      = 16, &
    fftw_threadsafe      =128

  type fft_t
    integer   :: slot       ! in which slot do we have this fft

    integer   :: n(MAX_DIM) ! size of the fft
    integer   :: is_real    ! is the fft real or complex
    C_POINTER :: planf      ! the plan for forward transforms
    C_POINTER :: planb      ! the plan for backward transforms
  end type fft_t

  integer     :: fft_refs(FFT_MAX)
  type(fft_t) :: fft_array(FFT_MAX)
  logical     :: fft_optimize

contains

  ! ---------------------------------------------------------
  ! initialize the table
  subroutine fft_all_init()
    integer :: i

    call loct_parse_logical(check_inp('FFTOptimize'), .true., fft_optimize)

    do i = 1, FFT_MAX
      fft_refs(i) = NULL
    end do
  end subroutine fft_all_init

  ! ---------------------------------------------------------
  ! delete all plans
  subroutine fft_all_end()
    integer :: i

    do i = 1, FFT_MAX
      if(fft_refs(i).ne.NULL) then
        call fftw_f77_destroy_plan(fft_array(i)%planf)
        call fftw_f77_destroy_plan(fft_array(i)%planb)
        fft_refs(i) = NULL
      end if
    end do
  end subroutine fft_all_end


  ! ---------------------------------------------------------
  subroutine fft_init(n, is_real, fft, optimize)
    integer,           intent(inout) :: n(MAX_DIM)
    integer,           intent(in)    :: is_real
    type(fft_t),       intent(out)   :: fft
    logical,           intent(in), optional :: optimize

    integer :: i, j, dim
    logical :: optimize_

    ! First, figure out about the dimensionaliy of the FFT.
    dim = 0
    do i = 1, MAX_DIM
      if(n(i) > 1) then 
        dim = dim + 1
      else
        exit
      end if
    end do

    if(dim.eq.0) then
      message(1) = "Internal error in fft_init: apparently, a 1x1x1 FFT is required."
      call write_fatal(1)
    end if

    optimize_ = .true.
    if(present(optimize)) optimize_ = optimize

    ! OLD: I let it here because maybe I revert to this method later_m
    ! optimize dimensions in non-periodic directions
    !    do i = sb%periodic_dim + 1, sb%dim
    !      if (n(i) /= 1 .and. fft_optimize) &
    !           call loct_fft_optimize(n(i), 7, 1) ! always ask for an odd number
    !    end do
    ! NEW
    ! optimize dimensions only for finite sys
    optimize_ = optimize_ .and. fft_optimize
    if(optimize_) then
      do i = 1, dim
        call loct_fft_optimize(n(i), 7, 1)
      end do
    end if

    ! find out if fft has already been allocated
    j = 0
    do i = FFT_MAX, 1, -1
      if(fft_refs(i).ne.NULL) then
        if(n(1) == fft_array(i)%n(1).and.n(2) == fft_array(i)%n(2).and.n(3) == fft_array(i)%n(3).and. &
          is_real == fft_array(i)%is_real) then
          fft = fft_array(i)             ! return a copy
          fft_refs(i) = fft_refs(i) + 1  ! increment the ref count
          return
        end if
      else
        j = i
      end if
    end do

    if(j == 0) then
      message(1) = "Not enough slots for FFTs"
      message(2) = "Please increase FFT_MAX in fft.F90 and recompile"
      call write_fatal(2)
    end if

    ! j now contains an empty slot
    fft_refs(j)          = 1
    fft_array(j)%slot    = j
    fft_array(j)%n       = n
    fft_array(j)%is_real = is_real
    if(is_real == fft_real) then
      call rfftwnd_f77_create_plan(fft_array(j)%planf, dim, n, &
        fftw_real_to_complex + fftw_forward,  fftw_measure + fftw_threadsafe)
      call rfftwnd_f77_create_plan(fft_array(j)%planb, dim, n, &
        fftw_complex_to_real + fftw_backward, fftw_measure + fftw_threadsafe)
    else
      call  fftwnd_f77_create_plan(fft_array(j)%planf, dim, n, &
        fftw_forward,  fftw_measure + fftw_threadsafe)
      call  fftwnd_f77_create_plan(fft_array(j)%planb, dim, n, &
        fftw_backward, fftw_measure + fftw_threadsafe)
    end if
    fft = fft_array(j)

    write(message(1), '(a,i4,a,i4,a,i4,a,i2)') "Info: FFT allocated with size (", &
      n(1), ",", n(2), ",", n(3), ") in slot ", j
    call write_info(1)

  end subroutine fft_init


  ! ---------------------------------------------------------
  subroutine fft_copy(fft_i, fft_o)
    type(fft_t), intent( in) :: fft_i
    type(fft_t), intent(out) :: fft_o

    ASSERT(fft_i%slot>=1.and.fft_i%slot<=FFT_MAX)
    ASSERT(fft_refs(fft_i%slot) > 0)

    fft_o = fft_i
    fft_refs(fft_i%slot) = fft_refs(fft_i%slot) + 1
  end subroutine fft_copy


  ! ---------------------------------------------------------
  subroutine fft_end(fft)
    type(fft_t), intent(inout) :: fft

    integer :: i

    i = fft%slot
    if(fft_refs(i)==NULL) then
      message(1) = "Trying to deallocate fft that has not been allocated"
      call write_warning(1)
    else
      if(fft_refs(i) > 1) then
        fft_refs(i) = fft_refs(i) - 1
      else
        fft_refs(i) = NULL
        call fftw_f77_destroy_plan(fft_array(i)%planf)
        call fftw_f77_destroy_plan(fft_array(i)%planb)

        write(message(1), '(a,i4,a,i4,a,i4,a,i2)') "Info: FFT deallocated from slot ", i
        call write_info(1)
      end if
    end if

  end subroutine fft_end


  ! ---------------------------------------------------------
  subroutine fft_getdim_real(fft, d)
    type(fft_t), intent(in) :: fft
    integer,    intent(out) :: d(MAX_DIM)

    d = fft%n
  end subroutine fft_getdim_real


  ! ---------------------------------------------------------
  subroutine fft_getdim_complex(fft, d)
    type(fft_t), intent(in) :: fft
    integer,    intent(out) :: d(MAX_DIM)

    d = fft%n
    if(fft%is_real == fft_real)  d(1) = d(1)/2 + 1
  end subroutine fft_getdim_complex


  ! ---------------------------------------------------------
  ! these routines simply call fftw
  ! first the real to complex versions
  subroutine dfft_forward(fft, r, c)
    type(fft_t), intent(in) :: fft
    FLOAT, intent(in)  :: r(:,:,:)
    CMPLX, intent(out) :: c(:,:,:)

    call push_sub('fftw2.dfft_forward')
    call rfftwnd_f77_one_real_to_complex(fft%planf, r, c)
    call pop_sub()

  end subroutine dfft_forward


  ! ---------------------------------------------------------
  subroutine dfft_backward(fft, c, r)
    type(fft_t), intent(in) :: fft
    CMPLX,    intent(in) :: c(fft%n(1),fft%n(2),fft%n(3))
    FLOAT,   intent(out) :: r(fft%n(1),fft%n(2),fft%n(3))

    call push_sub('fftw2.dfft_backward')

    call rfftwnd_f77_one_complex_to_real(fft%planb, c, r)

    ! multiply by 1/(N1*N2*N2)
    call lalg_scal(fft%n(1), fft%n(2), fft%n(3), &
      M_ONE/real(fft%n(1)*fft%n(2)*fft%n(3), REAL_PRECISION), r)

    call pop_sub()

  end subroutine dfft_backward


  ! ---------------------------------------------------------
  ! first the complex versions
  subroutine zfft_forward(fft, r, c)
    type(fft_t), intent(in) :: fft
    CMPLX, intent(in)  :: r(:,:,:)
    CMPLX, intent(out) :: c(:,:,:)

    call push_sub('fftw2.zfft_forward')

    call fftwnd_f77_one(fft%planf, r, c)

    call pop_sub()

  end subroutine zfft_forward


  ! ---------------------------------------------------------
  subroutine zfft_backward(fft, c, r)
    type(fft_t), intent(in) :: fft
    CMPLX, intent(in)  :: c(fft%n(1), fft%n(2), fft%n(3))
    CMPLX, intent(out) :: r(fft%n(1), fft%n(2), fft%n(3))

    call push_sub('fftw2.zfft_backward')

    call fftwnd_f77_one(fft%planb, c, r)

    ! multiply by 1/(N1*N2*N2)
    call lalg_scal(fft%n(1), fft%n(2), fft%n(3), &
      M_z1/real(fft%n(1)*fft%n(2)*fft%n(3), REAL_PRECISION), r)

    call pop_sub()

  end subroutine zfft_backward


  ! ---------------------------------------------------------
  ! convert between array index and G vector
  function pad_feq(i, n, mode)
    integer, intent(in) :: i,n
    logical, intent(in) :: mode
    integer :: pad_feq

    if(mode) then      ! index to frequency number
      if( i <= n/2 + 1 ) then
        pad_feq = i - 1
      else
        pad_feq = i - n -1
      end if
    else
      if( i >= 0 ) then
        pad_feq = i + 1
      else
        pad_feq = i + n + 1
      end if
    end if

    return
  end function pad_feq

end module fft_m
