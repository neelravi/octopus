!! Copyright (C) 2002 M. Marques, A. Castro, A. Rubio, G. Bertsch
!!
!! This program is free software; you can redistribute it and/or modify
!! it under the terms of the GNU General Public License as published by
!! the Free Software Foundation; either version 2, or (at your option)
!! any later version.
!!
!! This program is distributed in the hope that it will be useful,
!! but WITHOUT ANY WARRANTY; without even the implied warranty of
!! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!! GNU General Public License for more details.
!!
!! You should have received a copy of the GNU General Public License
!! along with this program; if not, write to the Free Software
!! Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
!! 02111-1307, USA.
!!
!! $Id$

#include "global.h"

module lcao
  use global
  use messages
  use lib_oct
  use lib_oct_gsl_spline
  use lib_basic_alg
  use lib_adv_alg
  use functions
  use mesh
  use simul_box
  use specie
  use geometry
  use states
  use system
  use hamiltonian
  use grid

  use output

  implicit none

  private
  public :: lcao_type, &
            lcao_init, &
            lcao_wf, &
            lcao_end

  type lcao_type
    integer           :: state ! 0 => non-initialized;
                               ! 1 => initialized (k, s and v1 matrices filled)

    integer           :: dim
    R_TYPE , pointer  :: psis(:, :, :, :)

    R_TYPE,  pointer :: hamilt(:, :, :) ! hamilt stores the Hamiltonian in the LCAO subspace;
    R_TYPE,  pointer :: s     (:, :, :) ! s is the overlap matrix;
    R_TYPE,  pointer :: k     (:, :, :) ! k is the kinetic + spin orbit operator matrix;
    R_TYPE,  pointer :: v     (:, :, :) ! v is the potential.

    logical, pointer  :: atoml(:,:)
  end type lcao_type

contains

subroutine lcao_init(gr, lcao_data, st, h)
  type(lcao_type),         intent(out)   :: lcao_data
  type(grid_type), target, intent(inout) :: gr
  type(states_type),       intent(in)    :: st
  type(hamiltonian_type),  intent(in)    :: h

  type(geometry_type), pointer :: geo

  integer :: ierr

  integer :: norbs, ispin, ik, n1, i1, l, l1, lm1, d1, n2
  integer, parameter :: orbs_local = 2

  R_TYPE, allocatable :: hpsi(:,:)

  if(NDIM.eq.2) return
  if(lcao_data%state == 1) return

  call push_sub('lcao.lcao_init')

  geo => gr%geo

  ! Counting
  allocate(lcao_data%atoml(geo%natoms, 6))
  lcao_data%atoml = .true.
  norbs = 0
  atoms_loop: do i1 = 1, geo%natoms
    if(geo%atom(i1)%spec%local) then
      norbs = geo%atom(i1)%spec%z_val      
      lcao_data%atoml(i1, :) = .true.
    else
      l_loop: do l1 = 1, geo%atom(i1)%spec%ps%conf%p
        l = geo%atom(i1)%spec%ps%conf%l(l1)
        if(sum(geo%atom(i1)%spec%ps%conf%occ(l1, :)).ne.M_ZERO) then
          norbs = norbs + (2*l+1)
        else
          lcao_data%atoml(i1, l1) = .false.
        endif
      end do l_loop
    end if
  end do atoms_loop

  if(st%d%ispin == SPINORS) norbs = norbs * 2

  if(norbs < st%nst) then ! we do not have enough states
    deallocate(lcao_data%atoml)
    message(1) = 'Not enough basis functions to perform LCAO calculation'
    call write_warning(1)
    lcao_data%state = 0
    return
  end if

  lcao_data%dim = norbs
  write(message(1), '(a,i6)') 'Info: LCAO basis dimension: ', lcao_data%dim
  call write_info(1)

  allocate(lcao_data%psis(gr%m%np, st%d%dim, norbs, st%d%nik))
  lcao_data%psis = M_ZERO
  do ik = 1, st%d%nik
    n1 = 1
    do i1 = 1, geo%natoms
      if(geo%atom(i1)%spec%local) then
        do d1 = 1, st%d%dim
           ispin = states_spin_channel(st%d%ispin, ik, d1)
           call atom_get_wf(gr%m, geo%atom(i1), 0, 0, ispin, lcao_data%psis(:, d1, n1, ik))
           call doutput_function (output_fill_how("AxisX"), &
                                  ".", "result", gr%m, gr%sb, lcao_data%psis(:, d1, n1, ik), M_ONE, ierr)
        enddo
      else
        do l1 = 1, geo%atom(i1)%spec%ps%conf%p
           l = geo%atom(i1)%spec%ps%conf%l(l1)
           if(.not. lcao_data%atoml(i1, l1)) cycle
           do lm1 = -l, l
              do d1 = 1, st%d%dim
                 ispin = states_spin_channel(st%d%ispin, ik, d1)
                 call atom_get_wf(gr%m, geo%atom(i1), l1, lm1, ispin, lcao_data%psis(:, d1, n1, ik))
                 n1 = n1 + 1
              end do
           end do
        end do
      endif

    end do
  end do

  ! Allocation of variables
  allocate(lcao_data%hamilt (norbs, norbs, st%d%nik), &
           lcao_data%s      (norbs, norbs, st%d%nik), &
           lcao_data%k      (norbs, norbs, st%d%nik), &
           lcao_data%v      (norbs, norbs, st%d%nik))

  ! Overlap and kinetic+so matrices.
  allocate(hpsi(gr%m%np, st%d%dim))
  do ik = 1, st%d%nik
    do n1 = 1, lcao_data%dim
      call X(kinetic) (h, gr, lcao_data%psis(:, :, n1, ik), hpsi(:, :), ik)
      ! Relativistic corrections...
      select case(h%reltype)
      case(NOREL)
#if defined(COMPLEX_WFNS) && defined(R_TCOMPLEX)
      case(SPIN_ORBIT)
        call zso (h, gr, lcao_data%psis(:, :, n1, ik), hpsi(:, :), ik)
#endif
      case default
        message(1) = 'Error: Internal.'
      call write_fatal(1)
      end select

      do n2 = n1, lcao_data%dim
        lcao_data%k(n1, n2, ik) = X(states_dotp)(gr%m, st%d%dim, hpsi, lcao_data%psis(:, : ,n2, ik))
        lcao_data%s(n1, n2, ik) = X(states_dotp)(gr%m, st%d%dim, lcao_data%psis(:, :, n1, ik), &
                                                 lcao_data%psis(:, : ,n2, ik))
      end do

    end do
  end do
  deallocate(hpsi)

  lcao_data%state = 1

  call pop_sub()
end subroutine lcao_init

subroutine lcao_end(lcao_data)
  type(lcao_type), intent(inout) :: lcao_data
  call push_sub('lcao.lcao_end')

  ASSERT(lcao_data%state == 1)

  if(associated(lcao_data%hamilt)) then
    deallocate(lcao_data%hamilt, lcao_data%s, lcao_data%k, lcao_data%v)
  endif
  if(associated(lcao_data%psis)) deallocate(lcao_data%psis)

  lcao_data%state = 0
  call pop_sub()
end subroutine lcao_end

subroutine lcao_wf(lcao_data, m, sb, st, h)
  type(lcao_type),        intent(inout) :: lcao_data
  type(mesh_type),        intent(in)    :: m
  type(simul_box_type),   intent(in)    :: sb
  type(states_type),      intent(inout) :: st
  type(hamiltonian_type), intent(in)    :: h

  integer, parameter :: orbs_local = 2

  integer :: np, dim, nst, ik, n1, n2, idim
  integer :: norbs
  R_TYPE, allocatable :: hpsi(:,:)
  FLOAT, allocatable :: ev(:)

  ASSERT(lcao_data%state == 1)
  if(sb%dim.eq.2) return

  call push_sub('lcao.lcao_wf')

  norbs = lcao_data%dim
  np = m%np
  dim = st%d%dim
  nst = st%nst

  ! Hamiltonian and overlap matrices.
  allocate(hpsi(np, dim))
  do ik = 1, st%d%nik
    do n1 = 1, lcao_data%dim
      hpsi = M_ZERO
      call X(vlpsi) (h, m, lcao_data%psis(:,:, n1, ik), hpsi(:,:), ik)
      if (h%ep%nvnl > 0) call X(vnlpsi) (h, m, sb, lcao_data%psis(:,:, n1, ik), hpsi(:,:), ik)
      do n2 = n1, lcao_data%dim
        lcao_data%v(n1, n2, ik) = X(states_dotp)(m, dim, hpsi, lcao_data%psis(1:, : ,n2, ik))
        lcao_data%hamilt(n1, n2, ik) = lcao_data%k(n1, n2, ik) + lcao_data%v(n1 , n2, ik)
      end do
    end do
  end do

  do ik = 1, st%d%nik
    allocate(ev(norbs))
    call lalg_geneigensolve(norbs, lcao_data%hamilt(1:norbs, 1:norbs, ik), &
         lcao_data%s(1:norbs, 1:norbs, ik), ev)

    st%eigenval(1:nst, ik) = ev(1:nst)
    deallocate(ev)

    st%X(psi)(:,:,:, ik) = R_TOTYPE(M_ZERO)

    ! Change of base
    do n1 = 1, nst
       do idim = 1, dim
          do n2 = 1, norbs
             call lalg_axpy(np, lcao_data%hamilt(n2, n1, ik), lcao_data%psis(:, idim, n2, ik), &
                            st%X(psi)(:, idim, n1, ik))
          enddo
       enddo
    enddo

   end do

  deallocate(hpsi)
  call pop_sub()
end subroutine lcao_wf

end module lcao






