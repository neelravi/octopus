!! Copyright (C) 2002-2006 M. Marques, A. Castro, A. Rubio, G. Bertsch
!!
!! This program is free software; you can redistribute it and/or modify
!! it under the terms of the GNU General Public License as published by
!! the Free Software Foundation; either version 2, or (at your option)
!! any later version.
!!
!! This program is distributed in the hope that it will be useful,
!! but WITHOUT ANY WARRANTY; without even the implied warranty of
!! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!! GNU General Public License for more details.
!!
!! You should have received a copy of the GNU General Public License
!! along with this program; if not, write to the Free Software
!! Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
!! 02111-1307, USA.
!!
!! -*- coding: utf-8 mode: f90 -*-
!! $Id$

! ---------------------------------------------------------
subroutine eigen_solver_cg3(m, st, h, tol, niter, converged, diff, reorder)
  use trl_info_m
  use trl_interface_m

  type(mesh_t),        target, intent(in)    :: m
  type(states_t),      target, intent(inout) :: st
  type(hamiltonian_t), target, intent(in) :: h
  FLOAT, intent(in)               :: tol
  integer, intent(inout)          :: niter
  integer, intent(out)            :: converged
  FLOAT, intent(out), optional    :: diff(1:st%nst,1:st%d%nik)
  logical, intent(in), optional   :: reorder

  integer :: unit, i
  integer :: nrow, lohi, ned, maxlan, mev, lwrk
  type(trl_info_t) :: info
!!$  R_TYPE, allocatable :: evec(:, :, :)

  call push_sub('eigen_trlan.eigen_solver_cg3')

  if(m%parallel_in_domains) then
    message(1) = 'Error: Trlan-Solver not parallelized for domain decomposition.'
    call write_fatal(1)
  end if
  !  FIXME: Need to adjust m%x and m%vol_pp occurences in the code below
  !         appropriately for domain decomposition. Also parallelization
  !         of the vectors has to be taken care of.

  nrow = (m%np+1)*st%d%dim; ned = st%nst; maxlan = (ned + min(6, ned)); mev = st%nst

!!$  ALLOCATE(evec(sys%m%np, st%d%dim, mev), sys%m%np*st%d%dim*mev)

  call trl_init_info(info, nrow, maxlan, lohi = -1, ned = ned, tol = CNST(1.0e-5), trestart = 3)

  if(in_debug_mode) then
    call io_assign(unit)
    call trl_set_debug(info, msglvl = 10, iou = unit, file = trim(tmpdir)//'trlan_log_')
  end if

  call trl_set_iguess(info, nec = 0, iguess = 1)
  do ik_trlan = 1, st%d%nik
    st%X(psi)(:, :, ik_trlan, 1) = R_TOTYPE(M_ZERO)
    do i = 1, st%nst
      st%X(psi)(:, :, 1, ik_trlan) =            &
        st%X(psi)(:, :, 1, ik_trlan) +       &
        st%X(psi)(:, :, i, ik_trlan)/st%nst
    end do
  end do

  h_trlan  => h
  m_trlan  => m
  st_trlan => st

  do ik_trlan = 1, st%d%nik
!!$     do i = 1, st%nst
!!$        evec(:, :, i) = st%X(psi)(:, :, i, ik_trlan)
!!$     end do
    call trlan(op, info, nrow, mev, &
      st%eigenval(:, ik_trlan), st%X(psi)(:, :, :, ik_trlan), nrow)
!!$     call trlan(op, info, nrow, mev, &
!!$                st%eigenval(:, ik_trlan), evec(:,:,:), nrow)
    if(info%stat.ne.0) then
      write(message(1),'(a,i5)') 'trlan call returned with error flag', info%stat
      call write_fatal(1)
    end if
    converged = info%nec
    niter     = info%matvec

!!$     do i = 1, st%nst
!!$        st%X(psi)(:, :, i, ik_trlan) = evec(:, :, i)
!!$     end do

  end do

  ! WARNING - problem with vol_pp
  message(1) = 'Error: eigen_trlan: Does not work'
  call write_fatal(1)
  !  call lalg_scal(m%np, st%d%dim. st%nst, st%d%nik, R_TOTYPE(M_ONE/sqrt(m%vol_pp)), &
  !     st%X(psi)(:,:,:,:))

  if(in_debug_mode) then
    call io_close(unit)
  end if

  nullify(h_trlan, m_trlan, st_trlan)
  call pop_sub()
end subroutine eigen_solver_cg3


subroutine op(nrow, ncol, xin, ldx, yout, ldy)
  integer, intent(in) :: nrow, ncol, ldx, ldy
  FLOAT, dimension(ldx, ncol), intent(in)  :: xin
  FLOAT, dimension(ldy, ncol), intent(out) :: yout

  integer :: i

  do i = 1, ncol
    call X(Hpsi) (h_trlan, m_trlan, xin(1:, i), yout(2:,i), ik_trlan)
  end do

end subroutine op
