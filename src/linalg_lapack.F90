! computes all the eigenvalues, and optionally, the eigenvectors of a real
! generalized symmetric-definite eigenproblem, of the form  A*x=(lambda)*B*x
! A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.
! Here A and B are assumed to be symmetric and B is also positive definite.
subroutine dgeneigensolve(n, a, b, e)
  integer, intent(in) :: n
  FLOAT, intent(inout) :: a(n, n), e(n)
  FLOAT, intent(in)  ::  b(n, n)

  interface
    subroutine dsygv(itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork, info)
      character(1), intent(in)    :: jobz, uplo
      integer,      intent(in)    :: itype, n, lda, ldb, lwork
      FLOAT,      intent(inout) :: a, b    ! a(lda,n), b(ldb,n)
      FLOAT,      intent(out)   :: w, work ! w(n), work(lwork)
      integer,      intent(out)   :: info
    end subroutine dsygv
  end interface

  integer :: info, lwork
  FLOAT :: bp(n, n)
  FLOAT, allocatable :: work(:)

  lwork = 5*n
  allocate(work(lwork))
  bp = b
  call dsygv(1, 'V', 'U', n, a(1, 1), n, bp(1, 1), n, e(1), work(1), lwork, info)
  if(info.ne.0) then
    write(message(1),'(a,i5)') 'In dgeneigensolve, LAPACK dsygv returned error message ', info
    call write_fatal(1)
  endif
  deallocate(work)

end subroutine dgeneigensolve

! computes all the eigenvalues, and optionally, the eigenvectors of a complex 
! generalized Hermitian-definite eigenproblem, of the form  A*x=(lambda)*B*x,  
! A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.
! Here A and B are assumed to be Hermitian and B is also positive definite.
subroutine zgeneigensolve(n, a, b, e)
  integer, intent(in) :: n
  CMPLX, intent(inout) :: a(n, n)
  CMPLX, intent(in)  ::  b(n, n)
  FLOAT, intent(out) ::  e(n)

  interface
    subroutine zhegv(itype, jobz, uplo, n, a, lda, b, ldb, w, work, lwork, rwork, info)
      character(1), intent(in)    :: jobz, uplo
      integer,      intent(in)    :: n, itype, lda, ldb, lwork
      CMPLX,   intent(inout) :: a, b     ! a(lda,n), b(ldb,n)
      FLOAT,      intent(out)   :: w, rwork ! w(n), rwork(max(1,3*n-2))
      CMPLX,   intent(out)   :: work     ! work(lwork)
      integer,      intent(out)   :: info 
    end subroutine zhegv
  end interface

  integer :: info, lwork
  CMPLX :: bp(n, n)
  FLOAT, allocatable :: rwork(:)
  CMPLX, allocatable :: work(:)

  lwork = 5*n
  allocate(work(lwork), rwork(max(1,3*n-2)))
  bp = b
  call zhegv(1, 'V', 'U', n, a(1, 1), n, bp(1, 1), n, e(1), work(1), lwork, rwork(1), info)
  if(info.ne.0) then
    write(message(1),'(a,i5)') 'In dgeneigensolve, LAPACK dhegv returned error message ', info
    call write_fatal(1)
  endif
  deallocate(work)

end subroutine zgeneigensolve

! computes all eigenvalues and, optionally, eigenvectors of a real symmetric square matrix A.
subroutine deigensolve(n, a, b, e)
  integer, intent(in) :: n
  FLOAT, intent(in)   :: a(n, n)
  FLOAT, intent(out)  ::  b(n, n), e(n)

  interface
    subroutine dsyev(jobz, uplo, n, a, lda, w, work, lwork, info)
      character(1), intent(in)    :: jobz, uplo
      integer,      intent(in)    :: n, lda, lwork
      FLOAT,      intent(inout) :: a       ! a(lda,n)
      FLOAT,      intent(out)   :: w, work ! w(n), work(lwork)
      integer,      intent(out)   :: info 
    end subroutine dsyev
  end interface

  integer :: info, lwork
  FLOAT, allocatable :: work(:)

  lwork = 6*n
  allocate(work(lwork))
  b = a
  call dsyev('V', 'U', n, b(1,1), n, e(1), work(1), lwork, info)
  if(info.ne.0) then
    write(message(1),'(a,i5)') 'In deigensolve, LAPACK dsyev returned error message ', info
    call write_fatal(1)
  endif
  deallocate(work)

end subroutine deigensolve

! computes all eigenvalues and, optionally, eigenvectors of a complex Hermitian square matrix A.
subroutine zeigensolve(n, a, b, e)
  integer, intent(in) :: n
  CMPLX, intent(in)   :: a(n, n)
  CMPLX, intent(out)  ::  b(n, n)
  FLOAT, intent(out)  :: e(n)

  interface
    subroutine zheev(jobz, uplo, n, a, lda, w, work, lwork, rwork, info)
      character(1), intent(in)    :: jobz, uplo
      integer,      intent(in)    :: n, lda, lwork
      CMPLX,   intent(inout) :: a        ! a(lda,n)
      FLOAT,      intent(out)   :: w, rwork ! w(n), rwork(max(1,3*n-2))
      CMPLX,   intent(out)   :: work     ! work(lwork)
      integer,      intent(out)   :: info
    end subroutine zheev
  end interface

  integer :: info, lwork
  CMPLX, allocatable :: work(:)
  FLOAT, allocatable :: rwork(:)

  lwork = 6*n
  allocate(work(lwork), rwork(max(1,3*n-2)))
  b = a
  call zheev('V','U', n, b(1,1), n, e(1), work(1), lwork, rwork(1), info)
  if(info.ne.0) then
    write(message(1),'(a,i5)') 'In zeigensolve, LAPACK zheev returned error message ', info
    call write_fatal(1)
  endif
  deallocate(work, rwork)

end subroutine zeigensolve

! return the determinant of a general square matrix a of dimensions (n,n)
FLOAT function ddet(a, n)
  integer, intent(in)  :: n
  FLOAT, intent(inout) :: a(n, n)

  interface
    subroutine dgetrf(m, n, a, lda, ipiv, info)
      integer, intent(in)    :: m, n, lda
      FLOAT, intent(inout) :: a    ! a(lda,n)
      integer, intent(out)   :: ipiv ! ipiv(min(m,n))
      integer, intent(out)   :: info
    end subroutine dgetrf
  end interface

  integer :: i, info, ipiv(n)
    
  call dgetrf(n, n, a(1,1), n, ipiv(1), info)
  if(info < 0) then
    write(message(1),'(a,i4)') 'In ddet, LAPACK dgetrf returned error code ',info
    call write_fatal(1)
  endif
  ddet = M_ONE
  do i = 1, n
    ddet = ddet*a(i, i)
    if(ipiv(i).ne.i) then
      ipiv(ipiv(i)) = ipiv(i)
      ddet = -ddet
    endif
  enddo

end function ddet

! return the determinant of a general square matrix a of dimensions (n,n)
CMPLX function zdet(a, n)
  integer, intent(in)  :: n
  CMPLX, intent(inout) :: a(n, n)

  interface
    subroutine zgetrf(m, n, a, lda, ipiv, info)
      integer,    intent(in)    :: m, n, lda
      CMPLX, intent(inout) :: a    ! a(lda,n)
      integer,    intent(out)   :: ipiv ! ipiv(min(m,n))
      integer,    intent(out)   :: info
    end subroutine zgetrf
  end interface

  integer :: info, i, ipiv(n)

  call zgetrf(n, n, a(1,1), n, ipiv(1), info)
  if(info < 0) then
    write(message(1),'(a,i4)') 'In zdet, LAPACK zgetrf returned error code ',info
    call write_fatal(1)
  endif
  zdet = M_z1
  do i = 1, n
    zdet = zdet*a(i, i)
    if(ipiv(i).ne.i) then
      ipiv(ipiv(i)) = ipiv(i)
      zdet = -zdet
    endif
  enddo
    
end function zdet

! Invert a real symmetric square matrix a
subroutine dinvert(n, a)
  integer, intent(in) :: n
  FLOAT, intent(inout) :: a(n, n)

  interface
    subroutine dsytrf(uplo, n, a, lda, ipiv, work, lwork, info)
      character(1), intent(in) :: uplo
      integer, intent(in) :: n, lda, lwork
      FLOAT, intent(inout) :: a    ! a(lda,n)
      integer, intent(out) :: ipiv ! ipiv(min(m,n))
      FLOAT, intent(out) :: work   ! work(lwork)
      integer, intent(out) :: info
    end subroutine dsytrf

    subroutine dsytri(uplo, n, a, lda, ipiv, work, info)
      character(1), intent(in) :: uplo
      integer, intent(in) :: n, lda
      FLOAT, intent(inout) :: a    ! a(lda,n)
      integer, intent(out) :: ipiv ! ipiv(min(m,n))
      FLOAT, intent(out) :: work   ! work(n)
      integer, intent(out) :: info
    end subroutine dsytri
  end interface

  integer :: info, i, j
  integer, allocatable :: ipiv(:)
  FLOAT, allocatable :: work(:)

  allocate(work(n), ipiv(n))

  call dsytrf('u', n, a(1, 1), n, ipiv(1), work(1), n, info)
  if(info /= 0) then
    write(message(1), '(a, i3)') 'In dinvert, LAPACK dsytrf returned info = ', info
    call write_fatal(1)
  end if

  call dsytri('u', n, a(1, 1), n, ipiv(1), work(1), info)
  if(info /= 0) then
    write(message(1), '(a, i3)') 'In dinvert, LAPACK dsytri returned info = ', info
    call write_fatal(1)
  end if

  deallocate(work, ipiv)

  ! complete the matrix
  do i = 1, n
    do j = i + 1, n
      a(j, i) = a(i, j)
    end do
  end do

end subroutine dinvert


