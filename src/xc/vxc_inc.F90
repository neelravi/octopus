!! Copyright (C) 2002-2006 M. Marques, A. Castro, A. Rubio, G. Bertsch
!!
!! This program is free software; you can redistribute it and/or modify
!! it under the terms of the GNU General Public License as published by
!! the Free Software Foundation; either version 2, or (at your option)
!! any later version.
!!
!! This program is distributed in the hope that it will be useful,
!! but WITHOUT ANY WARRANTY; without even the implied warranty of
!! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!! GNU General Public License for more details.
!!
!! You should have received a copy of the GNU General Public License
!! along with this program; if not, write to the Free Software
!! Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
!! 02111-1307, USA.
!!
!! $Id$

! ---------------------------------------------------------
subroutine xc_get_vxc(gr, xcs, st, rho, ispin, ex, ec, ip, qtot, vxc, vtau)
  type(grid_t),       intent(inout) :: gr
  type(xc_t), target, intent(in)    :: xcs
  type(states_t),     intent(inout) :: st
  FLOAT,              intent(in)    :: rho(:, :)
  integer,            intent(in)    :: ispin
  FLOAT,              intent(inout) :: ex, ec
  FLOAT,              intent(in)    :: ip, qtot
  FLOAT, optional,    intent(inout) :: vxc(:,:)
  FLOAT, optional,    intent(inout) :: vtau(:,:)

  integer :: n_block

  FLOAT, allocatable :: l_zk(:)
  FLOAT, allocatable :: l_dens(:,:), l_dedd(:,:)
  FLOAT, allocatable :: l_sigma(:,:), l_vsigma(:,:)
  FLOAT :: l_tau(MAX_SPIN), l_ldens(MAX_SPIN), l_dedtau(MAX_SPIN), l_dedldens(MAX_SPIN)

  FLOAT, allocatable :: dens(:,:), dedd(:,:), ex_per_vol(:), ec_per_vol(:)
  FLOAT, allocatable :: gdens(:,:,:), dedgd(:,:,:)
  FLOAT, allocatable :: ldens(:,:), tau(:,:), dedldens(:,:)

  integer :: ib, ib2, jj, ixc, spin_channels
  FLOAT   :: r
  logical :: gga, mgga
  type(profile_t), save :: prof

  type(xc_functl_t), pointer :: functl(:)

  call push_sub('vxc.xc_get_vxc')
  call profiling_in(prof, "XC_LOCAL")

  if(ispin == UNPOLARIZED) then
    functl => xcs%functl(:, 1)
  else
    functl => xcs%functl(:, 2)
  end if

  ! is there anything to do ?
  jj = XC_FAMILY_LDA + XC_FAMILY_GGA + XC_FAMILY_HYB_GGA + XC_FAMILY_MGGA
  if(iand(xcs%family, jj) == 0) go to 999

  if(iand(xcs%family, not(XC_FAMILY_LDA + XC_FAMILY_GGA)) == 0) then
    n_block = 1000
  else
    n_block = 1 ! blocks not yet implemented for the other functionals
  end if

  ! initialize a couple of handy variables
  gga  = iand(xcs%family, XC_FAMILY_GGA + XC_FAMILY_HYB_GGA + XC_FAMILY_MGGA).ne.0
  mgga = iand(xcs%family, XC_FAMILY_MGGA).ne.0

  ! This is a bit ugly (why functl(1) and not functl(2)?, but for the moment it works.
  spin_channels = functl(1)%spin_channels

  call lda_init()
  if( gga) call  gga_init()
  if(mgga) call mgga_init()

  ! Get the gradient and the laplacian of the density and the kinetic energy density
  ! We do it here instead of doing it in gga_init and mgga_init in order to 
  ! avoid calling the subroutine states_calc_tau_jp_gn twice
  if(gga .and. (.not. mgga)) then
    call states_calc_tau_jp_gn(gr, st, grho=gdens)
  elseif(mgga) then
    call states_calc_tau_jp_gn(gr, st, grho=gdens, tau=tau, lrho=ldens)    
  end if

  space_loop: do jj = 1, gr%mesh%np, n_block
    if(jj + n_block > gr%mesh%np) n_block = gr%mesh%np - jj + 1

    ! make a local copy with the correct memory order for libxc
    ib2 = jj
    do ib = 1, n_block
      l_dens(1:spin_channels, ib) = dens(ib2, 1:spin_channels)
      ib2 = ib2 + 1
    end do

    if(gga) then
      ib2 = jj
      do ib = 1, n_block
        l_sigma(1, ib) = sum(gdens(ib2, 1:gr%mesh%sb%dim, 1)*gdens(ib2, 1:gr%mesh%sb%dim, 1))
        if(ispin /= UNPOLARIZED) then
          l_sigma(2, ib) = sum(gdens(ib2, 1:gr%mesh%sb%dim, 1)*gdens(ib2, 1:gr%mesh%sb%dim, 2))
          l_sigma(3, ib) = sum(gdens(ib2, 1:gr%mesh%sb%dim, 2)*gdens(ib2, 1:gr%mesh%sb%dim, 2))
        end if
        ib2 = ib2 + 1
      end do
    end if

    if(mgga) then
      l_tau  (1:spin_channels) =   tau(jj, 1:spin_channels)
      l_ldens(1:spin_channels) = ldens(jj, 1:spin_channels)
    end if

    ! Calculate the potential/gradient density in local reference frame.
    functl_loop: do ixc = 1, 2

      if(.not.present(vxc)) then ! get only the xc energy

        if(iand(functl(ixc)%provides, XC_PROVIDES_EXC).ne.0) then
          select case(functl(ixc)%family)

          case(XC_FAMILY_LDA)
            call XC_F90(lda_exc)(functl(ixc)%conf, n_block, l_dens(1,1), l_zk(1))

          case(XC_FAMILY_GGA)
            call XC_F90(gga_exc)(functl(ixc)%conf, n_block, l_dens(1,1), l_sigma(1,1), l_zk(1))

          case(XC_FAMILY_HYB_GGA)
            message(1) = 'Hyb-GGAs are currently disabled.'
            call write_fatal(1)

          case(XC_FAMILY_MGGA)
            call XC_F90(mgga_exc)(functl(ixc)%conf, l_dens(1,1), l_sigma(1,1), l_ldens(1), l_tau(1), l_zk(1))

          case default
            cycle
          end select

        else ! Do not have an energy functional
          l_zk(:) = M_ZERO
        end if

      else ! we want exc and vxc

        if(iand(functl(ixc)%provides, XC_PROVIDES_EXC).ne.0) then
          ! we get the xc energy and potential
          select case(functl(ixc)%family)
          case(XC_FAMILY_LDA)
            call XC_F90(lda_exc_vxc)(functl(ixc)%conf, n_block, l_dens(1,1), l_zk(1), l_dedd(1,1))

          case(XC_FAMILY_GGA, XC_FAMILY_HYB_GGA)
            call XC_F90(gga_exc_vxc)(functl(ixc)%conf, n_block, l_dens(1,1), l_sigma(1,1), &
              l_zk(1), l_dedd(1,1), l_vsigma(1,1))

          case(XC_FAMILY_MGGA)
            call XC_F90(mgga_exc_vxc)(functl(ixc)%conf, l_dens(1,1), l_sigma(1,1), l_ldens(1), l_tau(1), &
              l_zk(1), l_dedd(1,1), l_vsigma(1,1), l_dedldens(1), l_dedtau(1))

          case default
            cycle
          end select

        else ! we do not have an energy functional so we get just the potential
          l_zk(:) = M_ZERO

          select case(functl(ixc)%family)
          case(XC_FAMILY_LDA)
            call XC_F90(lda_vxc)(functl(ixc)%conf, n_block, l_dens(1,1), l_dedd(1,1))
          
          case(XC_FAMILY_GGA, XC_FAMILY_HYB_GGA)
            l_vsigma = M_ZERO

            if(functl(ixc)%id == XC_GGA_XC_LB) then
              call mesh_r(gr%mesh, jj, r)
              call XC_F90(gga_lb_modified)(functl(ixc)%conf, n_block, l_dens(1,1), l_sigma(1,1), &
                r, l_dedd(1,1))
            else
              call XC_F90(gga_vxc)(functl(ixc)%conf, n_block, l_dens(1,1), l_sigma(1,1), &
                l_dedd(1,1), l_vsigma(1,1))
            end if
          
          case(XC_FAMILY_MGGA)
            call XC_F90(mgga_vxc)(functl(ixc)%conf, l_dens(1,1), l_sigma(1,1), l_ldens(1), l_tau(1), &
              l_dedd(1,1), l_vsigma(1,1), l_dedldens(1), l_dedtau(1))
            
          case default
            cycle
          end select

        end if
      end if

      ib2 = jj
      if(functl(ixc)%type == XC_EXCHANGE) then
        do ib = 1, n_block
          ex_per_vol(ib2) = ex_per_vol(ib2) + sum(l_dens(1:spin_channels, ib)) * l_zk(ib)
          ib2 = ib2 + 1
        end do
      else
        do ib = 1, n_block
          ec_per_vol(ib2) = ec_per_vol(ib2) + sum(l_dens(1:spin_channels, ib)) * l_zk(ib)
          ib2 = ib2 + 1
        end do
      end if

      ! store results
      if(present(vxc)) then
        ib2 = jj
        do ib = 1, n_block
          dedd(ib2, 1:spin_channels) = dedd(ib2, 1:spin_channels) + l_dedd(1:spin_channels, ib)
          ib2 = ib2 + 1
        end do

        if((functl(ixc)%family == XC_FAMILY_GGA).or.(functl(ixc)%family == XC_FAMILY_MGGA)) then
          ib2 = jj
          do ib = 1, n_block
            dedgd(ib2,:,1) = dedgd(ib2,:,1) + M_TWO*l_vsigma(1, ib)*gdens(ib2,:,1)
            if(ispin /= UNPOLARIZED) then
              dedgd(ib2,:,1) = dedgd(ib2,:,1) + l_vsigma(2, ib)*gdens(ib2,:,2)
              dedgd(ib2,:,2) = dedgd(ib2,:,2) +  &
                M_TWO*l_vsigma(3, ib)*gdens(ib2,:,2) + l_vsigma(2, ib)*gdens(ib2,:,1)
            end if
            ib2 = ib2 + 1
          end do
        end if

        if(functl(ixc)%family == XC_FAMILY_MGGA) then
          dedldens(jj, 1:spin_channels) = dedldens(jj, 1:spin_channels) + l_dedldens(1:spin_channels)
          vtau(jj, 1:spin_channels) = vtau(jj, 1:spin_channels) + l_dedtau(1:spin_channels)
        end if
      end if

    end do functl_loop
  end do space_loop

  ! this has to be done in inverse order
  if(present(vxc)) then
    if(mgga) call mgga_process()
    if( gga) call  gga_process()
    call  lda_process()
  end if

  ! integrate eneries per unit volume
  ex = dmf_integrate(gr%mesh, ex_per_vol)
  ec = dmf_integrate(gr%mesh, ec_per_vol)

  ! clean up allocated memory
  call  lda_end()
  if( gga) call  gga_end()
  if(mgga) call mgga_end()


999 continue

  call pop_sub()
  call profiling_out(prof)

contains

  ! ---------------------------------------------------------
  ! Takes care of the initialization of the LDA part of the functionals
  !   *) allocates density and dedd, and their local variants
  !   *) calculates the density taking into account nlcc and non-collinear spin
  subroutine lda_init()
    integer :: ii
    FLOAT   :: d(2), dtot, dpol

    call push_sub('vxc.xc_get_vxc.lda_init')

    ! allocate some general arrays
    SAFE_ALLOCATE(l_dens(1:spin_channels, 1:n_block))
    SAFE_ALLOCATE(l_zk(1:n_block))

    SAFE_ALLOCATE(dens(1:gr%mesh%np_part, 1:spin_channels))
    SAFE_ALLOCATE(ex_per_vol(1:gr%mesh%np))
    SAFE_ALLOCATE(ec_per_vol(1:gr%mesh%np))

    dens       = M_ZERO
    ex_per_vol = M_ZERO
    ec_per_vol = M_ZERO

    if(present(vxc)) then
      SAFE_ALLOCATE(l_dedd(1:spin_channels, 1:n_block))
      SAFE_ALLOCATE(dedd(1:gr%mesh%np_part, 1:spin_channels))
      dedd = M_ZERO
    end if

    do ii = 1, gr%mesh%np
      d(1:spin_channels) = rho(ii, 1:spin_channels)

      select case(ispin)
      case(UNPOLARIZED)
        dens(ii, 1) = max(d(1), M_ZERO)
      case(SPIN_POLARIZED)
        dens(ii, 1) = max(d(1), M_ZERO)
        dens(ii, 2) = max(d(2), M_ZERO)
      case(SPINORS)
        dtot = d(1) + d(2)
        dpol = sqrt((d(1) - d(2))**2 + &
          M_FOUR*(rho(ii, 3)**2 + rho(ii, 4)**2))
        dens(ii, 1) = max(M_HALF*(dtot + dpol), M_ZERO)
        dens(ii, 2) = max(M_HALF*(dtot - dpol), M_ZERO)
      end select
    end do
    
    call pop_sub()
  end subroutine lda_init


  ! ---------------------------------------------------------
  ! deallocate variables allocated in lda_init
  subroutine lda_end()
    SAFE_DEALLOCATE_A(l_dens)
    SAFE_DEALLOCATE_A(l_zk)

    SAFE_DEALLOCATE_A(dens)
    SAFE_DEALLOCATE_A(ex_per_vol)
    SAFE_DEALLOCATE_A(ec_per_vol)
    if(present(vxc)) then
      SAFE_DEALLOCATE_A(l_dedd)
      SAFE_DEALLOCATE_A(dedd)
    end if
  end subroutine lda_end


  ! ---------------------------------------------------------
  ! calculates the LDA part of vxc, taking into account non-collinear spin
  subroutine lda_process()
    integer :: i
    FLOAT :: d(2), dpol, vpol

    call push_sub('vxc.xc_get_vxc.lda_process')

    if(ispin == SPINORS) then
      ! rotate back (do not need the rotation matrix for this).
      do i = 1, gr%mesh%np
        d(1:spin_channels) = rho(i, 1:spin_channels)

        dpol = sqrt((d(1) - d(2))**2 + &
          M_FOUR*(rho(i, 3)**2 + rho(i, 4)**2))
        vpol = (dedd(i, 1) - dedd(i, 2))*(d(1) - d(2))/(dpol + tiny)

        vxc(i, 1) = vxc(i, 1) + M_HALF*(dedd(i, 1) + dedd(i, 2) + vpol)
        vxc(i, 2) = vxc(i, 2) + M_HALF*(dedd(i, 1) + dedd(i, 2) - vpol)
        vxc(i, 3) = vxc(i, 3) + (dedd(i, 1) - dedd(i, 2))*rho(i, 3)/(dpol + tiny)
        vxc(i, 4) = vxc(i, 4) + (dedd(i, 1) - dedd(i, 2))*rho(i, 4)/(dpol + tiny)
      end do
    elseif(ispin == SPIN_POLARIZED) then
      call lalg_axpy(gr%mesh%np, M_ONE, dedd(:, 1), vxc(:, 1))
      call lalg_axpy(gr%mesh%np, M_ONE, dedd(:, 2), vxc(:, 2))
    else
      call lalg_axpy(gr%mesh%np, M_ONE, dedd(:, 1), vxc(:, 1))
    end if

    call pop_sub()
  end subroutine lda_process


  ! ---------------------------------------------------------
  ! initialize GGAs
  !   *) allocates gradient of the density (gdens), dedgd, and its local variants
  !   *) calculates the gradient of the density
  subroutine gga_init()
    integer :: ii

    call push_sub('vxc.xc_get_vxc.gga_init')
    
    ii = 1
    if(ispin /= UNPOLARIZED) ii = 3

    ! allocate variables
    SAFE_ALLOCATE(l_sigma(1:ii, 1:n_block))
    SAFE_ALLOCATE(gdens(1:gr%mesh%np, 1:3, 1:spin_channels))
    gdens = M_ZERO

    if(present(vxc)) then
      SAFE_ALLOCATE(l_vsigma(1:ii, 1:n_block))
      SAFE_ALLOCATE(dedgd(1:gr%mesh%np_part, 1:3, 1:spin_channels))
      dedgd = M_ZERO
    end if

    do ii = 1, 2
      if(functl(ii)%id == XC_GGA_XC_LB) then
        call XC_F90(gga_lb_set_par)(functl(ii)%conf, &
          functl(ii)%LB94_modified, functl(ii)%LB94_threshold, ip, qtot)
      end if
    end do

    call pop_sub()
  end subroutine gga_init


  ! ---------------------------------------------------------
  ! cleans up memory allocated in gga_init
  subroutine gga_end()
    SAFE_DEALLOCATE_A(l_sigma)
    SAFE_DEALLOCATE_A(gdens)
    if(present(vxc)) then
      SAFE_DEALLOCATE_A(l_vsigma)
      SAFE_DEALLOCATE_A(dedgd)
    end if
  end subroutine gga_end


  ! ---------------------------------------------------------
  ! calculates the GGA contribution to vxc
  subroutine gga_process()
    integer :: i, is
    FLOAT, allocatable :: gf(:,:)

    call push_sub('vxc.xc_get_vxc.gga_process')

    ! subtract the divergence of the functional derivative of Exc with respect to
    ! the gradient of the density.
    SAFE_ALLOCATE(gf(1:gr%mesh%np, 1:1))
    do is = 1, spin_channels
      call dderivatives_div(gr%der, dedgd(:, :, is), gf(:, 1))
      call lalg_axpy(gr%mesh%np, -M_ONE, gf(:,1), dedd(:, is))
    end do
    SAFE_DEALLOCATE_A(gf)

    ! If LB94, we can calculate an approximation to the energy from
    ! Levy-Perdew relation PRA 32, 2010 (1985)
    if(functl(1)%id == XC_GGA_XC_LB) then
      SAFE_ALLOCATE(gf(1:gr%mesh%np, 1:3))

      do is = 1, spin_channels
        call dderivatives_grad(gr%der, dedd(:, is), gf(:,:))
        do i = 1, gr%mesh%np
          ex_per_vol(i) = ex_per_vol(i) - dens(i, is) * sum(gr%mesh%x(i,:)*gf(i,:))
        end do
      end do

      SAFE_DEALLOCATE_A(gf)
    end if

    call pop_sub()
  end subroutine gga_process


  ! ---------------------------------------------------------
  ! initialize meta-GGAs
  !   *) allocate the kinetic energy density, dedtau, and local variants
  !   *) calculates tau either from a GEA or from the orbitals
  subroutine mgga_init()
    FLOAT, allocatable :: gnon(:)
    FLOAT gn(MAX_DIM), n, tb09_c
    integer :: ii
    integer, SAVE :: ncall = 0 
    SAFE_ALLOCATE( tau(1:gr%mesh%np, 1:spin_channels))
    SAFE_ALLOCATE(ldens(1:gr%mesh%np, 1:spin_channels))
    if(present(vxc)) then
      SAFE_ALLOCATE(dedldens(1:gr%mesh%np_part, 1:spin_channels))
      dedldens = M_ZERO
    end if

    if(functl(1)%id == XC_MGGA_X_TB09 .and. gr%sb%periodic_dim == 3) then
      SAFE_ALLOCATE(gnon(1:gr%mesh%np))

      do ii = 1, gr%mesh%np
        if(ispin == UNPOLARIZED) then
          n = dens(ii, 1)
          gn(1:gr%mesh%sb%dim) = gdens(ii, 1:gr%mesh%sb%dim, 1)
        else
          n = dens(ii, 1) + dens(ii, 2)
          gn(1:gr%mesh%sb%dim) = gdens(ii, 1:gr%mesh%sb%dim, 1) + gdens(ii, 1:gr%mesh%sb%dim, 2)
        end if
         
        if (n <= CNST(1e-7)) then 
          gnon(ii) = CNST(0.0)
          ! here you will have to print the true gnon(ii) with the correspondent mesh point ii
        else
          gnon(ii) = sqrt(sum((gn(1:gr%mesh%sb%dim)/n)**2))
        end if
      end do
     
      ncall = ncall +1 
      tb09_c =  -CNST(0.012) + CNST(1.023)*sqrt(dmf_integrate(gr%mesh, gnon)/gr%sb%rcell_volume)
           
      write(*,*) "call number " , ncall
 
 
    
      

      write(message(1), '(a,f8.6)') "Info: In the functional TB09 c = ", tb09_c
      call write_info(1)

      call  XC_F90(mgga_x_tb09_set_par)(functl(1)%conf, tb09_c)

      SAFE_DEALLOCATE_A(gnon)
    end if

  end subroutine mgga_init


  ! ---------------------------------------------------------
  ! clean up memory allocates in mgga_init
  subroutine mgga_end()
    SAFE_DEALLOCATE_A(ldens)
    SAFE_DEALLOCATE_A(tau)
    if(present(vxc)) then
      SAFE_DEALLOCATE_A(dedldens)
    end if
  end subroutine mgga_end


  ! ---------------------------------------------------------
  ! calculate the mgga contribution to vxc
  subroutine mgga_process()
    integer :: is
    FLOAT, allocatable :: lf(:,:)

    ! add the laplacian of the functional derivative of Exc with respect to
    ! the gradient of the density.

    SAFE_ALLOCATE(lf(1:gr%mesh%np, 1:1))
    do is = 1, spin_channels
      call dderivatives_lapl(gr%der, dedldens(:, is), lf(:, 1))
      call lalg_axpy(gr%mesh%np, M_ONE, lf(:, 1), dedd(:, is))
    end do
    SAFE_DEALLOCATE_A(lf)
    
  end subroutine mgga_process

end subroutine xc_get_vxc

!! Local Variables:
!! mode: f90
!! coding: utf-8
!! End:
