!! Copyright (C) 2002-2006 M. Marques, A. Castro, A. Rubio, G. Bertsch
!!
!! This program is free software; you can redistribute it and/or modify
!! it under the terms of the GNU General Public License as published by
!! the Free Software Foundation; either version 2, or (at your option)
!! any later version.
!!
!! This program is distributed in the hope that it will be useful,
!! but WITHOUT ANY WARRANTY; without even the implied warranty of
!! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!! GNU General Public License for more details.
!!
!! You should have received a copy of the GNU General Public License
!! along with this program; if not, write to the Free Software
!! Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
!! 02111-1307, USA.
!!
!! $Id$

#include "global.h"

module xc_functl_m
  use datasets_m
  use global_m
  use loct_parser_m
  use XC_F90(lib_m)
  use messages_m

  implicit none

  private
  public ::                     &
    xc_functl_t,                &
    xc_j_functl_init,           &
    xc_functl_init_exchange,    &
    xc_functl_init_correlation, &
    xc_functl_end,              &
    xc_functl_write_info


  ! This adds to the constants defined in lib_xc. But since in that module
  ! the OEP functionals are not included, it is better to put it here.
  integer, public, parameter :: &
    XC_OEP_X = 901     ! Exact exchange

  type xc_functl_t
    integer         :: family            ! LDA, GGA, etc.
    integer         :: type              ! exchange, correlation, or exchange-correlation
    integer         :: id                ! identifier

    integer         :: spin_channels     ! XC_UNPOLARIZED | XC_POLARIZED

    type(XC_F90(func_t)) :: conf         ! the pointer used to call the library
    type(XC_F90(info_t)) :: info         ! information about the functional

    integer         :: LB94_modified     ! should I use a special version of LB94 that
    FLOAT           :: LB94_threshold    ! needs to be handled specially
  end type xc_functl_t

contains

  ! ---------------------------------------------------------
  subroutine xc_functl_init(functl, spin_channels)
    type(xc_functl_t), intent(out) :: functl
    integer,           intent(in)  :: spin_channels

    functl%family = 0
    functl%type   = 0
    functl%id     = 0
    functl%spin_channels = spin_channels

  end subroutine xc_functl_init


  ! ---------------------------------------------------------
  subroutine xc_j_functl_init(functl, cdft, spin_channels)
    type(xc_functl_t), intent(out) :: functl
    logical,           intent(in)  :: cdft
    integer,           intent(in)  :: spin_channels

    ! initialize structure
    call xc_functl_init(functl, spin_channels)

    if (.not.cdft) return

    !%Variable JFunctional
    !%Type integer
    !%Default lca_omc
    !%Section Hamiltonian::XC
    !%Description
    !% Defines the current functional
    !%Option lca_omc 301
    !% Orestes, Marcasso & Capelle 
    !%Option lca_lch 302
    !% Lee, Colwell & Handy
    !%End
    call loct_parse_int(datasets_check('JFunctional'), XC_LCA_OMC, functl%id)

    ! initialize
    select case(functl%id)
    case(0)

    case(XC_LCA_OMC, XC_LCA_LCH)
      functl%family = XC_FAMILY_LCA
      call XC_F90(lca_init)(functl%conf, functl%info, functl%id, &
        spin_channels)

    case default
      write(message(1), '(a,i3,a)') "'", functl%id, &
        "' is not a known current functional!"
      message(2) = "Please check the manual for a list of possible values."
      call write_fatal(2)
    end select

  end subroutine xc_j_functl_init


  ! ---------------------------------------------------------
  subroutine xc_functl_init_exchange(functl, id, ndim, spin_channels)
    type(xc_functl_t), intent(out) :: functl
    integer,           intent(in)  :: id
    integer,           intent(in)  :: ndim
    integer,           intent(in)  :: spin_channels


    call push_sub('xc_functl.xc_functl_init_exchange')

    ! initialize structure
    call xc_functl_init(functl, spin_channels)

    functl%id = id

    if(functl%id.ne.0) then
      ! get the family of the functional
      functl%family = XC_F90(family_from_id)(functl%id)

      if(functl%family == XC_FAMILY_UNKNOWN) then
        if(functl%id == XC_OEP_X) then
          functl%family = XC_FAMILY_OEP
        else
          call input_error('XCFunctional')
        end if
      end if
    end if

    ! initialize
    select case(functl%family)
    case(XC_FAMILY_LDA)
      call XC_F90(lda_init)(functl%conf, functl%info, XC_LDA_X, &
         spin_channels, ndim, XC_NON_RELATIVISTIC)

    case(XC_FAMILY_GGA)
      call XC_F90(gga_init)(functl%conf, functl%info, functl%id, spin_channels)
      if(functl%id == XC_GGA_XC_LB) then
        call loct_parse_int  (datasets_check('LB94_modified'),             0, functl%LB94_modified)
        call loct_parse_float(datasets_check('LB94_threshold'), CNST(1.0e-6), functl%LB94_threshold)
      end if

    case(XC_FAMILY_HYB_GGA)
      call XC_F90(hyb_gga_init)(functl%conf, functl%info, functl%id, spin_channels)
      
    case(XC_FAMILY_MGGA)
      call XC_F90(mgga_init)(functl%conf, functl%info, functl%id, spin_channels)

    end select

    if(functl%family == XC_FAMILY_OEP) then
      functl%type = XC_EXCHANGE
    else if(functl%family .ne. XC_FAMILY_NONE) then
      functl%type = XC_F90(info_kind)(functl%info)
    else
      functl%type = -1
    end if

    call pop_sub()
  end subroutine xc_functl_init_exchange


  ! ---------------------------------------------------------
  subroutine xc_functl_init_correlation(functl, id, ndim, nel, spin_channels)
    type(xc_functl_t), intent(out) :: functl
    integer,           intent(in)  :: id
    integer,           intent(in)  :: ndim
    FLOAT,             intent(in)  :: nel
    integer,           intent(in)  :: spin_channels

    FLOAT :: alpha

    call push_sub('xc_functl.xc_functl_init_correlation')

    ! initialize structure
    call xc_functl_init(functl, spin_channels)

    functl%id = id

    if(functl%id.ne.0) then
      ! get the family of the functional
      functl%family = XC_F90(family_from_id)(functl%id)

      if(functl%family == XC_FAMILY_UNKNOWN) then
        call input_error('XCFunctional')
      end if
    end if

    ! initialize
    select case(functl%family)
    case(XC_FAMILY_LDA)

      if(functl%id==XC_LDA_C_1D_CSC.and.ndim.ne.1) then
        message(1) = 'Functional CSC only allowed in 1D'
        call write_fatal(1)
      end if

      if(functl%id==XC_LDA_C_2D_AMGB.and.ndim.ne.2) then
        message(1) = 'Functional AMGB only allowed in 2D'
        call write_fatal(1)
      end if

      ! we initialize the functionals
      if(functl%id.ne.XC_LDA_C_XALPHA) then
        call XC_F90(lda_init)(functl%conf, functl%info, functl%id, spin_channels)
      else
        call loct_parse_float(datasets_check('Xalpha'), M_ONE, alpha)
        call XC_F90(lda_init)(functl%conf, functl%info, XC_LDA_C_XALPHA, &
          spin_channels, ndim, alpha)
      end if

      ! special parameters that have to be configured
      select case(functl%id)
      case(XC_LDA_C_1D_CSC)
        call loct_parse_float(datasets_check('lda_c_1d_csc_bb'), M_ONE, alpha)
        call XC_F90(lda_c_1d_csc_set_params)(functl%conf, alpha)

      case(XC_LDA_C_2D_PRM)
        call XC_F90(lda_c_2d_prm_set_params)(functl%conf, nel)
      end select

    case(XC_FAMILY_GGA)
      call XC_F90(gga_init)(functl%conf, functl%info, functl%id, spin_channels)

    case(XC_FAMILY_HYB_GGA)
      call XC_F90(hyb_gga_init)(functl%conf, functl%info, functl%id, spin_channels)

    case(XC_FAMILY_MGGA)
      call XC_F90(mgga_init)(functl%conf, functl%info, functl%id, spin_channels)

    end select

    if(functl%family.ne.XC_FAMILY_NONE) then
      functl%type = XC_F90(info_kind)(functl%info)
    else
      functl%type = -1
    end if

    call pop_sub()
  end subroutine xc_functl_init_correlation


  ! ---------------------------------------------------------
  subroutine xc_functl_end(functl)
    type(xc_functl_t), intent(inout) :: functl

    select case(functl%family)
    case(XC_FAMILY_LDA);      call XC_F90(lda_end)     (functl%conf)
    case(XC_FAMILY_GGA);      call XC_F90(gga_end)     (functl%conf)
    case(XC_FAMILY_HYB_GGA);  call XC_F90(hyb_gga_end) (functl%conf)
    case(XC_FAMILY_MGGA);     call XC_F90(mgga_end)    (functl%conf)
    case(XC_FAMILY_LCA);      call XC_F90(lca_end)     (functl%conf)
    end select

  end subroutine xc_functl_end


  ! ---------------------------------------------------------
  subroutine xc_functl_write_info(functl, iunit)
    type(xc_functl_t), intent(in) :: functl
    integer,           intent(in) :: iunit

    character(len=120) :: s1, s2
    integer(SIZEOF_VOIDP) :: str
    integer :: i

    call push_sub('xc_functl.xc_functl_write_info')

    if(functl%family == XC_FAMILY_OEP) then
      ! this is handled separately

      select case(functl%id)
      case(XC_OEP_X)
        write(message(1), '(2x,a)') 'Exchange'
        write(message(2), '(4x,a)') 'Exact exchange'
        call write_info(2, iunit)
      end select

    else if(functl%family .ne. XC_FAMILY_NONE) then ! all the other families
      select case(functl%type)
      case(XC_EXCHANGE)
        write(message(1), '(2x,a)') 'Exchange'
      case(XC_CORRELATION)
        write(message(1), '(2x,a)') 'Correlation'
      case(XC_EXCHANGE_CORRELATION)
        write(message(1), '(2x,a)') 'Exchange-correlation'
      end select

      call XC_F90(info_name)  (functl%info, s1)
      select case(functl%family)
        case (XC_FAMILY_LDA);      write(s2,'(a)') "LDA"
        case (XC_FAMILY_GGA);      write(s2,'(a)') "GGA"
        case (XC_FAMILY_HYB_GGA);  write(s2,'(a)') "Hybrid GGA"
        case (XC_FAMILY_MGGA);     write(s2,'(a)') "MGGA"
        case (XC_FAMILY_LCA);      write(s2,'(a)') "LCA"
      end select
      write(message(2), '(4x,4a)') trim(s1), ' (', trim(s2), ')'
      call write_info(2, iunit)
      
      i = 1; str = 0
      call XC_F90(info_ref)(functl%info, str, s1)
      do while(str >= 0)
        write(message(1), '(4x,a,i1,2a)') '[', i, '] ', trim(s1)
        call write_info(1, iunit)
        call XC_F90(info_ref)(functl%info, str, s1)
        i = i + 1
      end do
    end if

    call pop_sub()
  end subroutine xc_functl_write_info

end module xc_functl_m

!! Local Variables:
!! mode: f90
!! coding: utf-8
!! End:
