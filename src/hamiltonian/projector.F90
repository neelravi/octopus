!! Copyright (C) 2002-2006 M. Marques, A. Castro, A. Rubio, G. Bertsch
!!
!! This program is free software; you can redistribute it and/or modify
!! it under the terms of the GNU General Public License as published by
!! the Free Software Foundation; either version 2, or (at your option)
!! any later version.
!!
!! This program is distributed in the hope that it will be useful,
!! but WITHOUT ANY WARRANTY; without even the implied warranty of
!! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!! GNU General Public License for more details.
!!
!! You should have received a copy of the GNU General Public License
!! along with this program; if not, write to the Free Software
!! Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
!! 02111-1307, USA.
!!
!! $Id$

#include "global.h"

module projector_m
  use batch_m
  use double_grid_m
  use global_m
  use grid_m
  use io_m
  use math_m
  use mesh_function_m
  use mesh_m
  use messages_m
  use simul_box_m
  use profiling_m
  use ps_m
  use geometry_m
  use states_m
  use simul_box_m
  use submesh_m
  use mpi_m
  use mpi_debug_m
  use multicomm_m
  use varinfo_m
  use hgh_projector_m
  use kb_projector_m
  use rkb_projector_m

  implicit none

  private
  public ::                       &
       projector_t,               &
       projector_null,            &
       projector_is_null,         &
       projector_init,            &
       projector_init_phases,     &
       projector_build,           &
       projector_end,             &
       dproject_psi,              &
       zproject_psi,              &
       dproject_psi_batch,        &
       zproject_psi_batch,        &
       dproject_sphere,           &
       zproject_sphere,           &
       dpsia_project_psib,        &
       zpsia_project_psib,        &
       dprojector_commute_r,      &
       zprojector_commute_r

  integer, public, parameter ::  &
       M_NONE = 0,  &
       M_HGH  = 1,  &
       M_KB   = 2,  &
       M_RKB  = 3

  integer, parameter :: MAX_REDUCE_SIZE = 24
  integer, parameter :: MAX_L = 5

  ! The projector data type is intended to hold the local and
  ! non-local parts of the pseudopotentials. The definition of the
  ! action of a projector (which is done through the X(project)
  ! subroutine) depends on the type of the projector. 

  ! There are four different types: 
  ! local -> a local operator
  ! HGH projector -> "normal"
  ! Kleinman-Bylander projector (no spin-orbit) -> "relativistic"
  ! Kleinman-Bylander projector (includes spin-orbit)

  type projector_t
    private
    integer :: type = M_NONE
    integer :: reduce_size
    integer :: lmax
    integer :: lloc
    integer :: nik
    integer :: reltype

    type(submesh_t)  :: sphere
    

    ! Only one of the following structures should be used at once
    ! The one to be used depends on the value of type variable
    type(hgh_projector_t), pointer :: hgh_p(:, :) => null()
    type(kb_projector_t),  pointer :: kb_p(:, :)  => null()
    type(rkb_projector_t), pointer :: rkb_p(:, :) => null()
    CMPLX,                 pointer :: phase(:, :) => null()
  end type projector_t

#ifdef HAVE_MPI
  logical, public :: async_comm
#endif

contains
  ! ---------------------------------------------------------
  subroutine projector_null(p)
    type(projector_t), intent(out) :: p

    call push_sub('projector.projector_null')

    p%type = M_NONE
    nullify(p%phase)
    call submesh_null(p%sphere)

    call pop_sub()

  end subroutine projector_null
  !---------------------------------------------------------


  !---------------------------------------------------------
  logical pure function projector_is_null(p)
    type(projector_t), intent(in) :: p
    projector_is_null = (p%type == M_NONE)
  end function projector_is_null
  !---------------------------------------------------------


  !---------------------------------------------------------
  subroutine projector_init(p, mesh, sb, atm, dim, reltype)
    type(projector_t), intent(inout) :: p
    type(mesh_t),      intent(in)    :: mesh
    type(simul_box_t), intent(in)    :: sb
    type(atom_t),      intent(in)    :: atm
    integer,           intent(in)    :: dim
    integer,           intent(in)    :: reltype
    
    call push_sub('projector.projector_init')

    nullify(p%phase)
    p%reltype = reltype
    p%lmax = atm%spec%ps%l_max

    if(p%lmax == 0) then
      p%type = M_NONE
      call pop_sub(); return
    end if

    p%lloc = atm%spec%ps%l_loc

    call submesh_init_sphere(p%sphere, sb, mesh, atm%x, atm%spec%ps%rc_max + mesh%h(1))

    select case (atm%spec%ps%kbc)
    case (1)
      p%type = M_KB
      if (reltype == 1) then
        write(message(1),'(a,a,a)') "Spin-orbit coupling for species ", trim(atm%spec%label), " is not available."
        call write_warning(1)
      end if
    case (2)
      if (reltype == 0) then
        p%type = M_KB
      else
        p%type = M_RKB
      end if
    case (3)
      p%type = M_HGH
    end select
    
    select case(p%type)
    case(M_KB)
      p%reduce_size = dim * atm%spec%ps%kbc
    case(M_RKB)
      p%reduce_size = 4
    case(M_HGH)
      p%reduce_size = 24
    end select

    call pop_sub()
  end subroutine projector_init

  subroutine projector_init_phases(this, sb, nkpoints, kpoints, vec_pot, vec_pot_var)
    type(projector_t), intent(inout) :: this
    type(simul_box_t), intent(in)    :: sb
    integer,           intent(in)    :: nkpoints
    FLOAT,             intent(in)    :: kpoints(:, :)
    FLOAT, optional,   intent(in)    :: vec_pot(1:MAX_DIM)
    FLOAT,             pointer       :: vec_pot_var(:, :)

    integer :: ns, ik, is
    FLOAT   :: kr
    integer :: ndim

    call push_sub('projector.projector_init_phases')

    ns = this%sphere%ns
    ndim = sb%dim

    if(.not. associated(this%phase)) then
      SAFE_ALLOCATE(this%phase(1:ns, 1:nkpoints))
    end if

    do ik = 1, nkpoints

      do is = 1, ns
        kr = sum(kpoints(1:ndim, ik) * &
          (this%sphere%x(is, 1:ndim) - this%sphere%mesh%x(this%sphere%jxyz(is), 1:ndim)))
        if(present(vec_pot)) kr = kr + sum(vec_pot(1:ndim) * this%sphere%x(is, 1:ndim))
        if(associated(vec_pot_var)) kr = kr + sum(vec_pot_var(this%sphere%jxyz(is), 1:ndim)*this%sphere%x(is, 1:ndim))
        this%phase(is, ik) = exp(-M_zI * kr)
      end do

    end do

    call pop_sub()

  end subroutine projector_init_phases

  !---------------------------------------------------------
  subroutine projector_build(p, gr, a, so_strength)
    type(projector_t), intent(inout) :: p
    type(grid_t),      intent(in)    :: gr
    type(atom_t),      intent(in)    :: a
    FLOAT,             intent(in)    :: so_strength

    integer :: ll, mm

    call push_sub('projector.projector_build')

    select case (p%type)

    case (M_HGH)
      SAFE_ALLOCATE(p%hgh_p(0:p%lmax, -p%lmax:p%lmax))
      do ll = 0, p%lmax
        if(ll == p%lloc) cycle
        do mm = -ll, ll
          call hgh_projector_null(p%hgh_p(ll, mm))
          call hgh_projector_init(p%hgh_p(ll, mm), p%sphere, gr, a, ll, mm, so_strength)
        end do
      end do

    case (M_KB)
      SAFE_ALLOCATE(p%kb_p(0:p%lmax, -p%lmax:p%lmax))
      do ll = 0, p%lmax
        if(ll == p%lloc) cycle
        do mm = -ll, ll
          call kb_projector_null(p%kb_p(ll, mm))
          call kb_projector_init(p%kb_p(ll, mm), p%sphere, gr, a, ll, mm)
        end do
      end do

    case (M_RKB)
      SAFE_ALLOCATE(p%rkb_p(1:p%lmax, -p%lmax:p%lmax))
      do ll = 1, p%lmax
        if(ll == p%lloc) cycle
        do mm = -ll, ll
          call rkb_projector_null(p%rkb_p(ll, mm))
          call rkb_projector_init(p%rkb_p(ll, mm), p%sphere, a, ll, mm, so_strength)
        end do
      end do
      ! for rkb, l = 0 is a normal kb
      if(p%lloc /= 0) then
        SAFE_ALLOCATE(p%kb_p(1:1, 1:1))
        call kb_projector_null(p%kb_p(1, 1))
        call kb_projector_init(p%kb_p(1, 1), p%sphere, gr, a, 0, 0)
      end if

    end select

    call pop_sub()
  end subroutine projector_build

  !---------------------------------------------------------
  subroutine projector_end(p)
    type(projector_t), intent(inout) :: p

    integer :: ll, mm

    call push_sub('projector.projector_end')

    call submesh_end(p%sphere)

    select case(p%type)
    case(M_HGH)
      do ll = 0, p%lmax
        if(ll == p%lloc) cycle
        do mm = -ll, ll
          call hgh_projector_end(p%hgh_p(ll, mm))
        end do
      end do
      SAFE_DEALLOCATE_P(p%hgh_p)

    case(M_KB)
      do ll = 0, p%lmax
        if(ll == p%lloc) cycle
        do mm = -ll, ll
          call kb_projector_end(p%kb_p(ll, mm))
        end do
      end do
      SAFE_DEALLOCATE_P(p%kb_p)

    case(M_RKB)
      do ll = 1, p%lmax
        if(ll == p%lloc) cycle
        do mm = -ll, ll
          call rkb_projector_end(p%rkb_p(ll, mm))
        end do
      end do
      SAFE_DEALLOCATE_P(p%rkb_p)
      if(p%lloc /= 0) then
        call kb_projector_end(p%kb_p(1, 1))
        SAFE_DEALLOCATE_P(p%kb_p)
      end if

    end select
    
    p%type = M_NONE

    SAFE_DEALLOCATE_P(p%phase)

    call pop_sub()
  end subroutine projector_end

#include "undef.F90"
#include "real.F90"
#include "projector_inc.F90"

#include "undef.F90"
#include "complex.F90"
#include "projector_inc.F90"

end module projector_m



!! Local Variables:
!! mode: f90
!! coding: utf-8
!! End:
