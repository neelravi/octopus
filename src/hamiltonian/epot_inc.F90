!! Copyright (C) 2002-2006 M. Marques, A. Castro, A. Rubio, G. Bertsch
!!
!! This program is free software; you can redistribute it and/or modify
!! it under the terms of the GNU General Public License as published by
!! the Free Software Foundation; either version 2, or (at your option)
!! any later version.
!!
!! This program is distributed in the hope that it will be useful,
!! but WITHOUT ANY WARRANTY; without even the implied warranty of
!! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!! GNU General Public License for more details.
!!
!! You should have received a copy of the GNU General Public License
!! along with this program; if not, write to the Free Software
!! Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
!! 02111-1307, USA.
!!
!! $Id$

subroutine X(calc_forces_from_potential)(gr, geo, ep, st, time, lr, lr2, lr_dir, Born_sum)
  type(grid_t),         intent(inout) :: gr
  type(geometry_t),     intent(inout) :: geo
  type(epot_t),         intent(in)    :: ep
  type(states_t),       intent(inout) :: st
  FLOAT,                intent(in)    :: time
  type(lr_t), optional, intent(inout) :: lr
  type(lr_t), optional, intent(inout) :: lr2
  integer,    optional, intent(in)    :: lr_dir
  CMPLX,      optional, intent(out)   :: Born_sum(:)
  ! provide these optional arguments to calculate Born effective charges rather than forces
  ! lr, lr2 should be the wfns from electric perturbation in the lr_dir direction
  ! lr is for +omega, lr2 is for -omega.
  ! for each atom, Z*(i,j) = dF(j)/dE(i)
  ! Born_sum is the sum over atoms of a given tensor component of the Born charges,
  !   which should be zero if the acoustic sum rule is satisfied

  integer :: iatom, ist, ik, idim, idir, np, np_part, ip

  R_TYPE, allocatable :: psi(:, :)
  R_TYPE, allocatable :: dl_psi(:, :)
  R_TYPE, allocatable :: dl_psi2(:, :)
  R_TYPE, allocatable :: grad_psi(:, :, :)
  R_TYPE, allocatable :: grad_dl_psi(:, :, :)
  R_TYPE, allocatable :: grad_dl_psi2(:, :, :)
  FLOAT,  allocatable :: vloc(:)
  CMPLX,  allocatable :: grad_rho(:, :), force(:, :), zvloc(:)
  CMPLX :: phase
#ifdef HAVE_MPI
  integer, allocatable :: recv_count(:), recv_displ(:)
  CMPLX, allocatable  :: force_local(:, :), grad_rho_local(:, :)
  type(profile_t), save :: prof
#endif

  call push_sub('epot_inc.Xcalc_forces_from_potential')

  ASSERT(present(lr) .eqv. present(lr_dir))
  ASSERT(present(lr) .eqv. present(lr2))
  ASSERT(present(lr) .eqv. present(Born_sum))
  ! need all to calculate Born charges
  if(present(lr_dir)) then
    ASSERT(lr_dir > 0 .and. lr_dir <= gr%mesh%sb%dim)
  end if

  np = gr%fine%mesh%np
  np_part = gr%fine%mesh%np_part
  ! if there is no fine mesh, gr%fine%mesh => gr%mesh according to grid.F90

  if(present(lr)) then
    ALLOCATE(grad_dl_psi(np_part, 1:gr%mesh%sb%dim, st%d%dim), np_part*gr%mesh%sb%dim*st%d%dim)
    ALLOCATE(grad_dl_psi2(np_part, 1:gr%mesh%sb%dim, st%d%dim), np_part*gr%mesh%sb%dim*st%d%dim)
  endif
  ALLOCATE(grad_psi(np_part, 1:gr%mesh%sb%dim, st%d%dim), np_part*gr%mesh%sb%dim*st%d%dim)
  ALLOCATE(grad_rho(np, 1:gr%mesh%sb%dim), np*gr%mesh%sb%dim)
  grad_rho(1:np, 1:gr%mesh%sb%dim) = M_ZERO
  ALLOCATE(force(1:gr%mesh%sb%dim, 1:geo%natoms), gr%mesh%sb%dim*geo%natoms)
  force = M_ZERO

  ! even if there is no fine mesh, we need to make another copy
  ALLOCATE(psi(np_part, st%d%dim), np_part*st%d%dim)
  if(present(lr)) then
    ALLOCATE(dl_psi(np_part, st%d%dim), np_part*st%d%dim)
    ALLOCATE(dl_psi2(np_part, st%d%dim), np_part*st%d%dim)
  endif

  !THE NON-LOCAL PART (parallel in states and k-points)
  do ik = st%d%kpt%start, st%d%kpt%end
    do ist = st%st_start, st%st_end
      do idim = 1, st%d%dim

        if(gr%have_fine_mesh) then
        ! conveniently, multigrid_coarse2fine sets the boundary conditions in the process
          call X(multigrid_coarse2fine)(gr%fine, st%X(psi)(:, idim, ist, ik), psi(:, idim))
          if (present(lr)) then
            call X(multigrid_coarse2fine)(gr%fine, lr%X(dl_psi)(:, idim, ist, ik), dl_psi(:, idim))
            call X(multigrid_coarse2fine)(gr%fine, lr2%X(dl_psi)(:, idim, ist, ik), dl_psi2(:, idim))
          endif
        else
          call lalg_copy(gr%mesh%np_part, st%X(psi)(:, idim, ist, ik), psi(:, idim))
          call X(set_bc)(gr%der, psi(:, idim))

          if (present(lr)) then
            call lalg_copy(gr%mesh%np_part, lr%X(dl_psi)(:, idim, ist, ik), dl_psi(:, idim))
            call X(set_bc)(gr%der, dl_psi(:, idim))
            call lalg_copy(gr%mesh%np_part, lr2%X(dl_psi)(:, idim, ist, ik), dl_psi2(:, idim))
            call X(set_bc)(gr%der, dl_psi2(:, idim))
          endif
        endif

        if(simul_box_is_periodic(gr%sb) .and. .not. kpoint_is_gamma(st%d, ik)) then
          do ip = 1, np_part
            phase = exp(-M_zI*sum(st%d%kpoints(1:gr%sb%dim, ik)*gr%mesh%x(ip, 1:gr%sb%dim)))
            psi(ip, idim) = phase*psi(ip, idim)
            if(present(lr)) then
              dl_psi(ip, idim) = phase*dl_psi(ip, idim)
              dl_psi2(ip, idim) = phase*dl_psi2(ip, idim)
            endif
          end do
        endif
       
        ! calculate the gradients of the wave-functions
        ! and set boundary conditions in preparation for applying projectors
        call X(derivatives_grad)(gr%fine%der, psi(:, idim), grad_psi(:, :, idim), set_bc = .false.)
        do idir = 1, gr%mesh%sb%dim
          call X(set_bc)(gr%der, grad_psi(:, idir, idim))
        enddo

        if (present(lr)) then
          call X(derivatives_grad)(gr%fine%der, dl_psi(:, idim), grad_dl_psi(:, :, idim), set_bc = .false.)
          call X(derivatives_grad)(gr%fine%der, dl_psi2(:, idim), grad_dl_psi2(:, :, idim), set_bc = .false.)

          do idir = 1, gr%mesh%sb%dim
            call X(set_bc)(gr%der, grad_dl_psi(:, idir, idim))
            call X(set_bc)(gr%der, grad_dl_psi2(:, idir, idim))
          enddo
        endif

        !accumulate to calculate the gradient of the density
        if (present(lr)) then
          forall (idir = 1:gr%mesh%sb%dim, ip = 1:np) &
            grad_rho(ip, idir) = grad_rho(ip, idir) + st%d%kweights(ik) * st%occ(ist, ik) * &
            (R_CONJ(grad_psi(ip, idir, idim)) * dl_psi(ip, idim) + R_CONJ(psi(ip, idim)) * grad_dl_psi(ip, idir, idim) &
            + R_CONJ(dl_psi2(ip, idim)) * grad_psi(ip, idir, idim) + R_CONJ(grad_dl_psi2(ip, idir, idim)) * psi(ip, idim))
        else
          forall (idir = 1:gr%mesh%sb%dim, ip = 1:np) grad_rho(ip, idir) = grad_rho(ip, idir) + &
            st%d%kweights(ik) * st%occ(ist, ik) * M_TWO * R_CONJ(psi(ip, idim)) * grad_psi(ip, idir, idim)
        endif
      end do

      call profiling_count_operations(np*st%d%dim*gr%mesh%sb%dim*(2 + R_MUL))
      ! probably this is not accurate anymore

      ! iterate over the projectors
      do iatom = 1, geo%natoms
        if(projector_is_null(ep%proj(iatom))) cycle
        do idir = 1, gr%mesh%sb%dim

          if(present(lr)) then
            force(idir, iatom) = force(idir, iatom) - st%d%kweights(ik) * st%occ(ist, ik) * &
               (X(psia_project_psib)(ep%proj_fine(iatom), st%d%dim, grad_psi(:, idir, :), dl_psi, ik) &
              + X(psia_project_psib)(ep%proj_fine(iatom), st%d%dim, psi, grad_dl_psi(:, idir, :), ik) &
              + X(psia_project_psib)(ep%proj_fine(iatom), st%d%dim, dl_psi2, grad_psi(:, idir, :), ik) &
              + X(psia_project_psib)(ep%proj_fine(iatom), st%d%dim, grad_dl_psi2(:, idir, :), psi, ik))
          else
            force(idir, iatom) = force(idir, iatom) - M_TWO * st%d%kweights(ik) * st%occ(ist, ik) * &
              X(psia_project_psib)(ep%proj_fine(iatom), st%d%dim, psi, grad_psi(:, idir, :), ik)
          endif

        end do
      end do

    end do
  end do
  
  SAFE_DEALLOCATE_A(psi)
  if(present(lr)) then
    SAFE_DEALLOCATE_A(dl_psi)
    SAFE_DEALLOCATE_A(dl_psi2)
  endif

  SAFE_DEALLOCATE_A(grad_psi)
  if(present(lr)) then
    SAFE_DEALLOCATE_A(grad_dl_psi)
    SAFE_DEALLOCATE_A(grad_dl_psi2)
  endif

#if defined(HAVE_MPI)
  if(st%parallel_in_states) then

    call profiling_in(prof, "FORCES_MPI")

    !reduce the force
    ALLOCATE(force_local(1:gr%mesh%sb%dim, 1:geo%natoms), gr%mesh%sb%dim*geo%natoms)
    force_local = force
    call MPI_Allreduce(force_local, force, gr%mesh%sb%dim*geo%natoms, MPI_CMPLX, MPI_SUM, st%mpi_grp%comm, mpi_err)
    SAFE_DEALLOCATE_A(force_local)

    !reduce the gradient of the density
    ALLOCATE(grad_rho_local(np, gr%mesh%sb%dim), np*gr%mesh%sb%dim)
    call lalg_copy(np, gr%mesh%sb%dim, grad_rho, grad_rho_local)
    call MPI_Allreduce(grad_rho_local, grad_rho, np*gr%mesh%sb%dim, MPI_CMPLX, MPI_SUM, st%mpi_grp%comm, mpi_err)
    SAFE_DEALLOCATE_A(grad_rho_local)

    call profiling_out(prof)

  end if

  if(st%d%kpt%parallel) then
    
    call profiling_in(prof, "FORCES_MPI")
    
    !reduce the force
    ALLOCATE(force_local(1:gr%mesh%sb%dim, 1:geo%natoms), gr%mesh%sb%dim*geo%natoms)
    force_local = force
    call MPI_Allreduce(force_local, force, gr%mesh%sb%dim*geo%natoms, MPI_CMPLX, MPI_SUM, st%d%kpt%mpi_grp%comm, mpi_err)
    SAFE_DEALLOCATE_A(force_local)
    
    !reduce the gradient of the density
    ALLOCATE(grad_rho_local(np, gr%mesh%sb%dim), np*gr%mesh%sb%dim)
    call lalg_copy(np, gr%mesh%sb%dim, grad_rho, grad_rho_local)
    call MPI_Allreduce(grad_rho_local, grad_rho, np*gr%mesh%sb%dim, MPI_CMPLX, MPI_SUM, st%d%kpt%mpi_grp%comm, mpi_err)
    SAFE_DEALLOCATE_A(grad_rho_local)

    call profiling_out(prof)

  end if

#endif
  
  do iatom = 1, geo%natoms
    if(present(lr)) then
      geo%atom(iatom)%Born_charge(lr_dir, 1:gr%mesh%sb%dim) = force(1:gr%mesh%sb%dim, iatom)
    else
      geo%atom(iatom)%f(1:gr%mesh%sb%dim) = geo%atom(iatom)%f(1:gr%mesh%sb%dim) + real(force(1:gr%mesh%sb%dim, iatom))
    endif
  end do

  ! THE LOCAL PART (parallel in atoms)

  ALLOCATE(vloc(1:np), np)
  ALLOCATE(zvloc(1:np), np)
  
  do iatom = geo%atoms%start, geo%atoms%end
    
    vloc(1:np) = M_ZERO
    
    call epot_local_potential(ep, gr, gr%fine%mesh, geo, iatom, vloc, time)
    
    forall(ip = 1:np) zvloc(ip) = vloc(ip)

    do idir = 1, gr%mesh%sb%dim
      force(idir, iatom) = -zmf_dotp(gr%fine%mesh, zvloc, grad_rho(:, idir))
    end do

  end do

  SAFE_DEALLOCATE_A(vloc)

#ifdef HAVE_MPI
  if(geo%atoms%parallel) then

    call profiling_in(prof, "FORCES_MPI")

    ! each node has a piece of the force array, they have to be
    ! collected by all nodes, MPI_Allgatherv does precisely this (if
    ! we get the arguments right).

    ALLOCATE(recv_count(geo%atoms%mpi_grp%size), geo%atoms%mpi_grp%size)
    ALLOCATE(recv_displ(geo%atoms%mpi_grp%size), geo%atoms%mpi_grp%size)
    ALLOCATE(force_local(1:gr%mesh%sb%dim, 1:geo%atoms%nlocal), gr%mesh%sb%dim*geo%atoms%nlocal)

    recv_count(1:geo%atoms%mpi_grp%size) = gr%mesh%sb%dim*geo%atoms%num(0:geo%atoms%mpi_grp%size - 1)
    recv_displ(1:geo%atoms%mpi_grp%size) = gr%mesh%sb%dim*(geo%atoms%range(1, 0:geo%atoms%mpi_grp%size - 1) - 1)

    force_local(1:gr%mesh%sb%dim, 1:geo%atoms%nlocal) = force(1:gr%mesh%sb%dim, geo%atoms%start:geo%atoms%end)

    call MPI_Allgatherv(&
         force_local, gr%mesh%sb%dim*geo%atoms%nlocal, MPI_CMPLX, &
         force, recv_count(1), recv_displ, MPI_CMPLX, &
         geo%atoms%mpi_grp%comm, mpi_err)

    SAFE_DEALLOCATE_A(recv_count)
    SAFE_DEALLOCATE_A(recv_displ)
    SAFE_DEALLOCATE_A(force_local)

    call profiling_out(prof)

  end if
#endif

  if(present(lr)) then
    Born_sum(1:gr%mesh%sb%dim) = M_ZERO 

    do iatom = 1, geo%natoms
      geo%atom(iatom)%Born_charge(lr_dir, lr_dir) = geo%atom(iatom)%Born_charge(lr_dir, lr_dir) + geo%atom(iatom)%spec%Z_val
      do idir = 1, gr%mesh%sb%dim
        geo%atom(iatom)%Born_charge(lr_dir, idir) = geo%atom(iatom)%Born_charge(lr_dir, idir) + force(idir, iatom)
        Born_sum(idir) = Born_sum(idir) + geo%atom(iatom)%Born_charge(lr_dir, idir)
      enddo
    enddo

    ! enforce acoustic sum rule: sum(iatom) Z*(iatom,idir,idir2) = 0
    do iatom = 1, geo%natoms
      do idir = 1, gr%mesh%sb%dim
        geo%atom(iatom)%Born_charge(lr_dir, idir) = geo%atom(iatom)%Born_charge(lr_dir, idir) - Born_sum(idir) / geo%natoms
      enddo
    enddo

  else
    forall (iatom = 1:geo%natoms, idir = 1:gr%mesh%sb%dim) 
      geo%atom(iatom)%f(idir) = geo%atom(iatom)%f(idir) + real(force(idir, iatom))
    end forall
  endif

  SAFE_DEALLOCATE_A(force)
  call pop_sub()
  
end subroutine X(calc_forces_from_potential)

!! Local Variables:
!! mode: f90
!! coding: utf-8
!! End:
