!! Copyright (C) 2002-2006 M. Marques, A. Castro, A. Rubio, G. Bertsch
!!
!! This program is free software; you can redistribute it and/or modify
!! it under the terms of the GNU General Public License as published by
!! the Free Software Foundation; either version 2, or (at your option)
!! any later version.
!!
!! This program is distributed in the hope that it will be useful,
!! but WITHOUT ANY WARRANTY; without even the implied warranty of
!! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!! GNU General Public License for more details.
!!
!! You should have received a copy of the GNU General Public License
!! along with this program; if not, write to the Free Software
!! Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
!! 02111-1307, USA.
!!
!! $Id$

! ---------------------------------------------------------
subroutine X(vlaser_operator_quadratic) (laser, der, std, psi, hpsi)
  type(laser_t),       intent(in)    :: laser
  type(derivatives_t), intent(inout) :: der
  type(states_dim_t),  intent(in)    :: std
  R_TYPE,              intent(inout) :: psi(:,:)  ! psi(gr%mesh%np_part, h%d%dim)
  R_TYPE,              intent(inout) :: hpsi(:,:) ! hpsi(gr%mesh%np_part, h%d%dim)

  integer :: k
  logical :: vector_potential, magnetic_field

  FLOAT :: a_field(1:MAX_DIM), a_field_prime(1:MAX_DIM), b(1:MAX_DIM), b_prime(1:MAX_DIM)
  FLOAT, allocatable :: a(:, :), a_prime(:, :)

  call push_sub('h_inc.Xvlaser_operator_quadratic')

  a_field = M_ZERO

  vector_potential = .false.
  magnetic_field = .false.

  select case(laser_kind(laser))
  case(E_FIELD_ELECTRIC) ! do nothing
  case(E_FIELD_MAGNETIC)
    if(.not. allocated(a)) then 
      SAFE_ALLOCATE(a(1:der%mesh%np_part, 1:der%mesh%sb%dim))
      a = M_ZERO
      SAFE_ALLOCATE(a_prime(1:der%mesh%np_part, 1:der%mesh%sb%dim))
      a_prime = M_ZERO
    end if
    call laser_vector_potential(laser, a_prime)
    a = a + a_prime
    call laser_field(der%mesh%sb, laser, b_prime)
    b = b + b_prime
    magnetic_field = .true.
  case(E_FIELD_VECTOR_POTENTIAL)
    call laser_field(der%mesh%sb, laser, a_field_prime)
    a_field = a_field + a_field_prime
    vector_potential = .true.
  end select

  if(magnetic_field) then
    do k = 1, der%mesh%np
      hpsi(k, :) = hpsi(k, :) + M_HALF*dot_product(a(k, 1:der%mesh%sb%dim), a(k, 1:der%mesh%sb%dim))*psi(k, :) / P_c**2
    end do
    SAFE_DEALLOCATE_A(a)
    SAFE_DEALLOCATE_A(a_prime)
  end if
  if(vector_potential) then
    do k = 1, der%mesh%np
      hpsi(k, :) = hpsi(k, :) + M_HALF*dot_product(a_field(1:der%mesh%sb%dim), a_field(1:der%mesh%sb%dim))*psi(k, :) / P_c**2
    end do
  end if

  call pop_sub()
end subroutine X(vlaser_operator_quadratic)

! ---------------------------------------------------------
subroutine X(vlaser_operator_linear) (laser, der, std, psi, hpsi, ik, gyromagnetic_ratio, a_static)
  type(laser_t),       intent(in)    :: laser
  type(derivatives_t), intent(inout) :: der
  type(states_dim_t),  intent(in)    :: std
  R_TYPE,              intent(inout) :: psi(:,:) 
  R_TYPE,              intent(inout) :: hpsi(:,:)
  integer,             intent(in)    :: ik
  FLOAT,               intent(in)    :: gyromagnetic_ratio
  FLOAT, optional,     intent(in)    :: a_static(:,:)

  integer :: k, idim
  logical :: electric_field, vector_potential, magnetic_field
  R_TYPE, allocatable :: grad(:, :, :), lhpsi(:, :)

  FLOAT :: a_field(1:MAX_DIM), a_field_prime(1:MAX_DIM), b(1:MAX_DIM), b_prime(1:MAX_DIM)

  FLOAT, allocatable :: v(:), pot(:), a(:, :), a_prime(:, :)

  call push_sub('h_inc.Xvlaser_operator_linear')

  a_field = M_ZERO

  electric_field = .false.
  vector_potential = .false.
  magnetic_field = .false.

  select case(laser_kind(laser))
  case(E_FIELD_SCALAR_POTENTIAL)
    if(.not. allocated(v)) then 
      SAFE_ALLOCATE(v(1:der%mesh%np))
      v = M_ZERO
    end if
    call laser_potential(der%mesh%sb, laser, der%mesh, v)
    electric_field = .true.

  case(E_FIELD_ELECTRIC)
    if(.not. allocated(v)) then 
      SAFE_ALLOCATE(v(1:der%mesh%np))
      v = M_ZERO
      SAFE_ALLOCATE(pot(1:der%mesh%np))
      pot = M_ZERO
    end if
    call laser_potential(der%mesh%sb, laser, der%mesh, pot)
    v = v + pot
    electric_field = .true.
    SAFE_DEALLOCATE_A(pot)

  case(E_FIELD_MAGNETIC)
    if(.not. allocated(a)) then 
      SAFE_ALLOCATE(a(1:der%mesh%np_part, 1:der%mesh%sb%dim))
      a = M_ZERO
      SAFE_ALLOCATE(a_prime(1:der%mesh%np_part, 1:der%mesh%sb%dim))
      a_prime = M_ZERO
    end if
    call laser_vector_potential(laser, a_prime)
    a = a + a_prime
    call laser_field(der%mesh%sb, laser, b_prime)
    b = b + b_prime
    magnetic_field = .true.
  case(E_FIELD_VECTOR_POTENTIAL)
    call laser_field(der%mesh%sb, laser, a_field_prime)
    a_field = a_field + a_field_prime
    vector_potential = .true.
  end select

  if(electric_field) then
    do k = 1, std%dim
      hpsi(1:der%mesh%np, k)= hpsi(1:der%mesh%np, k) + v(1:der%mesh%np) * psi(1:der%mesh%np, k)
    end do
    SAFE_DEALLOCATE_A(v)
  end if

  if(magnetic_field) then

    SAFE_ALLOCATE(grad(1:der%mesh%np_part, 1:der%mesh%sb%dim, 1:std%dim))
 
    do idim = 1, std%dim
      call X(derivatives_grad)(der, psi(:, idim), grad(:, :, idim))
    end do

    ! If there is a static magnetic field, its associated vector potential is coupled with
    ! the time-dependent one defined as a "laser" (ideally one should just add them all and
    ! do the calculation only once...). Note that h%ep%a_static already has been divided
    ! by P_c, and therefore here we only divide by P_c, and not P_c**2.
    if(present(a_static)) then
      do k = 1, der%mesh%np
        hpsi(k, :) = hpsi(k, :) + dot_product(a(k, 1:der%mesh%sb%dim), a_static(k, 1:der%mesh%sb%dim))*psi(k, :) / P_c
      end do
    end if

    select case(std%ispin)
    case(UNPOLARIZED, SPIN_POLARIZED)
      do k = 1, der%mesh%np
        hpsi(k, 1) = hpsi(k, 1) - M_zI*dot_product(a(k, 1:der%mesh%sb%dim), grad(k, 1:der%mesh%sb%dim, 1)) / P_c
      end do
    case (SPINORS)
      do k = 1, der%mesh%np
        do idim = 1, std%dim
          hpsi(k, idim) = hpsi(k, idim) - M_zI*dot_product(a(k, 1:der%mesh%sb%dim), grad(k, 1:der%mesh%sb%dim, idim)) / P_c
        end do
      end do
    end select


    select case (std%ispin)
    case (SPIN_POLARIZED)
      SAFE_ALLOCATE(lhpsi(1:der%mesh%np, 1:std%dim))
      if(modulo(ik+1, 2) == 0) then ! we have a spin down
        lhpsi(1:der%mesh%np, 1) = - M_HALF/P_C*sqrt(dot_product(b, b))*psi(1:der%mesh%np, 1)
      else
        lhpsi(1:der%mesh%np, 1) = + M_HALF/P_C*sqrt(dot_product(b, b))*psi(1:der%mesh%np, 1)
      end if
      hpsi(1:der%mesh%np, :) = hpsi(1:der%mesh%np, :) + (gyromagnetic_ratio * M_HALF) * lhpsi(1:der%mesh%np, :)
      SAFE_DEALLOCATE_A(lhpsi)

    case (SPINORS)
      SAFE_ALLOCATE(lhpsi(1:der%mesh%np, 1:std%dim))
      lhpsi(1:der%mesh%np, 1) = M_HALF/P_C*( b(3)*psi(1:der%mesh%np, 1) &
           + (b(1) - M_zI*b(2))*psi(1:der%mesh%np, 2))
      lhpsi(1:der%mesh%np, 2) = M_HALF/P_C*(-b(3)*psi(1:der%mesh%np, 2) &
           + (b(1) + M_zI*b(2))*psi(1:der%mesh%np, 1))
      hpsi(1:der%mesh%np, :) = hpsi(1:der%mesh%np, :) + (gyromagnetic_ratio * M_HALF) * lhpsi(1:der%mesh%np, :)
      SAFE_DEALLOCATE_A(lhpsi)
    end select

    SAFE_DEALLOCATE_A(grad)
    SAFE_DEALLOCATE_A(a)
    SAFE_DEALLOCATE_A(a_prime)
  end if

  if(vector_potential) then
    SAFE_ALLOCATE(grad(1:der%mesh%np_part, 1:der%mesh%sb%dim, 1:std%dim))

    do idim = 1, std%dim
      call X(derivatives_grad)(der, psi(:, idim), grad(:, :, idim))
    end do

    select case(std%ispin)
    case(UNPOLARIZED, SPIN_POLARIZED)
      do k = 1, der%mesh%np
        hpsi(k, 1) = hpsi(k, 1) - M_zI*dot_product(a_field(1:der%mesh%sb%dim), grad(k, 1:der%mesh%sb%dim, 1)) / P_c
      end do
    case (SPINORS)
      do k = 1, der%mesh%np
        do idim = 1, std%dim
          hpsi(k, idim) = hpsi(k, idim) - M_zI*dot_product(a_field(1:der%mesh%sb%dim), grad(k, 1:der%mesh%sb%dim, idim)) / P_c
        end do
      end do
    end select
    SAFE_DEALLOCATE_A(grad)
  end if

  call pop_sub()
end subroutine X(vlaser_operator_linear)


! ---------------------------------------------------------
subroutine X(vlasers) (lasers, nlasers, der, std, psi, hpsi, grad, ik, gyromagnetic_ratio, a_static, t)
  type(laser_t),       intent(in)    :: lasers(:)
  integer,             intent(in)    :: nlasers
  type(derivatives_t), intent(inout) :: der
  type(states_dim_t),  intent(in)    :: std
  R_TYPE,              intent(inout) :: psi(:,:)  ! psi(der%mesh%np_part, std%dim)
  R_TYPE,              intent(inout) :: hpsi(:,:) ! hpsi(der%mesh%np_part, std%dim)
  R_TYPE,              intent(inout) :: grad(: , :, :)
  integer,             intent(in)    :: ik
  FLOAT,               intent(in)    :: gyromagnetic_ratio
  FLOAT,    optional,  intent(in)    :: a_static(:,:)
  FLOAT,    optional,  intent(in)    :: t

  integer :: k, idim
  logical :: electric_field, vector_potential, magnetic_field
  R_TYPE, allocatable :: lhpsi(:, :)
  type(profile_t), save :: ext_fields_profile

  FLOAT :: a_field(1:MAX_DIM), a_field_prime(1:MAX_DIM), b(1:MAX_DIM), b_prime(1:MAX_DIM)

  FLOAT, allocatable :: v(:), pot(:), a(:, :), a_prime(:, :)

  call push_sub('h_inc.Xvlasers')
  call profiling_in(ext_fields_profile, 'EXTERNAL_FIELDS')

  a_field = M_ZERO

  electric_field = .false.
  vector_potential = .false.
  magnetic_field = .false.

  call get_fields()
  
  if(electric_field)   call apply_electric_field()
  if(magnetic_field)   call apply_magnetic_field()
  if(vector_potential) call apply_vector_potential()

  call profiling_out(ext_fields_profile)
  call pop_sub()

contains

  ! ---------------------------------------------------------
  subroutine get_fields()
    integer :: i

    do i = 1, nlasers

      select case(laser_kind(lasers(i)))
      case(E_FIELD_SCALAR_POTENTIAL, E_FIELD_ELECTRIC)
        if(.not. allocated(v)) then 
          SAFE_ALLOCATE(v(1:der%mesh%np))
          v = M_ZERO
        end if
        SAFE_ALLOCATE(pot(1:der%mesh%np))
        pot = M_ZERO
        call laser_potential(der%mesh%sb, lasers(i), der%mesh, pot, t)
        v = v + pot
        electric_field = .true.
        SAFE_DEALLOCATE_A(pot)
        
      case(E_FIELD_MAGNETIC)
        if(.not. allocated(a)) then 
          SAFE_ALLOCATE(a(1:der%mesh%np_part, 1:der%mesh%sb%dim))
          a = M_ZERO
          SAFE_ALLOCATE(a_prime(1:der%mesh%np_part, 1:der%mesh%sb%dim))
          a_prime = M_ZERO
        end if

        call laser_vector_potential(lasers(i), a_prime, t)
        a = a + a_prime
        if(present(t)) then
          call laser_field(der%mesh%sb, lasers(i), b_prime, t)
        else 
          call laser_field(der%mesh%sb, lasers(i), b_prime)
        end if
        b = b + b_prime
        magnetic_field = .true.
        
      case(E_FIELD_VECTOR_POTENTIAL)
        call laser_field(der%mesh%sb, lasers(i), a_field_prime, t)
        a_field = a_field + a_field_prime
        vector_potential = .true.
        
      end select

    end do

  end subroutine get_fields


  ! ---------------------------------------------------------
  subroutine apply_electric_field()
    do k = 1, std%dim
      hpsi(1:der%mesh%np, k)= hpsi(1:der%mesh%np, k) + v(1:der%mesh%np) * psi(1:der%mesh%np, k)
    end do
    SAFE_DEALLOCATE_A(v)
  end subroutine apply_electric_field


  ! ---------------------------------------------------------
  subroutine apply_magnetic_field()
    do k = 1, der%mesh%np
      hpsi(k, :) = hpsi(k, :) + M_HALF*dot_product(a(k, 1:der%mesh%sb%dim), &
        a(k, 1:der%mesh%sb%dim))*psi(k, :) / P_c**2
    end do

    ! If there is a static magnetic field, its associated vector potential is coupled with
    ! the time-dependent one defined as a "laser" (ideally one should just add them all and
    ! do the calculation only once...). Note that h%ep%a_static already has been divided
    ! by P_c, and therefore here we only divide by P_c, and not P_c**2.
    if(present(a_static)) then
      do k = 1, der%mesh%np
        hpsi(k, :) = hpsi(k, :) + dot_product(a(k, 1:der%mesh%sb%dim), &
          a_static(k, 1:der%mesh%sb%dim))*psi(k, :) / P_c
      end do
    end if
    
    select case(std%ispin)
    case(UNPOLARIZED, SPIN_POLARIZED)
      do k = 1, der%mesh%np
        hpsi(k, 1) = hpsi(k, 1) - M_zI*dot_product(a(k, 1:der%mesh%sb%dim), grad(k, 1:der%mesh%sb%dim, 1)) / P_c
      end do
    case (SPINORS)
      do k = 1, der%mesh%np
        do idim = 1, std%dim
          hpsi(k, idim) = hpsi(k, idim) - M_zI*dot_product(a(k, 1:der%mesh%sb%dim), grad(k, 1:der%mesh%sb%dim, idim)) / P_c
        end do
      end do
    end select


    select case (std%ispin)
    case (SPIN_POLARIZED)
      SAFE_ALLOCATE(lhpsi(1:der%mesh%np, 1:std%dim))
      if(modulo(ik+1, 2) == 0) then ! we have a spin down
        lhpsi(1:der%mesh%np, 1) = - M_HALF/P_C*sqrt(dot_product(b, b))*psi(1:der%mesh%np, 1)
      else
        lhpsi(1:der%mesh%np, 1) = + M_HALF/P_C*sqrt(dot_product(b, b))*psi(1:der%mesh%np, 1)
      end if
      hpsi(1:der%mesh%np, :) = hpsi(1:der%mesh%np, :) + (gyromagnetic_ratio * M_HALF) * lhpsi(1:der%mesh%np, :)
      SAFE_DEALLOCATE_A(lhpsi)

    case (SPINORS)
      SAFE_ALLOCATE(lhpsi(1:der%mesh%np, 1:std%dim))
      lhpsi(1:der%mesh%np, 1) = M_HALF/P_C*( b(3)*psi(1:der%mesh%np, 1) &
        + (b(1) - M_zI*b(2))*psi(1:der%mesh%np, 2))
      lhpsi(1:der%mesh%np, 2) = M_HALF/P_C*(-b(3)*psi(1:der%mesh%np, 2) &
        + (b(1) + M_zI*b(2))*psi(1:der%mesh%np, 1))
      hpsi(1:der%mesh%np, :) = hpsi(1:der%mesh%np, :) + (gyromagnetic_ratio * M_HALF) * lhpsi(1:der%mesh%np, :)
      SAFE_DEALLOCATE_A(lhpsi)
    end select

    SAFE_DEALLOCATE_A(a)
    SAFE_DEALLOCATE_A(a_prime)

  end subroutine apply_magnetic_field


  ! ---------------------------------------------------------
  subroutine apply_vector_potential()
    do k = 1, der%mesh%np
      hpsi(k, :) = hpsi(k, :) + M_HALF*dot_product(a_field(1:der%mesh%sb%dim), a_field(1:der%mesh%sb%dim))*psi(k, :) / P_c**2
    end do

    select case(std%ispin)
    case(UNPOLARIZED, SPIN_POLARIZED)
      do k = 1, der%mesh%np
        hpsi(k, 1) = hpsi(k, 1) - M_zI*dot_product(a_field(1:der%mesh%sb%dim), grad(k, 1:der%mesh%sb%dim, 1)) / P_c
      end do
    case (SPINORS)
      do k = 1, der%mesh%np
        do idim = 1, std%dim
          hpsi(k, idim) = hpsi(k, idim) - M_zI*dot_product(a_field(1:der%mesh%sb%dim), grad(k, 1:der%mesh%sb%dim, idim)) / P_c
        end do
      end do
    end select

  end subroutine apply_vector_potential

end subroutine X(vlasers)

!! Local Variables:
!! mode: f90
!! coding: utf-8
!! End:
