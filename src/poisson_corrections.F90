!! Copyright (C) 2002 M. Marques, A. Castro, A. Rubio, G. Bertsch
!!
!! This program is free software; you can redistribute it and/or modify
!! it under the terms of the GNU General Public License as published by
!! the Free Software Foundation; either version 2, or (at your option)
!! any later version.
!!
!! This program is distributed in the hope that it will be useful,
!! but WITHOUT ANY WARRANTY; without even the implied warranty of
!! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!! GNU General Public License for more details.
!!
!! You should have received a copy of the GNU General Public License
!! along with this program; if not, write to the Free Software
!! Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
!! 02111-1307, USA.
!!
!! $Id$

#include "global.h"

module poisson_corrections_m
  use global_m
  use lib_oct_m
  use derivatives_m
  use mesh_m
  use mesh_function_m
  use messages_m

  implicit none

  private
  public ::         &
    phi,            &
    aux,            &
    maxl,           &
    der_pointer,    &
    mesh_pointer,   &
    build_phi,      &
    kill_phi,       &
    build_aux,      &
    kill_aux,       &
    correct_rho,    &
    get_multipoles, &
    op, opt, dotp

  type(der_discr_t), pointer :: der_pointer
  type(mesh_t),      pointer :: mesh_pointer

  integer :: maxl
  FLOAT, allocatable :: phi(:, :)
  FLOAT, allocatable :: aux(:, :)

  FLOAT, parameter :: alpha_ = M_FIVE

contains

  ! ---------------------------------------------------------
  subroutine correct_rho(m, ml, rho, rho_corrected, vh_correction)
    implicit none
    type(mesh_t), intent(in)  :: m
    integer,      intent(in)  :: ml
    FLOAT,        intent(in)  :: rho(:)
    FLOAT,        intent(out) :: rho_corrected(:)
    FLOAT,        intent(out) :: vh_correction(:)

    integer :: i, add_lm, l, mm, lldfac, j
    FLOAT   :: alpha, r2
    FLOAT, allocatable :: mult(:)
    FLOAT, allocatable :: betal(:)

    call push_sub('poisson_corrections.correct_rho')

    ALLOCATE(mult((ml+1)**2), (ml+1)**2)
    call get_multipoles(m, rho, ml, mult)

    alpha = alpha_*m%h(1)

    ALLOCATE(betal((ml+1)**2), (ml+1)**2)
    add_lm = 1
    do l = 0, ml
      do mm = -l, l
        lldfac = 1; do j = 1, 2*l+1, 2; lldfac = lldfac * j; end do
        betal(add_lm) = (2**(l+2))/( alpha**(2*l+3) * sqrt(M_PI) * lldfac )
        add_lm = add_lm + 1
      end do
    end do

    rho_corrected = M_ZERO    
    rho_corrected(1:m%np) = rho(1:m%np)
    vh_correction = M_ZERO
    do i = 1, m%np
      r2 = dot_product(m%x(i, 1:3), m%x(i, 1:3)) ! mesh_r could be used, but it wastes time.
      r2 = exp(-r2/alpha**2)
      add_lm = 1
      do l = 0, ml
        do mm = -l, l
          rho_corrected(i) = rho_corrected(i) - mult(add_lm) * betal(add_lm) * aux(add_lm, i) * r2
          vh_correction(i) = vh_correction(i) + mult(add_lm) * phi(add_lm, i)
          add_lm = add_lm + 1
        end do
      end do
    end do

    deallocate(mult, betal)
    call pop_sub()
  end subroutine correct_rho


  ! ---------------------------------------------------------
  subroutine get_multipoles(m, rho, ml, mult)
    implicit none
    type(mesh_t), intent(in)  :: m
    FLOAT,           intent(in)  :: rho(:)  ! rho(m%np)
    integer,         intent(in)  :: ml
    FLOAT,           intent(out) :: mult((ml+1)**2)

    FLOAT   :: tmp(m%np)
    integer :: add_lm, l, mm

    call push_sub('poisson_corrections.get_multipoles')

    mult(:) = M_ZERO
    add_lm = 1
    do l = 0, ml
      do mm = -l, l
        tmp(1:m%np) = rho(1:m%np)*aux(add_lm, 1:m%np)
        ! Use Xmf_integrate, so things work parallel too.
        mult(add_lm) = dmf_integrate(m, tmp)
        add_lm = add_lm + 1
      end do
    end do

    call pop_sub()
  end subroutine get_multipoles


  ! ---------------------------------------------------------
  subroutine build_phi(m)
    type(mesh_t), intent(in) :: m

    FLOAT :: alpha, beta, gamma, ylm, r, x(MAX_DIM)
    integer :: i, l, add_lm, lldfac, j, mm

    call push_sub('poisson_corrections.build_phi')

    ALLOCATE(phi((maxl+1)**2, m%np), (maxl+1)**2*m%np)

    alpha = alpha_*m%h(1)
    do i = 1, m%np
      call mesh_r(m, i, r, x = x)
      add_lm = 1
      do l = 0, maxl
        lldfac = 1; do j = 1, 2*l+1, 2; lldfac = lldfac * j; end do
        beta = (2**(l+2))/( alpha**(2*l+3) * sqrt(M_PI) * lldfac )
        gamma = ( sqrt(M_PI)*2**(l+3) ) / lldfac
        do mm = -l, l
          ylm  = loct_ylm(x(1), x(2), x(3), l, mm)
          if(r .ne. M_ZERO) then
            phi(add_lm, i) = gamma * isubl( l, r/alpha) * ylm / r**(l+1)
          else
            phi(add_lm, i) = gamma * ylm / alpha
          end if
          add_lm = add_lm + 1
        end do
      end do
    end do

    call pop_sub()
  contains

    ! ---------------------------------------------------------
    FLOAT function isubl(l, x)
      integer, intent(in) :: l
      FLOAT,   intent(in) :: x

      isubl = M_HALF*loct_gamma(l + M_HALF)*(M_ONE - loct_incomplete_gamma(l+M_HALF, x**2) )
    end function isubl

  end subroutine build_phi


  ! ---------------------------------------------------------
  subroutine kill_phi
    if(allocated(phi)) deallocate(phi)
  end subroutine kill_phi


  ! ---------------------------------------------------------
  subroutine build_aux(m)
    type(mesh_t), intent(in) :: m

    FLOAT :: ylm, r, x(MAX_DIM)
    integer :: i, l, add_lm, mm

    call push_sub('poisson_corrections.build_aux')
    ALLOCATE(aux((maxl+1)**2, m%np), (maxl+1)**2*m%np)

    do i = 1, m%np
      call mesh_r(m, i, r, x = x)
      add_lm = 1
      do l = 0, maxl
        do mm = -l, l
          ylm  = loct_ylm(x(1), x(2), x(3), l, mm)
          if(r .ne. M_ZERO) then
            aux(add_lm, i) = r**l*ylm
          else
            if(l==0) then
              aux(add_lm, i) = ylm
            else
              aux(add_lm, i) = M_ZERO
            end if
          end if
          add_lm = add_lm + 1
        end do
      end do
    end do

    call pop_sub()
  end subroutine build_aux


  ! ---------------------------------------------------------
  subroutine kill_aux
   if(allocated(aux)) deallocate(aux)
  end subroutine kill_aux


  ! ---------------------------------------------------------
  subroutine op(x, y)
    FLOAT, intent(inout) :: x(:)
    FLOAT, intent(out)   :: y(:)

    call push_sub('poisson_corrections.op')

    call dderivatives_lapl(der_pointer, x, y)

    call pop_sub()

  end subroutine op


  ! ---------------------------------------------------------
  FLOAT function dotp(x, y) result(res)
    FLOAT, intent(inout) :: x(:)
    FLOAT, intent(in)    :: y(:)

    res     = dmf_dotp(mesh_pointer, x, y)
  end function dotp


  ! ---------------------------------------------------------
  subroutine opt(x, y)
    FLOAT, intent(inout) :: x(:)
    FLOAT, intent(out)   :: y(:)

    call dderivatives_laplt(der_pointer, x, y)
  end subroutine opt


end module poisson_corrections_m
