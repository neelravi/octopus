!! Copyright (C) 2002-2006 M. Marques, A. Castro, A. Rubio, G. Bertsch
!!
!! This program is free software; you can redistribute it and/or modify
!! it under the terms of the GNU General Public License as published by
!! the Free Software Foundation; either version 2, or (at your option)
!! any later version.
!!
!! This program is distributed in the hope that it will be useful,
!! but WITHOUT ANY WARRANTY; without even the implied warranty of
!! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!! GNU General Public License for more details.
!!
!! You should have received a copy of the GNU General Public License
!! along with this program; if not, write to the Free Software
!! Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
!! 02111-1307, USA.
!!
!! -*- coding: utf-8 mode: f90 -*-
!! $Id$

#include "global.h"

module poisson_m
  use datasets_m
  use geometry_m
  use global_m
  use io_m
  use lib_oct_m
  use lib_oct_parser_m
  use mesh_m
  use messages_m
  use mpi_m
  use profiling_m
  use simul_box_m
  use units_m
#ifdef HAVE_FFT
  use fft_m
  use cube_function_m
#endif
  use functions_m
  use math_m
  use poisson_corrections_m
  use poisson_cg_m
  use poisson_isf_m
  use grid_m
  use output_m
  use poisson_multigrid_m
  use mesh_function_m
  use par_vec_m
  use lib_oct_gsl_spline_m

  implicit none

  private
  public ::             &
    poisson_init,       &
    dpoisson_solve,     &
    zpoisson_solve,     &
    poisson_end,        &
    poisson_test

  integer, parameter :: &
    CG            =  5, &
    CG_CORRECTED  =  6, &
    MULTIGRILLA   =  7, &
    ISF           =  8
  
#ifdef HAVE_FFT
  integer, parameter :: &
    DIRECT_SUM_1D = -1, &
    DIRECT_SUM_2D = -2, &
    FFT_SPH       =  0, &
    FFT_CYL       =  1, &
    FFT_PLA       =  2, &
    FFT_NOCUT     =  3, &
    FFT_CORRECTED =  4

  type(dcf_t) :: fft_cf
  FLOAT, pointer :: fft_coulb_FS(:,:,:)
#endif

  integer :: poisson_solver = -99
  type(mg_solver_t) :: mg

  type hartree_t
    private
    logical        :: increase_box
    type(grid_t)   :: grid
  end type hartree_t

  type(hartree_t) :: hartree_integrator

contains

  !-----------------------------------------------------------------
  subroutine poisson_init(gr, geo)
    type(grid_t), intent(inout) :: gr
    type(geometry_t), intent(in) :: geo

    if(poisson_solver.ne.-99) return ! already initialized

    call push_sub('poisson.poisson_init')

    call messages_print_stress(stdout, "Hartree")
    select case(NDIM)
    case(1); call init_1D()
    case(2); call init_2D()
    case(3); call init_3D()
    end select
    call messages_print_stress(stdout)

    call pop_sub()
  contains

    !%Variable PoissonSolver
    !%Type integer
    !%Default fft
    !%Section Hamiltonian::Poisson
    !%Description
    !% Defines which method to use in order to solve the Poisson equation.
    !% The default for 1D and 2D is the direct evaluation of the Hartree potential.
    !%Option direct2D -2
    !% Direct evaluation of the Hartree potential (in 2D)
    !%Option direct1D -1
    !% Direct evaluation of the Hartree potential (in 1D)
    !%Option fft 0
    !% FFTs using spherical cutoff (in 2D or 3D; uses FFTW)
    !%Option fft_cyl 1
    !% FFTs using cylindrical cutoff (in 3D; uses FFTW)
    !%Option fft_pla 2
    !% FFTs using planar cutoff (in 3D; uses FFTW)
    !%Option fft_nocut 3
    !% FFTs without using a cutoff (in 3D; uses FFTW)
    !%Option fft_corrected 4
    !% FFTs + corrections
    !%Option cg 5
    !% Conjugated gradients
    !%Option cg_corrected 6
    !% Corrected conjugated gradients
    !%Option multigrid 7
    !% Multigrid method
    !%Option isf 8
    !% Interpolating Scaling Functions poisson solver.
    !%End

    !---------------\--------------------------------------------------
    subroutine init_1D()
      poisson_solver = -NDIM ! internal type

      call messages_print_var_option(stdout, "PoissonSolver", poisson_solver)
    end subroutine init_1D


    !-----------------------------------------------------------------
    subroutine init_2D()
#if defined(HAVE_FFT)
      call loct_parse_int(check_inp('PoissonSolver'), gr%sb%periodic_dim, poisson_solver)
      if( (poisson_solver .ne. FFT_SPH) .and. (poisson_solver .ne. DIRECT_SUM_2D) ) then
        call input_error('PoissonSolver')
      end if

#else
      poisson_solver = -NDIM ! internal type
#endif

      if(gr%m%use_curvlinear .and. (poisson_solver .ne. -NDIM) ) then
        message(1) = 'If curvilinear coordinates are used in 2D, then the only working'
        message(2) = 'Poisson solver is -2 ("direct summation in two dimensions")'
        call write_fatal(2)
      end if

      call messages_print_var_option(stdout, "PoissonSolver", poisson_solver)
      call poisson2D_init(gr)
    end subroutine init_2D


    !-----------------------------------------------------------------
    subroutine init_3D()
#ifdef HAVE_FFT
      call loct_parse_int(check_inp('PoissonSolver'), gr%sb%periodic_dim, poisson_solver)
      if(poisson_solver < FFT_SPH .or. poisson_solver > ISF ) then
        call input_error('PoissonSolver')
      end if

      if(poisson_solver /= gr%sb%periodic_dim .and. &
        poisson_solver < CG .and. &
        poisson_solver /= FFT_CORRECTED .and. poisson_solver /= FFT_CYL) then
        write(message(1), '(a,i1,a)')'The System is periodic in ', gr%sb%periodic_dim ,' dimension(s),'
        write(message(2), '(a,i1,a)')'but Poisson Solver is set for ',poisson_solver,' dimensions.'
        message(3) =                 'You know what you are doing, right?'
        call write_warning(3)
      end if
#else
      call loct_parse_int(check_inp('PoissonSolver'), CG, poisson_solver)
      if(poisson_solver < CG) then
        call input_error('PoissonSolver')
      end if
#endif

      if(gr%m%use_curvlinear .and. (poisson_solver.ne.CG_CORRECTED) .and. (poisson_solver.ne.MULTIGRILLA) ) then
        message(1) = 'If curvilinear coordinates are used, then the only working'
        message(2) = 'Poisson solvers are cg_corrected ("corrected conjugate gradients") and'
        message(3) = 'multigrid.'
        call write_fatal(3)
      end if

      if(gr%m%parallel_in_domains .and. poisson_solver.eq.MULTIGRILLA) then
        message(1) = 'When running in parallel in domains, you cannot use: '
        message(2) = 'PoissonSolver = multigrid'
        call write_fatal(2)
      end if

      if( (gr%sb%box_shape .eq. MINIMUM) .and. (poisson_solver .eq. CG_CORRECTED) ) then
        message(1) = 'When using the "minimum" box shape and the "cg_corrected"'
        message(2) = 'Poisson solver, we have observed "sometimes" some non-'
        message(3) = 'negligible error. You may want to check that the "fft" or "cg"'
        message(4) = 'solver are providing, in your case, the same results.'
        call write_warning(4)
      end if

      call messages_print_var_option(stdout, "PoissonSolver", poisson_solver)
      call poisson3D_init(gr, geo)
    end subroutine init_3D

  end subroutine poisson_init


  !-----------------------------------------------------------------
  subroutine poisson_end()
    call push_sub('poisson.poisson_end')

    select case(poisson_solver)
#ifdef HAVE_FFT
    case(FFT_SPH,FFT_CYL,FFT_PLA,FFT_NOCUT)
      call dcf_free(fft_cf)
      deallocate(fft_coulb_FS); nullify(fft_coulb_FS)
    case(FFT_CORRECTED)
      call dcf_free(fft_cf)
      deallocate(fft_coulb_FS); nullify(fft_coulb_FS)
      call poisson_corrections_end()

#endif
    case(CG_CORRECTED)
      call poisson_cg_end()
    case(MULTIGRILLA)
      call poisson_multigrid_end(mg)
    case(ISF)
      call poisson_isf_end()

    end select
    poisson_solver = -99

    call pop_sub()
  end subroutine poisson_end


  !-----------------------------------------------------------------
  subroutine zpoisson_solve(gr, pot, rho)
    type(grid_t),  target, intent(inout) :: gr
    CMPLX,                 intent(inout) :: pot(:)  ! pot(m%np)
    CMPLX,                 intent(in)    :: rho(:)  ! rho(m%np)

    FLOAT, allocatable :: aux1(:), aux2(:)

    call push_sub('poisson.zpoisson_solve')

    ALLOCATE(aux1(gr%m%np), gr%m%np)
    ALLOCATE(aux2(gr%m%np), gr%m%np)

    ! first the real part
    aux1(1:NP) = real(rho(1:NP))
    aux2(1:NP) = real(pot(1:NP))
    call dpoisson_solve(gr, aux2, aux1)
    pot(1:NP)  = aux2(1:NP)

    ! now the imaginary part
    aux1(1:NP) = aimag(rho(1:NP))
    aux2(1:NP) = aimag(pot(1:NP))
    call dpoisson_solve(gr, aux2, aux1)
    pot(1:NP) = pot(1:NP) + M_zI*aux2(1:NP)

    deallocate(aux1, aux2)

    call pop_sub()
  end subroutine zpoisson_solve


  !-----------------------------------------------------------------
  subroutine dpoisson_solve(gr, pot, rho)
    type(grid_t), target, intent(inout) :: gr
    FLOAT,                intent(inout) :: pot(:)  ! pot(m%np)
    FLOAT,                intent(in)    :: rho(:)  ! rho(m%np)

    FLOAT, allocatable :: rho_corrected(:), vh_correction(:)
    FLOAT, allocatable :: rhop(:), potp(:)

    call profiling_in(C_PROFILING_POISSON_SOLVE)
    call push_sub('poisson.dpoisson_solve')

    ASSERT(poisson_solver.ne.-99)

    select case(poisson_solver)
    case(DIRECT_SUM_1D)
      call poisson1d_solve(gr%m, pot, rho)

    case(DIRECT_SUM_2D)
      call poisson2d_solve(gr%m, pot, rho)

    case(CG)
      call poisson_cg1(gr%m, gr%f_der%der_discr, pot, rho)

    case(CG_CORRECTED)
      if(hartree_integrator%increase_box) then
        ALLOCATE(potp(hartree_integrator%grid%m%np), hartree_integrator%grid%m%np)
        ALLOCATE(rhop(hartree_integrator%grid%m%np), hartree_integrator%grid%m%np)
        ALLOCATE(rho_corrected(gr%m%np), gr%m%np)
        ALLOCATE(vh_correction(gr%m%np), gr%m%np)
        potp = M_ZERO; rhop = M_ZERO; rho_corrected = M_ZERO; vh_correction = M_ZERO
        call correct_rho(gr%m, rho, rho_corrected, vh_correction)
        pot = pot - vh_correction
        call dmf_interpolate(gr%m, hartree_integrator%grid%m, full_interpolation = .false., u = rho_corrected, f = rhop)
        call dmf_interpolate(gr%m, hartree_integrator%grid%m, full_interpolation = .false., u = pot, f = potp)
        call poisson_cg2(hartree_integrator%grid%m, hartree_integrator%grid%f_der%der_discr, potp, rhop)
        call dmf_interpolate(hartree_integrator%grid%m, gr%m, full_interpolation = .false., u = potp, f = pot)
        pot = pot + vh_correction
        deallocate(rho_corrected, vh_correction)
        deallocate(potp, rhop)
      else
        ALLOCATE(rho_corrected(gr%m%np), gr%m%np)
        ALLOCATE(vh_correction(gr%m%np), gr%m%np)
        call correct_rho(gr%m, rho, rho_corrected, vh_correction)
        pot = pot - vh_correction
        call poisson_cg2(gr%m, gr%f_der%der_discr, pot, rho_corrected)
        pot = pot + vh_correction
        deallocate(rho_corrected, vh_correction)
      end if

    case(MULTIGRILLA)
      call poisson_multigrid_solver(mg, gr, pot, rho)

#ifdef HAVE_FFT
    case(FFT_SPH,FFT_CYL,FFT_PLA,FFT_NOCUT)
      call poisson_fft(gr%m, pot, rho)

    case(FFT_CORRECTED)
      ALLOCATE(rho_corrected(gr%m%np), gr%m%np)
      ALLOCATE(vh_correction(gr%m%np), gr%m%np)

      call correct_rho(gr%m, rho, rho_corrected, vh_correction)
      call poisson_fft(gr%m, pot, rho_corrected, average_to_zero = .true.)

      pot = pot + vh_correction
      deallocate(rho_corrected, vh_correction)
#endif
    case(ISF)
      call poisson_isf_solve(gr%m, pot, rho)
      
    end select

    call pop_sub()
    call profiling_out(C_PROFILING_POISSON_SOLVE)
  end subroutine dpoisson_solve


#if defined(HAVE_FFT)
  !-----------------------------------------------------------------
  subroutine poisson_fft(m, pot, rho, average_to_zero)
    type(mesh_t), intent(in) :: m
    FLOAT, intent(out) :: pot(:) ! pot(m%np)
    FLOAT, intent(in)  :: rho(:) ! rho(m%np)
    logical, intent(in), optional :: average_to_zero

    FLOAT, allocatable :: rho_global(:), pot_global(:)

    integer :: k, j, i
    FLOAT :: average

    call push_sub('poisson.poisson_fft')

    average=M_ZERO !this avoids a non-initialized warning
    
    if(m%parallel_in_domains) then
      ALLOCATE(rho_global(m%np_global), m%np_global)
      ALLOCATE(pot_global(m%np_global), m%np_global)
    end if

    call dcf_alloc_RS(fft_cf)          ! allocate the cube in real space
    call dcf_alloc_FS(fft_cf)          ! allocate the cube in Fourier space

    if(m%parallel_in_domains) then
#if defined HAVE_MPI
      call dvec_gather(m%vp, rho_global, rho)
      call dmf2cf(m, rho_global, fft_cf)        ! put the density in a cube
#endif
    else
      call dmf2cf(m, rho, fft_cf)        ! put the density in a cube
    end if
    call dcf_RS2FS(fft_cf)             ! Fourier transform


    ! multiply by the FS of the Coulomb interaction
    do k = 1, fft_cf%n(3)
      do j = 1, fft_cf%n(2)
        do i = 1, fft_cf%nx
          fft_cf%FS(i, j, k) = fft_cf%FS(i, j, k)*fft_Coulb_FS(i, j, k)
        end do
      end do
    end do

    call dcf_FS2RS(fft_cf)             ! Fourier transform back
    if(present(average_to_zero)) then
      if(average_to_zero) average = cf_surface_average(fft_cf)
#if defined HAVE_MPI
      ! Only root has the right average.
      if(m%parallel_in_domains) call MPI_Bcast(average, 1, MPI_FLOAT, 0, m%mpi_grp%comm, k)
#endif
    end if

    if(m%parallel_in_domains) then
#if defined(HAVE_MPI)
      call dcf2mf(m, fft_cf, pot_global)        ! put the density in a cube
      call dvec_scatter(m%vp, pot_global, pot)
#endif
    else
      call dcf2mf(m, fft_cf, pot)        ! put the density in a cube
    end if

    if(present(average_to_zero)) then
      if(average_to_zero) pot = pot - average
    end if

    call dcf_free_RS(fft_cf)           ! memory is no longer needed
    call dcf_free_FS(fft_cf)

    if(m%parallel_in_domains) then
      deallocate(rho_global, pot_global)
    end if

    call pop_sub()
  end subroutine poisson_fft
#endif

  !-----------------------------------------------------------------
  ! This routine checks the Hartree solver selected in the input
  ! file by calculating numerically and analytically the Hartree
  ! potential originated by a Gaussian distribution of charge.
  ! This only makes sense for finite systems.
  subroutine poisson_test(gr)
    type(grid_t), intent(inout) :: gr

    FLOAT, allocatable :: rho(:), vh(:), vh_exact(:), rhop(:), x(:, :)
    FLOAT :: alpha, beta, r, delta, norm, rnd
    integer :: i, k, ierr, iunit, n, n_gaussians

    call push_sub('poisson.poisson_test')

    if(calc_dim.eq.1) then
      write(message(1),'(a)') 'The Hartree integrator test is not implemented for the one dimensional case.'
      call write_warning(1)
      call pop_sub()
      return
    endif

    n_gaussians = 5

    ALLOCATE(     rho(NP), NP)
    ALLOCATE(    rhop(NP), NP)
    ALLOCATE(      vh(NP), NP)
    ALLOCATE(vh_exact(NP), NP)
    ALLOCATE(x(gr%m%sb%dim, n_gaussians), gr%m%sb%dim*n_gaussians)

    rho = M_ZERO; vh = M_ZERO; vh_exact = M_ZERO

    alpha = CNST(4.0) * gr%m%h(1)
    beta = M_ONE / ( alpha**calc_dim * sqrt(M_PI)**calc_dim )

    write(0, *) 'Building the Gaussian distribution of charge...'
    rho = M_ZERO
    do n = 1, n_gaussians
      norm = M_ZERO
      do while(abs(norm-M_ONE)> CNST(1.0e-6))
        do k = 1, gr%m%sb%dim
          call random_number(rnd)
          x(k, n) = -gr%m%sb%lsize(k) + rnd*M_TWO*gr%m%sb%lsize(k)
        end do
        r = sqrt(sum(x(:, n)*x(:,n)))
        do i = 1, NP
          call mesh_r(gr%m, i, r, a = x(:, n))
          rhop(i) = beta*exp(-(r/alpha)**2)
        end do
        norm = dmf_integrate(gr%m, rhop)
      end do
      rho = rho + rhop
    end do
    write(message(1), '(a,f14.6)') 'Total charge of the Gaussian distribution', dmf_integrate(gr%m, rho)
    call write_info(1)

    ! This builds analytically its potential
    vh_exact = M_ZERO
    do n = 1, n_gaussians
      do i = 1, NP
        call mesh_r(gr%m, i, r, a = x(:, n))
        select case(calc_dim)
        case(3)
          if(r > r_small) then
            vh_exact(i) = vh_exact(i) + loct_erf(r/alpha)/r
          else
            vh_exact(i) = vh_exact(i) + (M_TWO/sqrt(M_PI))/alpha
          end if
        case(2)
          vh_exact(i) = vh_exact(i) + beta * (M_PI)**(M_THREE*M_HALF) * alpha * exp(-r**2/(M_TWO*alpha**2)) * &
            loct_bessel_in(0, r**2/(M_TWO*alpha**2))
        end select
      end do
    end do

    ! This calculates the numerical potential
    call dpoisson_solve(gr, vh, rho)

    ! And this compares.
    delta = dmf_nrm2(gr%m, vh-vh_exact)

    ! Output
    iunit = io_open("hartree_results", action='write')
    write(iunit, '(a,f10.2)' ) 'Hartree test = ', delta
    call io_close(iunit)
    call doutput_function (output_fill_how('AxisX'), ".", "poisson_test_rho.x", gr%m, gr%sb, rho, M_ONE, ierr)
    call doutput_function (output_fill_how('AxisX'), ".", "poisson_test_exact.x", gr%m, gr%sb, vh_exact, M_ONE, ierr)
    call doutput_function (output_fill_how('AxisX'), ".", "poisson_test_numerical.x", gr%m, gr%sb, vh, M_ONE, ierr)
    call doutput_function (output_fill_how('AxisY'), ".", "poisson_test_rho.y", gr%m, gr%sb, rho, M_ONE, ierr)
    call doutput_function (output_fill_how('AxisY'), ".", "poisson_test_exact.y", gr%m, gr%sb, vh_exact, M_ONE, ierr)
    call doutput_function (output_fill_how('AxisY'), ".", "poisson_test_numerical.y", gr%m, gr%sb, vh, M_ONE, ierr)

    deallocate(rho, rhop, vh, vh_exact, x)
    call pop_sub()
  end subroutine poisson_test


#include "poisson1D.F90"
#include "poisson2D.F90"
#include "poisson3D.F90"

end module poisson_m
