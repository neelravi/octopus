!! Copyright (C) 2002-2006 M. Marques, A. Castro, A. Rubio, G. Bertsch, 
!! J. Alberdi, P. Garcia RisueÃ±o, M. Oliveira
!!
!! This program is free software; you can redistribute it and/or modify
!! it under the terms of the GNU General Public License as published by
!! the Free Software Foundation; either version 2, or (at your option)
!! any later version.
!!
!! This program is distributed in the hope that it will be useful,
!! but WITHOUT ANY WARRANTY; without even the implied warranty of
!! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!! GNU General Public License for more details.
!!
!! You should have received a copy of the GNU General Public License
!! along with this program; if not, write to the Free Software
!! Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
!! 02111-1307, USA.
!!
!! $Id$

! ---------------------------------------------------------
subroutine poisson_fmm_init(params_fmm, mesh, all_nodes_comm)
  type(poisson_fmm_t), intent(out)   :: params_fmm
  type(mesh_t),        intent(in)    :: mesh
  integer,             intent(in)    :: all_nodes_comm

#ifdef HAVE_LIBFM
  integer :: cdim
  logical, allocatable :: remains(:)
  integer, allocatable :: dend(:)
  integer :: subcomm

  PUSH_SUB(poisson_fmm_init)

  !%Variable DeltaEFMM
  !%Type float
  !%Default 0.0001 
  !%Section Hamiltonian::Poisson 
  !%Description
  !% Parameter for absolute or relative convergence of FMM.
  !% Sets energy error bound.
  !% Strong inhomogeneous systems may violate the error bound.
  !% For inhomogeneous systems we have an error-controlled sequential version available
  !% (from Ivo Kabadshow).
  !%End
  call parse_float(datasets_check('DeltaEFMM'), CNST(1e-4), params_fmm%delta_E_fmm)

  !%Variable AbsRelFMM 
  !%Type integer
  !%Default 2
  !%Section Hamiltonian::Poisson 
  !%Description
  !% Sets type of error bound.
  !% 0 = 10^-3 relative error.
  !% 1 = absolute deltaE error. The error (deltaE) is a fraction of the unity of energy
  !% 2 = relative deltaE error. The error is the given ratio (deltaE) of the total energy
  !% > - Could you explain me what is the difference between considering relative
  !% > or absolute error in the calculations, and why you choose your default as
  !%  > deltaE=E-3, absrel=relative?
  !% The default is just standard error, which fits most situations. It
  !% means, your energy has three significant digits. Lets say the energy of
  !% your system is 1000.0, then the FMM will compute results with a
  !% precision of +-1.
  !% So the result will be
  !% energy=999 ... 1001.
  !% If you change deltaE to 10^-6 it would be something in between
  !% energy=999.999 ... 1000.001
  !% If you do know the magnitude of your energy and set absrel to an
  !% absolute error the situation is different. Setting deltaE to 10^-2 means
  !% you will an energy=999.99..1000.01 which corresponds to 10^5 as
  !% relative error.
  !% Which one you choose is up to you. Since you want to calculate periodic
  !% systems, you may experience very precise results even if you set deltaE
  !% very low. It is a side effect from the periodicity (totalcharge=0), but
  !% should not bother you at all. You get this kind of extra precision for free.
  !%End
  call parse_integer(datasets_check('AbsRelFMM'), 2, params_fmm%abs_rel_fmm)

  !%Variable DipoleCorrection 
  !%Type integer
  !%Default 0
  !%Section Hamiltonian::Poisson 
  !%Description
  !% Extrinsic/Intrinsic potential.
  !% If you want to compare to classical Ewald use 0 or 1.
  !%Option 0
  !% FMM decides whether correction should be applied.
  !%Option 1
  !% Apply dipole correction.
  !%Option -1
  !% Disables dipole correction.
  !%End
  call parse_integer(datasets_check('DipoleCorrection'), 0, params_fmm%dipole_correction)

  ! FMM: Variable periodic sets periodicity
  ! 0 = open system
  ! 1 = 1D periodic system
  ! 2 = 2D periodic system
  ! 3 = 3D periodic system
  
  call mpi_grp_init(params_fmm%all_nodes_grp, all_nodes_comm)

  if (mpi_world%size == 1) then
    cdim = 1

    SAFE_ALLOCATE(params_fmm%disps(1))
    SAFE_ALLOCATE(dend(1))
    SAFE_ALLOCATE(params_fmm%dsize(1))
    
    dend = mesh%np
    params_fmm%sp = 1 
    params_fmm%ep = mesh%np
    params_fmm%dsize(1) = mesh%np
    params_fmm%disps = 0
    params_fmm%nlocalcharges = params_fmm%dsize(1)
    
  else 
    call MPI_Cartdim_get(params_fmm%all_nodes_grp%comm, cdim, mpi_err)
 
    SAFE_ALLOCATE(remains(1:cdim))
    
    remains = .true.
    remains(1) = .false.
    
    call MPI_Cart_sub(params_fmm%all_nodes_grp%comm, remains(1), subcomm, mpi_err)
    
    call mpi_grp_init(params_fmm%perp_grp, subcomm)

    SAFE_ALLOCATE(params_fmm%disps(1:params_fmm%perp_grp%size))
    SAFE_ALLOCATE(dend(1:params_fmm%perp_grp%size))
    SAFE_ALLOCATE(params_fmm%dsize(1:params_fmm%perp_grp%size))
    
    call multicomm_divide_range(mesh%np, params_fmm%perp_grp%size, params_fmm%disps, dend, params_fmm%dsize)
    
    params_fmm%sp = params_fmm%disps(params_fmm%perp_grp%rank + 1)
    params_fmm%ep = dend(params_fmm%perp_grp%rank + 1)
    params_fmm%nlocalcharges = params_fmm%dsize(params_fmm%perp_grp%rank + 1)
    
    params_fmm%disps = params_fmm%disps - 1
  end if
  call fmm_init()

  POP_SUB(poisson_fmm_init)
#endif
end subroutine poisson_fmm_init

! ---------------------------------------------------------
subroutine poisson_fmm_end(params_fmm)
  type(poisson_fmm_t), intent(inout) :: params_fmm

#ifdef HAVE_LIBFM
  PUSH_SUB(poisson_fmm_end)

  if (mpi_world%size > 1) call MPI_Comm_free(params_fmm%perp_grp%comm, mpi_err)
  SAFE_DEALLOCATE_P(params_fmm%disps)
  SAFE_DEALLOCATE_P(params_fmm%dsize)
  call fmm_finalize()

  POP_SUB(poisson_fmm_end)
#endif
end subroutine poisson_fmm_end

! ---------------------------------------------------------
!> Both direct solvers and FMM calculate the Hartree potential via 
!! direct additions, without solving the Poisson equation itself.
!! Direct solvers in any dimension does not require any initialization.
!! However, fmm requires initialization because, in contrast to Octopus`
!! direct solvers, FMM reads some parameters from the inp file.
subroutine poisson_fmm_solve(this, pot, rho)  
  type(poisson_t),     intent(inout) :: this
  FLOAT,               intent(inout) :: pot(:)
  FLOAT,               intent(inout) :: rho(:)

#ifdef HAVE_LIBFM
  integer(8) :: totalcharges
  integer(8) :: periodic
  integer(8) :: periodicaxes  !< is always 1
  integer(8) :: dipolecorrection
  integer(8) :: absrel

  real(8), allocatable :: q(:)  
  real(8), allocatable :: potLibFMM(:)
  real(8), allocatable :: xyz(:, :)
  real(8) :: deltaE 
  real(8) :: energyfmm   !< We don`t use it, but we cannot remove energyfmm by the moment
  real(8) :: periodlength
  real(8) :: st, en
  real(8) :: aux
  integer :: ii, jj, ierr, local_j
  integer :: sp, ep

  integer  :: ip, idir, limit, gip
  integer, allocatable :: ix(:)
  FLOAT :: aux1
  FLOAT :: rho_half_neigh(1:6)
  type(mesh_t), pointer :: mesh

  PUSH_SUB(poisson_fmm_solve)

  mesh => this%der%mesh
  sp = this%params_fmm%sp
  ep = this%params_fmm%ep

  this%params_fmm%periodic = mesh%sb%periodic_dim

  if(this%params_fmm%periodic /= 0) then
    if ((mesh%sb%box_shape == PARALLELEPIPED).and.((mesh%sb%lsize(1)==mesh%sb%lsize(2)).and.&
         (mesh%sb%lsize(1)==mesh%sb%lsize(3)).and.&
         (mesh%sb%lsize(2)==mesh%sb%lsize(3)))) then
      this%params_fmm%periodic_length = mesh%sb%lsize(1)
    else
      message(1) = "At present, FMM solver for Hartree potential can only deal with cubic boxes. "
      message(2) = " Please, change your Poisson solver or the size or dimensions of your box. "
      call messages_fatal(2)
    endif
  endif

  call profiling_in(poisson_prof, "POISSON_FMM")


  ! allocate buffers.
  SAFE_ALLOCATE(q(sp:ep))
  SAFE_ALLOCATE(xyz(1:3, sp:ep))
  SAFE_ALLOCATE(potLibFMM(sp:ep)) 

  totalcharges = mesh%np_global 

  if (.not. mesh%use_curvilinear) then
    do ii = sp, ep
      q(ii) = rho(ii)*mesh%vol_pp(1)
    end do
  else
    do ii = sp, ep
      q(ii) = rho(ii)*mesh%vol_pp(ii)
    end do
  end if

  ! invert the indices
  do ii = sp, ep
    do jj = 1, MAX_DIM
      xyz(jj, ii) = mesh%x(ii, jj)
    end do
  end do

  absrel = this%params_fmm%abs_rel_fmm
  deltaE = this%params_fmm%delta_E_fmm
  potLibFMM = M_ZERO 
  this%params_fmm%periodic=mesh%sb%periodic_dim
  this%params_fmm%periodic_length= CNST(2.0)*mesh%sb%lsize(1)
  periodic = this%params_fmm%periodic
  periodicaxes = 1 
  periodlength = this%params_fmm%periodic_length
  dipolecorrection = this%params_fmm%dipole_correction

  call fmm(totalcharges, this%params_fmm%nlocalcharges, q(sp), xyz(1, sp), absrel, deltaE, energyfmm, &
    potLibFMM(sp), periodic, periodicaxes, periodlength, dipolecorrection)
    
  if (mpi_world%size > 1) then
    !now we need to allgather the results between "states"
    call MPI_Allgatherv(potlibFMM(sp), this%params_fmm%nlocalcharges, MPI_FLOAT, &
         pot(1), this%params_fmm%dsize(1), this%params_fmm%disps(1), MPI_FLOAT, &
         this%params_fmm%perp_grp%comm, mpi_err)
  else
    pot = potlibFMM
  end if

  ! FMM just calculates contributions from other cells. for self-interaction cell integration, we include 
  ! (as traditional in octopus) an approximate integration using a spherical cell whose volume is the volume of the actual cell
  ! Next line is only valid for 3D
  if (mesh%sb%dim==3) then
    if (.not. mesh%use_curvilinear .and. (mesh%spacing(1)==mesh%spacing(2)) .and. &
         (mesh%spacing(2)==mesh%spacing(3)) .and. &
         (mesh%spacing(1)==mesh%spacing(3))) then
      aux = CNST(2.417987931)*(mesh%spacing(1)*mesh%spacing(2)) 
      do ii = 1, mesh%np
        pot(ii)=pot(ii)+aux*rho(ii)
      end do
    else
      do ii = 1, mesh%np 
        aux = M_TWO*M_PI*(3.*mesh%vol_pp(ii)/(M_PI*4.))**(2./3.)
        pot(ii)=pot(ii)+aux*rho(ii)
      end do
    end if
  end if

  if (mesh%sb%dim==2) then
    aux = M_TWO*M_PI*mesh%spacing(1)
    do ii = 1, mesh%np
      pot(ii)=pot(ii)+aux*rho(ii)
    end do
  end if

  SAFE_DEALLOCATE_A(q)
  SAFE_DEALLOCATE_A(xyz)
  SAFE_DEALLOCATE_A(potLibFMM)

  ! Apply the parallel correction
  SAFE_ALLOCATE(ix(1:mesh%sb%dim))
  
  if (mesh%parallel_in_domains) then
#ifdef HAVE_MPI
    call dvec_ghost_update(mesh%vp, rho)
#endif
  end if

  ! Corrections for first neighbours obtained with linear interpolation      
  ! First we obtain the densities in neighbouring points ip+1/2
  rho_half_neigh=M_ZERO
  ! Iterate over all local points of rho (1 to mesh%np)
  do ip =1,mesh%np
    if (mesh%parallel_in_domains) then
#ifdef HAVE_MPI
      ! Get the global point from the local point
      gip = mesh%vp%local(mesh%vp%xlocal(mesh%vp%partno) + ip - 1)
#endif
    else
      gip = ip
    end if
    
    ! Get x,y,z indexes of the global point
    call index_to_coords(mesh%idx, mesh%sb%dim, gip, ix)

    ! Correction for the 1st neighbour
    local_j = vec_index2local(mesh, ix, 1, -1)
    rho_half_neigh(1)=(9.0/16.0)*(rho(local_j)+rho(ip))

    local_j = vec_index2local(mesh, ix, 1, -2)
    rho_half_neigh(1)=rho_half_neigh(1)-(1.0/16.0)*rho(local_j)

    local_j = vec_index2local(mesh, ix, 1, 1)
    rho_half_neigh(1)=rho_half_neigh(1)+(1.0/16.0)*rho(local_j)

    ! Correction for the 2nd neighbour
    local_j = vec_index2local(mesh, ix, 1, 1)
    rho_half_neigh(2)=(9.0/16.0)*(rho(local_j)+rho(ip))

    local_j = vec_index2local(mesh, ix, 1, -1)
    rho_half_neigh(2)=rho_half_neigh(2)-(1.0/16.0)*rho(local_j)

    local_j = vec_index2local(mesh, ix, 1, 2)
    rho_half_neigh(2)=rho_half_neigh(2)+(1.0/16.0)*rho(local_j)

    ! Correction for the 3rd neighbour
    local_j = vec_index2local(mesh, ix, 2, -1)
    rho_half_neigh(3)=(9.0/16.0)*(rho(local_j)+rho(ip))

    local_j = vec_index2local(mesh, ix, 2, -2)
    rho_half_neigh(3)=rho_half_neigh(3)-(1.0/16.0)*rho(local_j)

    local_j = vec_index2local(mesh, ix, 2, 1)
    rho_half_neigh(3)=rho_half_neigh(3)+(1.0/16.0)*rho(local_j)

    ! Correction for the 4th neighbour
    local_j = vec_index2local(mesh, ix, 2, 1)
    rho_half_neigh(4)=(9.0/16.0)*(rho(local_j)+rho(ip))

    local_j = vec_index2local(mesh, ix, 2, -1)
    rho_half_neigh(4)=rho_half_neigh(4)-(1.0/16.0)*rho(local_j)

    local_j = vec_index2local(mesh, ix, 2, 2)
    rho_half_neigh(4)=rho_half_neigh(4)+(1.0/16.0)*rho(local_j)

    ! Correction for the 5th neighbour
    local_j = vec_index2local(mesh, ix, 3, -1)
    rho_half_neigh(5)=(9.0/16.0)*(rho(local_j)+rho(ip))

    local_j = vec_index2local(mesh, ix, 3, -2)
    rho_half_neigh(5)=rho_half_neigh(5)-(1.0/16.0)*rho(local_j)

    local_j = vec_index2local(mesh, ix, 3, 1)
    rho_half_neigh(5)=rho_half_neigh(5)+(1.0/16.0)*rho(local_j)

    ! Correction for the 6th neighbour
    local_j = vec_index2local(mesh, ix, 3, 1)
    rho_half_neigh(6)=(9.0/16.0)*(rho(local_j)+rho(ip))

    local_j = vec_index2local(mesh, ix, 3, -1)
    rho_half_neigh(6)=rho_half_neigh(6)-(1.0/16.0)*rho(local_j)

    local_j = vec_index2local(mesh, ix, 3, 2)
    rho_half_neigh(6)=rho_half_neigh(6)+(1.0/16.0)*rho(local_j)

    aux1=M_ZERO  

    local_j = vec_index2local(mesh, ix, 1, -1)
    aux1=aux1+(mesh%spacing(2)*mesh%spacing(3))*&
         (rho_half_neigh(1)/M_FOUR - rho(local_j)/16.0000) 

    local_j = vec_index2local(mesh, ix, 1, 1)
    aux1=aux1+(mesh%spacing(2)*mesh%spacing(3))*&
         (rho_half_neigh(2)/M_FOUR - rho(local_j)/16.0000)

    local_j = vec_index2local(mesh, ix, 2, -1)
    aux1=aux1+(mesh%spacing(1)*mesh%spacing(3))*&
         (rho_half_neigh(3)/M_FOUR - rho(local_j)/16.0000)

    local_j = vec_index2local(mesh, ix, 2, 1)
    aux1=aux1+(mesh%spacing(1)*mesh%spacing(3))*&
         (rho_half_neigh(4)/M_FOUR - rho(local_j)/16.0000)

    local_j = vec_index2local(mesh, ix, 3, -1)
    aux1=aux1+(mesh%spacing(1)*mesh%spacing(2))*&
         (rho_half_neigh(5)/M_FOUR - rho(local_j)/16.0000)

    local_j = vec_index2local(mesh, ix, 3, 1)
    aux1=aux1+(mesh%spacing(1)*mesh%spacing(2))*&
         (rho_half_neigh(6)/M_FOUR - rho(local_j)/16.0000)

    aux1=aux1-(M_SIX/22.862)*((mesh%spacing(1)*mesh%spacing(2)*mesh%spacing(3))**(2./3.))*&
         rho(ip)*M_TWO*M_PI*(3./(M_PI*4.))**(2./3.)

    ! Apply the correction to the potential
    pot(ip)=pot(ip)+aux1
    
  end do
  SAFE_DEALLOCATE_A(ix)

  call profiling_out(poisson_prof)

  POP_SUB(poisson_fmm_solve)
#endif
end subroutine poisson_fmm_solve

!> Change the value of one dimension (1=x, 2=y, 3=z) 
!! according to the given value and return the local point
integer function vec_index2local(mesh, ix, dim_pad, pad)
   type(mesh_t), intent(in) :: mesh    !< All the requiered information
   integer,      intent(in) :: ix(1:3) !< Global x,y,z indexes
   integer,      intent(in) :: dim_pad !< The dimension that has to be change
   integer,      intent(in) :: pad     !< 
   
   integer :: global_point, local_point
   integer :: jx(1:3)
   
   jx = ix
   jx(dim_pad) = jx(dim_pad) + pad
   global_point = index_from_coords(mesh%idx, 3, jx)
   if (mesh%parallel_in_domains) then
#ifdef HAVE_MPI
     local_point = vec_global2local(mesh%vp, global_point, mesh%vp%partno)
     if (local_point == 0) then
       write(message(1), '(a)') "You are trying to access to a neighbour that does not exists"
       write(message(2), '(a, i5)') "Global point = ",global_point
       write(message(3), '(a, 3i5)') "x,y,z point  = ",jx
       call messages_warning(3)
     end if
#endif
   else
     local_point = global_point
   end if

   vec_index2local = local_point

 end function vec_index2local
!! Local Variables:
!! mode: f90
!! coding: utf-8
!! End:
