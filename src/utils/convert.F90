!! Copyright (C) 2013 J. Alberdi-Rodriguez
!!
!! This program is free software; you can redistribute it and/or modify
!! it under the terms of the GNU General Public License as published by
!! the Free Software Foundation; either version 2, or (at your option)
!! any later version.
!!
!! This program is distributed in the hope that it will be useful,
!! but WITHOUT ANY WARRANTY; without even the implied warranty of
!! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!! GNU General Public License for more details.
!!
!! You should have received a copy of the GNU General Public License
!! along with this program; if not, write to the Free Software
!! Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
!! 02110-1301, USA.
!!
!! $Id$

#include "global.h"

program oct_convert
  use calc_mode_m
  use command_line_m
  use datasets_m
  use fft_m
  use geometry_m
  use global_m
  use io_m
  use io_function_m
  use io_binary_m
  use loct_m
  use messages_m
  use mesh_m
  use output_m
  use parser_m
  use poisson_m
  use profiling_m
  use system_m
  use restart_m
  use unit_m
  use unit_system_m
  use utils_m

  implicit none

  character*256 :: config_str
  integer :: ierr
  
  call getopt_init(ierr)
  config_str = trim(get_config_opts()) // trim(get_optional_libraries())
  if(ierr  ==  0) call getopt_octopus(config_str)
  call getopt_end()

  call global_init()
  call calc_mode_init()
  call messages_init()

  call datasets_init(1)
  call io_init()
  call profiling_init()
  call messages_experimental("oct-convert utility")

  call print_header()

  call messages_print_stress(stdout, "Convert mode")
  call messages_print_stress(stdout)

  call fft_all_init()
  call unit_system_init()

  call convert()

  call fft_all_end()
  call profiling_output()
  call profiling_end()
  call io_end()
  call print_date("Calculation ended on ")
  call datasets_end()
  call messages_end()
  call global_end()

contains

  ! -------------
  !> Reads an binary file and writes the equivalent files, 
  !! defined with OutputHow.
  !! This is a high-level interface that reads the input file and
  !! calls the proper function.
  subroutine convert()
    type(system_t) :: sys

    character(64)  :: basename, folder, ref_name, ref_folder, folder_default
    integer        :: c_start, c_end, c_step, c_start_default, length
    logical        :: iterate_folder, subtract_file

    PUSH_SUB(convert)

    call calc_mode_set_parallelization(P_STRATEGY_STATES, default = .false.)
    call system_init(sys)

    message(1) = 'Info: Converting files'
    message(2) = ''
    call messages_info(2)

    !%Variable ConvertFilename
    !%Type string
    !%Default density
    !%Section Utilities::oct-convert
    !%Description
    !% Input filename. The original filename which is going to be converted in the format
    !% specified in <tt>OutputHow</tt>. It is going to convert various files, it should 
    !% only contain the beginning of the name. For instance, in the case of the restart 
    !% files it should be one space ' '.
    !%End
    call parse_string(datasets_check('ConvertFilename'), 'density', basename)
    if ( basename == " " ) basename = ""
    ! Delete the extension if present
    length = len_trim(basename)
    if ( length > 4) then
      if ( basename(length-3:length) == '.obf' ) then
        basename = trim(basename(1:length-4))
      end if
    end if


    !%Variable ConvertIterateFolder
    !%Type logical
    !%Default true
    !%Section Utilities::oct-convert
    !%Description
    !% This variable decides if a folder is going to be iterated or the 
    !% filename is going to be iterated.
    !%End
    call parse_logical(datasets_check('ConvertIterateFolder'), .true., iterate_folder)

    if (iterate_folder) then
      folder_default  = 'td.'
      c_start_default = 0
    else
      folder_default  = 'restart'
      c_start_default = 1
    end if
    
    !%Variable ConvertFolder
    !%Type string
    !%Section Utilities::oct-convert
    !%Description
    !% The folder name where the input files are.
    !%End
    call parse_string(datasets_check('ConvertFolder'), folder_default, folder)
    ! Check if the folder is finished by an /
    if (index(folder, '/', .true.) /= len_trim(folder)) then
      write(folder,'(a,a1)') trim(folder), '/'
    end if

    !%Variable ConvertStart
    !%Type integer
    !%Default 0
    !%Section Utilities::oct-convert
    !%Description
    !% The starting number of the filename.
    !%End
    call parse_integer(datasets_check('ConvertStart'), c_start_default, c_start)

    !%Variable ConvertEnd
    !%Type integer
    !%Default 1
    !%Section Utilities::oct-convert
    !%Description
    !% The last number of the filename.
    !%End
    call parse_integer(datasets_check('ConvertEnd'), 1, c_end)

    !%Variable ConvertStep
    !%Type integer
    !%Default 1
    !%Section Utilities::oct-convert
    !%Description
    !% The padding between the filenames.
    !%End
    call parse_integer(datasets_check('ConvertStep'), 1, c_step)

    !%Variable ConvertRefFileName
    !%Type string
    !%Default density
    !%Section Utilities::oct-convert
    !%Description
    !% Input filename. The original filename which is going to convert in the formats 
    !% specified in <tt>OutputHow</tt>.
    !%End
    call parse_string(datasets_check('ConvertRefFileName'), 'density', ref_name)
    if ( ref_name == " " ) ref_name = ""

    !%Variable ConvertSubtractFile
    !%Type logical
    !%Default false
    !%Section Utilities::oct-convert
    !%Description
    !% The reference file that is going to be used to subtract from.
    !%End
    call parse_logical(datasets_check('ConvertSubtractFile'), .false., subtract_file)

    !%Variable ConvertSubtractFolder
    !%Type string
    !%Default [blank]
    !%Section Utilities::oct-convert
    !%Description
    !% The folder name which is going to be subtracted.
    !%End
    call parse_string(datasets_check('ConvertSubtractFolder'), ' ', ref_folder)
    if ( ref_folder == " " ) ref_folder = ""

    call convert_low(sys%gr%mesh, sys%geo, basename, folder, &
         c_start, c_end, c_step, sys%outp%how, sys%outp%what, iterate_folder, &
         subtract_file, ref_name, ref_folder )

    call system_end(sys)

    POP_SUB(convert)
  end subroutine convert

  ! ---------------------------------------------------------
  !> Giving a range of input files, it writes the corresponding 
  !! output files
  subroutine convert_low(mesh, geo, basename, in_folder, c_start, c_end, c_step, how, what, iterate_folder, & 
                                 subtract_file, ref_name, ref_folder)
    type(mesh_t)    , intent(in)    :: mesh
    type(geometry_t), intent(in)    :: geo
    character(len=*), intent(inout) :: basename       !< File name
    character(len=*), intent(in)    :: in_folder      !< Folder name
    integer,          intent(in)    :: c_start        !< The first file number
    integer,          intent(in)    :: c_end          !< The last file number
    integer,          intent(in)    :: c_step         !< The step between files
    integer,          intent(in)    :: how            !< Decides the kind of the output
    integer,          intent(in)    :: what           !< Decides what is going to be written
    logical,          intent(in)    :: iterate_folder !< If true, it iterates over the folders, keeping the filename fixed.
                                                      !! If false, it iterates over the filenames
    logical,          intent(in)    :: subtract_file  !< If true, it subtracts the density from the reference 
    character(len=*), intent(inout) :: ref_name       !< Reference file name 
    character(len=*), intent(inout) :: ref_folder     !< Reference folder name

    type(restart_t)    :: restart
    integer            :: ierr, ii
    character(64)      :: filename, out_name, folder, frmt
    FLOAT, allocatable :: read_ff(:), read_rff(:), pot(:)

    PUSH_SUB(convert_low)

    SAFE_ALLOCATE(read_ff(1:mesh%np))
    SAFE_ALLOCATE(read_rff(1:mesh%np))
    SAFE_ALLOCATE(pot(1:mesh%np))
    read_rff(:) = M_ZERO
   
    write(message(1),'(5a,i5,a,i5,a,i5)') "Converting '", trim(in_folder), "/", trim(basename), &
         "' from ", c_start, " to ", c_end, " every ", c_step
    call messages_info(1)
 
    if (subtract_file) then
      write(message(1),'(a,a,a,a)') "Reading ref-file from ", trim(ref_folder), trim(ref_name),".obf"
      call restart_init(restart, RESTART_UNDEFINED, RESTART_TYPE_LOAD, mesh%mpi_grp, &
                      ierr, dir=trim(ref_folder), mesh = mesh)
      ! FIXME: why only real functions? Please generalize.
      if(ierr == 0) then
        call drestart_read_mesh_function(restart, trim(ref_name), mesh, read_rff, ierr)
        call restart_end(restart)
      else
        message(1) = "Failed to read from ref-file."
        call messages_fatal(1)
      endif
    end if

    call loct_progress_bar(-1, c_end-c_start)
    do ii = c_start, c_end, c_step
      if (iterate_folder) then
        ! Delete the last / and add the corresponding folder number
        write(folder,'(a,i0.7,a)') in_folder(1:len_trim(in_folder)-1),ii,"/"
        write(filename, '(a,a,a)') trim(folder), trim(basename), ".obf"
        out_name = trim(basename)
      else
        folder = in_folder
        if ( c_start /= c_end ) then
          ! Here, we are only considering 10 character long filenames.
          ! Subtract the initial part given at 'ConvertFilename' from the format and pad
          ! with zeros.
          write(frmt,'(a,i0,a)')"(a,i0.",10-len_trim(basename),")"
          write(filename, fmt=trim(frmt)) trim(basename), ii
          write(out_name, '(a)') trim(filename)
          write(filename, '(a,a,a,a)') trim(folder),"/", trim(out_name),".obf"
        else 
          ! Assuming filename is given complete in the 'ConvertFilename'
          write(filename, '(a,a,a,a)') trim(folder),"/", trim(basename),".obf"
          write(out_name, '(a)') trim(basename)
        end if
      end if

      ! Read the obf file
      call restart_init(restart, RESTART_UNDEFINED, RESTART_TYPE_LOAD, mesh%mpi_grp, &
                      ierr, dir=trim(folder), mesh = mesh)
      if(ierr == 0) then
        call drestart_read_mesh_function(restart, trim(out_name), mesh, read_ff, ierr)
        call restart_end(restart)
      endif

      if (ierr /= 0) then
        write(message(1), '(a,a)') "Error reading the file ", filename
        write(message(2), '(a)') "Skipping...."
        call messages_warning(2)
        cycle
      end if
      if (subtract_file) then
        read_ff(:) = read_ff(:) - read_rff(:) 
        write(out_name, '(a,a)') trim(out_name),"-ref"
      end if
      ! Write the corresponding output
      call dio_function_output(how, &
        trim(folder), trim(out_name), mesh, read_ff, units_out%length**(-mesh%sb%dim), ierr, geo = geo)
      
      if (iand(what, C_OUTPUT_POTENTIAL) /= 0) then
        write(out_name, '(a)') "potential"
        call dpoisson_solve(psolver, pot, read_ff)
        call dio_function_output(how, &
             trim(folder), trim(out_name), mesh, pot, units_out%energy, ierr, geo = geo)
      end if
      call loct_progress_bar(ii-c_start, c_end-c_start) 
    end do
    
    SAFE_DEALLOCATE_A(read_ff)
    SAFE_DEALLOCATE_A(read_rff)
    SAFE_DEALLOCATE_A(pot)
    POP_SUB(convert_low)
  end subroutine convert_low
  
end program

!! Local Variables:
!! mode: f90
!! coding: utf-8
!! End:
