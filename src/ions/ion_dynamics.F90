!! Copyright (C) 2008 X. Andrade
!!
!! This program is free software; you can redistribute it and/or modify
!! it under the terms of the GNU General Public License as published by
!! the Free Software Foundation; either version 2, or (at your option)
!! any later version.
!!
!! This program is distributed in the hope that it will be useful,
!! but WITHOUT ANY WARRANTY; without even the implied warranty of
!! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!! GNU General Public License for more details.
!!
!! You should have received a copy of the GNU General Public License
!! along with this program; if not, write to the Free Software
!! Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
!! 02111-1307, USA.
!!
!! $Id: dynamics.F90 3813 2008-03-04 20:40:01Z xavier $

#include "global.h"

module ion_dynamics_m
  use c_pointer_m
  use datasets_m
  use global_m
  use io_m
  use loct_math_m
  use parser_m
  use math_m
  use messages_m
  use mpi_m
  use geometry_m
  use loct_m
  use simul_box_m
  use species_m
  use profiling_m
  use unit_m
  use unit_system_m
  use varinfo_m
  use xyz_file_m

  implicit none

  private

  public ::                                &
    ion_dynamics_t,                        &
    ion_state_t,                           &
    ion_dynamics_init,                     &
    ion_dynamics_end,                      &
    ion_dynamics_propagate,                &
    ion_dynamics_propagate_vel,            &
    ion_dynamics_save_state,               &
    ion_dynamics_restore_state,            &
    ion_dynamics_ions_move,                &
    ion_dynamics_temperature,              &
    ion_dynamics_kinetic_energy

  integer, parameter ::   &
    STATIC_IONS     = 0,  &
    VELOCITY_VERLET = 1,  &
    NOSE_HOOVER     = 5

  type nose_hoover_t
    private
    FLOAT :: mass
    FLOAT :: pos
    FLOAT :: vel
  end type nose_hoover_t

  type ion_dynamics_t
    private
    integer          :: method
    FLOAT            :: dt

    FLOAT, pointer   :: oldforce(:, :)

    ! the old positions for Verlet (used for the Nose-Hoover)
    FLOAT, pointer :: old_x(:, :)    

    ! variables for the Nose-Hoover thermostat
    type(nose_hoover_t) :: nh1
    type(nose_hoover_t) :: nh2
    FLOAT :: nh_t_start
    FLOAT :: nh_t_end
    FLOAT :: nh_end_time
    FLOAT :: temp
  end type ion_dynamics_t

  type ion_state_t
    private
    FLOAT, pointer :: pos(:, :)
    FLOAT, pointer :: vel(:, :)
  end type ion_state_t

contains

  subroutine ion_dynamics_init(this, geo)
    type(ion_dynamics_t), intent(out)   :: this
    type(geometry_t),     intent(inout) :: geo

    integer :: i, j, iatom
    FLOAT   :: x(MAX_DIM), temperature, sigma, kin1, kin2
    type(c_ptr) :: random_gen_pointer
    type(xyz_file_info) :: xyz

    call push_sub('ion_dynamics.ion_dynamics_init')

    !%Variable MoveIons
    !%Type integer
    !%Default static_ions
    !%Section Time-Dependent::Propagation
    !%Description
    !% This variable specifies how to treat the dynamics of the ions
    !% during a time-dependent run. By default they will remain static.
    !%Option static_ions 0
    !% Do not move the ions.
    !%Option vel_verlet 1
    !% Newtonian dynamics using the velocity Verlet integrator.
    !%Option nose_hoover 5
    !% Nos&eacute;-Hoover thermostat.
    !%End
    
    call parse_integer(datasets_check('MoveIons'), STATIC_IONS, this%method)
    if(.not.varinfo_valid_option('MoveIons', this%method)) call input_error('MoveIons')
    call messages_print_var_option(stdout, 'MoveIons', this%method)

    if(this%method == NOSE_HOOVER) call messages_devel_version('Nose-Hoover thermostat')

    nullify(this%oldforce)
    
    if(ion_dynamics_ions_move(this)) then 
      SAFE_ALLOCATE(this%oldforce(1:MAX_DIM, 1:geo%natoms))
    end if

    !now initialize velocities

    !%Variable RandomVelocityTemp
    !%Type float
    !%Section System::Velocities
    !%Description
    !% If this variable is present, <tt>Octopus</tt> will assign random
    !% velocities to the atoms following a Boltzmann distribution with
    !% temperature given by <tt>RandomVelocityTemp</tt> (in degrees Kelvin).
    !%End

    ! we now load the velocities, either from the temperature, from the input, or from a file
    if(parse_isdef(datasets_check('RandomVelocityTemp')).ne.0) then

      if( mpi_grp_is_root(mpi_world)) then
        call loct_ran_init(random_gen_pointer)
        call parse_float(datasets_check('RandomVelocityTemp'), M_ZERO, temperature)
      end if

      do i = 1, geo%natoms
        !generate the velocities in the root node
        if( mpi_grp_is_root(mpi_world)) then
          sigma = sqrt( P_Kb*temperature / species_weight(geo%atom(i)%spec) )
          do j = 1, 3
             geo%atom(i)%v(j) = loct_ran_gaussian(random_gen_pointer, sigma)
          end do
        end if
#ifdef HAVE_MPI
        !and send them to the others
        call MPI_Bcast(geo%atom(i)%v, MAX_DIM, MPI_FLOAT, 0, mpi_world%comm, mpi_err)
#endif
      end do

      if( mpi_grp_is_root(mpi_world)) then
        call loct_ran_end(random_gen_pointer)
      end if

      kin1 = ion_dynamics_kinetic_energy(geo)

      call cm_vel(geo, x)
      do i = 1, geo%natoms
        geo%atom(i)%v = geo%atom(i)%v - x
      end do

      kin2 = ion_dynamics_kinetic_energy(geo)

      do i = 1, geo%natoms
        geo%atom(i)%v(:) =  sqrt(kin1/kin2)*geo%atom(i)%v(:)
      end do

      write(message(1),'(a,f10.4,1x,a)') 'Info: Initial velocities randomly distributed with T =', &
        temperature, 'K'
      write(message(2),'(2x,a,f8.4,1x,a)') '<K>       =', &
        units_from_atomic(units_out%energy, ion_dynamics_kinetic_energy(geo)/geo%natoms), &
        units_abbrev(units_out%energy)
      write(message(3),'(2x,a,f8.4,1x,a)') '3/2 k_B T =', &
        units_from_atomic(units_out%energy, (M_THREE/M_TWO)*P_Kb*temperature), &
        units_abbrev(units_out%energy)
      call write_info(3)

    else
      !%Variable XYZVelocities
      !%Type string
      !%Section System::Velocities
      !%Description
      !% <tt>Octopus</tt> will try to read the starting velocities of the atoms from the XYZ file 
      !% specified by the variable <tt>XYZVelocities</tt>.
      !% Note that you do not need to specify initial velocities if you are not going
      !% to perform ion dynamics; if you are going to allow the ions to move but the velocities
      !% are not specified, they are considered to be null.
      !%End

      !%Variable Velocities
      !%Type block
      !%Section System::Velocities
      !%Description
      !% If <tt>XYZVelocities</tt> is not present, octopus will try to fetch the initial 
      !% atomic velocities from this block. If this block is not present, octopus
      !% will reset the initial velocities to zero. The format of this block can be
      !% illustrated by this example:
      !%
      !% <tt>%Velocities
      !% <br>&nbsp;&nbsp;'C'  |      -1.7 | 0.0 | 0.0
      !% <br>&nbsp;&nbsp;'O'  | &nbsp;1.7 | 0.0 | 0.0
      !% <br>%</tt>
      !%
      !% It describes one carbon and one oxygen moving at the relative
      !% velocity of 3.4 velocity units.
      !%
      !% Note: It is important for the velocities to maintain the ordering 
      !% in which the species were defined in the coordinates specifications.
      !%End

      call xyz_file_init(xyz)
      call xyz_file_read('Velocities', xyz)
      if(xyz%file_type.ne.XYZ_FILE_ERR) then
        if(geo%natoms.ne.xyz%n) then
          write(message(1), '(a,i4,a,i4)') 'I need exactly ', geo%natoms, ' velocities, but I found ', xyz%n
          call write_fatal(1)
        end if

        ! copy information and adjust units
        do i = 1, geo%natoms
          geo%atom(i)%v = units_to_atomic(units_inp%velocity/units_inp%length, xyz%atom(i)%x)
        end do

        call xyz_file_end(xyz)

      else
        do i = 1, geo%natoms
          geo%atom(i)%v = M_ZERO
        end do
      end if
    end if

    geo%kinetic_energy = ion_dynamics_kinetic_energy(geo)

    if(this%method == NOSE_HOOVER) then
      call parse_float(datasets_check("NHTStart"), CNST(0.0), this%nh_t_start)
      this%nh_t_start = P_Kb*this%nh_t_start
      
      call parse_float(datasets_check("NHTEnd"), CNST(300.0), this%nh_t_end)
      this%nh_t_end = P_Kb*this%nh_t_end

      call parse_float(datasets_check("NHEndTime"), CNST(200.0), this%nh_end_time)
      
      call parse_float(datasets_check("NHMass"), CNST(300.0), this%nh1%mass)
      this%nh2%mass = this%nh1%mass

      this%nh1%pos = M_ZERO
      this%nh2%pos = M_ZERO
      this%nh1%vel = M_ZERO
      this%nh2%vel = M_ZERO

      SAFE_ALLOCATE(this%old_x(1:MAX_DIM, 1:geo%natoms))

      do iatom = 1, geo%natoms
        this%old_x(1:MAX_DIM, iatom) = geo%atom(iatom)%x(1:MAX_DIM)
      end do

    end if

    call pop_sub()
  end subroutine ion_dynamics_init

  subroutine ion_dynamics_end(this)
    type(ion_dynamics_t), intent(inout) :: this

    call push_sub('ion_dynamics.ion_dynamics_end')
    SAFE_DEALLOCATE_P(this%oldforce)

    call pop_sub()
  end subroutine ion_dynamics_end

  subroutine ion_dynamics_propagate(this, sb, geo, time, dt)
    type(ion_dynamics_t), intent(inout) :: this
    type(simul_box_t),    intent(in)    :: sb
    type(geometry_t),     intent(inout) :: geo
    FLOAT,                intent(in)    :: time
    FLOAT,                intent(in)    :: dt
    
    integer :: iatom

    if(.not. ion_dynamics_ions_move(this)) return

    call push_sub('ion_dynamics.ion_dynamics_propagate')

    this%dt = dt

    select case(this%method)
    case(VELOCITY_VERLET)
      
      do iatom = 1, geo%natoms
        if(.not. geo%atom(iatom)%move) cycle
        
        geo%atom(iatom)%x(1:MAX_DIM) = geo%atom(iatom)%x(1:MAX_DIM) &
             + dt*geo%atom(iatom)%v(1:MAX_DIM) + &
             M_HALF*dt**2 / species_weight(geo%atom(iatom)%spec) * geo%atom(iatom)%f(1:MAX_DIM)
        
        this%oldforce(1:MAX_DIM, iatom) = geo%atom(iatom)%f(1:MAX_DIM)
        
      end do
      
      call simul_box_atoms_in_box(sb, geo)

    case(NOSE_HOOVER)

      ! The implementation of the Nose-Hoover thermostat is based on
      ! Understanding Molecular Simulations by Frenkel and Smit,
      ! Appendix E, page 540-542.

      if (time < this%nh_end_time) then
        this%temp = this%nh_t_start + (this%nh_t_end - this%nh_t_start)*time/this%nh_end_time
      else
        this%temp = this%nh_t_end
      end if

      call chain(this, geo)

      do iatom = 1, geo%natoms
        geo%atom(iatom)%x(1:MAX_DIM) = geo%atom(iatom)%x(1:MAX_DIM) + M_HALF*dt*geo%atom(iatom)%v(1:MAX_DIM)
      enddo

    end select
    
    call pop_sub()
  end subroutine ion_dynamics_propagate
  
  subroutine chain(this, geo)
    type(ion_dynamics_t), intent(inout) :: this
    type(geometry_t),     intent(inout) :: geo

    FLOAT :: g1, g2, ss, uk, dt
    integer :: iatom

    call push_sub('ion_dynamics.chain')

    dt = this%dt

    uk = ion_dynamics_kinetic_energy(geo)

    g2 = (this%nh1%mass*this%nh1%vel**2 - this%temp)/this%nh2%mass
    this%nh2%vel = this%nh2%vel + g2*dt/CNST(4.0)
    this%nh1%vel = this%nh1%vel*exp(-this%nh2%vel*dt/CNST(8.0))

    g1 = (CNST(2.0)*uk - M_THREE*geo%natoms*this%temp)/this%nh1%mass
    this%nh1%vel = this%nh1%vel + g1*dt/CNST(4.0)
    this%nh1%vel = this%nh1%vel*exp(-this%nh2%vel*dt/CNST(8.0))
    this%nh1%pos = this%nh1%pos + this%nh1%vel*dt/CNST(2.0)
    this%nh2%pos = this%nh2%pos + this%nh2%vel*dt/CNST(2.0)

    ss = exp(-this%nh1%vel*dt/CNST(2.0))
    
    do iatom = 1, geo%natoms
      geo%atom(iatom)%v(1:MAX_DIM) = ss*geo%atom(iatom)%v(1:MAX_DIM)
    enddo
    
    uk = uk*ss**2

    this%nh1%vel = this%nh1%vel*exp(-this%nh2%vel*dt/CNST(8.0))
    g1 = (CNST(2.0)*uk - M_THREE*geo%natoms*this%temp)/this%nh1%mass
    this%nh1%vel = this%nh1%vel + g1*dt/CNST(4.0)
    this%nh1%vel = this%nh1%vel*exp(-this%nh2%vel*dt/CNST(8.0))

    g2 = (this%nh1%mass*this%nh1%vel**2 - this%temp)/this%nh2%mass
    this%nh2%vel = this%nh2%vel + g2*dt/CNST(4.0)
    
    call pop_sub()
  end subroutine chain
  
  subroutine ion_dynamics_propagate_vel(this, geo)
    type(ion_dynamics_t), intent(inout) :: this
    type(geometry_t),     intent(inout) :: geo

    integer :: iatom

    if(.not. ion_dynamics_ions_move(this)) return

    call push_sub('ion_dynamics.ion_dynamics_propagate_vel')

    select case(this%method)
    case(VELOCITY_VERLET)
      
      do iatom = 1, geo%natoms
        if(.not. geo%atom(iatom)%move) cycle
        
        geo%atom(iatom)%v(1:MAX_DIM) = geo%atom(iatom)%v(1:MAX_DIM) &
             + this%dt/species_weight(geo%atom(iatom)%spec) * M_HALF * (this%oldforce(1:MAX_DIM, iatom) + &
             geo%atom(iatom)%f(1:MAX_DIM))
        
      end do
      
    case(NOSE_HOOVER)
      do iatom = 1, geo%natoms
        geo%atom(iatom)%v(1:MAX_DIM) = geo%atom(iatom)%v(1:MAX_DIM) + &
          this%dt*geo%atom(iatom)%f(1:MAX_DIM) / species_weight(geo%atom(iatom)%spec)
        geo%atom(iatom)%x(1:MAX_DIM) = geo%atom(iatom)%x(1:MAX_DIM) + M_HALF*this%dt*geo%atom(iatom)%v(1:MAX_DIM)
      enddo

      call chain(this, geo)

    end select

    call pop_sub()
  end subroutine ion_dynamics_propagate_vel

  subroutine ion_dynamics_save_state(this, geo, state)
    type(ion_dynamics_t), intent(in)    :: this
    type(geometry_t),     intent(in)    :: geo
    type(ion_state_t),    intent(out)   :: state

    integer :: iatom

    if(.not. ion_dynamics_ions_move(this) .or. this%method /= VELOCITY_VERLET) return

    call push_sub('ion_dynamics.ion_dynamics_save_state')

    SAFE_ALLOCATE(state%pos(1:MAX_DIM, 1:geo%natoms))
    SAFE_ALLOCATE(state%vel(1:MAX_DIM, 1:geo%natoms))

    do iatom = 1, geo%natoms
      state%pos(1:MAX_DIM, iatom) = geo%atom(iatom)%x(1:MAX_DIM)
      state%vel(1:MAX_DIM, iatom) = geo%atom(iatom)%v(1:MAX_DIM)
    end do

    call pop_sub()
  end subroutine ion_dynamics_save_state

  subroutine ion_dynamics_restore_state(this, geo, state)
    type(ion_dynamics_t), intent(in)    :: this
    type(geometry_t),     intent(inout) :: geo
    type(ion_state_t),    intent(inout) :: state

    integer :: iatom

    if(.not. ion_dynamics_ions_move(this)) return

    call push_sub('ion_dynamics.ion_dynamics_restore_state')

    do iatom = 1, geo%natoms
      geo%atom(iatom)%x(1:MAX_DIM) = state%pos(1:MAX_DIM, iatom)
      geo%atom(iatom)%v(1:MAX_DIM) = state%vel(1:MAX_DIM, iatom)
    end do

    SAFE_DEALLOCATE_P(state%pos)
    SAFE_DEALLOCATE_P(state%vel)
    
    call pop_sub()
  end subroutine ion_dynamics_restore_state

  logical pure function ion_dynamics_ions_move(this) result(ions_move)
    type(ion_dynamics_t), intent(in)    :: this
    
    ions_move = (this%method /= STATIC_IONS)
    
  end function ion_dynamics_ions_move
  
  ! ---------------------------------------------------------
  FLOAT pure function ion_dynamics_kinetic_energy(geo) result(kinetic_energy)
    type(geometry_t),      intent(in) :: geo

    integer :: iatom

    kinetic_energy = M_ZERO
    do iatom = 1, geo%natoms
      kinetic_energy = kinetic_energy + &
        M_HALF * species_weight(geo%atom(iatom)%spec) * sum(geo%atom(iatom)%v(1:MAX_DIM)**2)
    end do

  end function ion_dynamics_kinetic_energy

  ! ---------------------------------------------------------
  FLOAT pure function ion_dynamics_temperature(geo) result(temperature)
    type(geometry_t),      intent(in) :: geo

    temperature = M_TWO/M_THREE*ion_dynamics_kinetic_energy(geo)/(geo%natoms*P_Kb)
    
  end function ion_dynamics_temperature

end module ion_dynamics_m

!! Local Variables:
!! mode: f90
!! coding: utf-8
!! End:
