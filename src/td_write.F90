!! Copyright (C) 2002-2006 M. Marques, A. Castro, A. Rubio, G. Bertsch
!!
!! This program is free software; you can redistribute it and/or modify
!! it under the terms of the GNU General Public License as published by
!! the Free Software Foundation; either version 2, or (at your option)
!! any later version.
!!
!! This program is distributed in the hope that it will be useful,
!! but WITHOUT ANY WARRANTY; without even the implied warranty of
!! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!! GNU General Public License for more details.
!!
!! You should have received a copy of the GNU General Public License
!! along with this program; if not, write to the Free Software
!! Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
!! 02111-1307, USA.
!!
!! $Id$

#include "global.h"

module td_write_m
  use datasets_m
  use excited_states_m
  use functions_m
  use geometry_m
  use global_m
  use grid_m
  use hamiltonian_m
  use io_m
  use lasers_m
  use lib_oct_m
  use lib_oct_parser_m
  use magnetic_m
  use mesh_function_m
  use mesh_m
  use messages_m
  use mpi_m
  use output_m
  use restart_m
  use spectrum_m
  use states_m
  use states_output_m
  use units_m
  use varinfo_m
  use external_pot_m

  implicit none

  private
  public ::         &
    td_write_t,     &
    td_write_init,  &
    td_write_end,   &
    td_write_iter,  &
    td_write_data


  type td_write_t
    private
    C_POINTER :: out_multip
    C_POINTER :: out_coords
    C_POINTER :: out_populations
    C_POINTER :: out_acc
    C_POINTER :: out_laser
    C_POINTER :: out_energy
    C_POINTER :: out_proj
    C_POINTER :: out_angular
    C_POINTER :: out_spin
    C_POINTER :: out_magnets
    C_POINTER :: out_gauge_field

    integer        :: lmax     ! maximum multipole moment to output
    FLOAT          :: lmm_r    ! radius of the sphere used to compute the local magnetic moments
    type(states_t), pointer :: gs_st    ! The states_type where the ground state is stored, in order to
                                        ! calculate the projections(s) onto it.
    integer        :: n_excited_states  ! number of excited sates onto which the projections are calculated.
    type(excited_states_t), pointer :: excited_st(:) ! The excited states.
  end type td_write_t

contains

  ! ---------------------------------------------------------
  subroutine td_write_init(w, gr, st, geo, ions_move, with_gauge_field, iter, dt)
    type(td_write_t)             :: w
    type(grid_t),     intent(in) :: gr
    type(states_t),   intent(in) :: st
    type(geometry_t), intent(in) :: geo
    logical,          intent(in) :: ions_move
    logical,          intent(in) :: with_gauge_field
    integer,          intent(in) :: iter
    FLOAT,            intent(in) :: dt


    FLOAT :: rmin
    integer :: ierr, first, i, flags
    C_POINTER :: blk
    character(len=100) :: filename

    call push_sub('td_write.td_write_handler')


    !%Variable TDOutput
    !%Type flag
    !%Default multipoles + geometry
    !%Section Time Dependent::TD Output
    !%Description
    !% Defines what should be output during the time-dependent simulation.
    !%Option multipoles 1
    !% Outputs the multipole moments of the density to the file <tt>td.general/multipoles</tt>.
    !% This is required to, e.g., calculate optical absorption spectra of finite systems. The
    !% maximum value of <math>l</math> can be set with the variable <tt>TDDipoleLmax</tt>.
    !%Option angular 2
    !% Outputs the angular momentum of the system that can be used to calculate circular
    !% dichroism (EXPERIMENTAL)
    !%Option spin 4
    !% Outputs the expectation value of the spin, that can be used to calculate magnetic
    !% cicular dichroism (EXPERIMENTAL)
    !%Option populations 8
    !% Outputs the projection of the time-dependent Kohn-Sham Slater determinant
    !% onto the ground-state (or approximations to the excited states) to the file 
    !% <tt>td.general/populations</tt>.
    !%Option geometry 16
    !% If set (and if the atoms are allowed to move), outputs the coordinates, velocities,
    !% and forces of the atoms to the the file <tt>td.general/coordinates</tt>.
    !%Option acceleration 32
    !% When set outputs the acceleration, calculated from Ehrenfest theorem,
    !% in the file <tt>td.general/acceleration</tt>. This file can then be
    !% processed by the utility "hs-from-acc" in order to obtain the harmonic spectrum.
    !%Option laser 64
    !% If set, and if there are lasers defined in <tt>TDLasers</tt>,
    !% <tt>octopus</tt> outputs the laser field to the file <tt>td.general/laser</tt>.
    !%Option energy 128
    !% If <tt>set</tt>, <tt>octopus</tt> outputs the different components of the energy
    !% to the file <tt>td.general/el_energy</tt>.
    !%Option td_occup 256
    !% If set, outputs the projections of the time-dependent Kohn-Sham
    !% wave-functions onto the static (zero time) wave-functions to the
    !% file <tt>td.general/projections.XXX</tt>.
    !%Option local_mag_moments 512
    !% If set, outputs the local magnetic moments, integrated in sphere centered around each atom.
    !% The radius of the sphere can be ser with <tt>LocalMagneticMomentsSphereRadius</tt>
    !%Option gauge_field 1024
    !% If set, outputs the vector gauge field corresponding to a uniform (but time dependent) external electrical potential.
    !% This is only useful in a time-dependent periodic run
    !%End
    call loct_parse_int(check_inp('TDOutput'), 1+16+128, flags)
    if(.not.varinfo_valid_option('TDOutput', flags, is_flag=.true.)) then
      call input_error('TDOutput')
    end if

    w%out_multip  = 0; if(iand(flags,   1).ne.0) w%out_multip  = 1
    w%out_angular = 0; if(iand(flags,   2).ne.0) w%out_angular = 1
    w%out_spin    = 0; if(iand(flags,   4).ne.0) w%out_spin    = 1
    w%out_populations = 0; if(iand(flags,   8).ne.0) w%out_populations     = 1
    w%out_coords  = 0; if(iand(flags,  16).ne.0.and.ions_move) w%out_coords = 1
    w%out_acc     = 0; if(iand(flags,  32).ne.0) w%out_acc     = 1
    w%out_laser   = 0; if(iand(flags,  64).ne.0) w%out_laser   = 1
    w%out_energy  = 0; if(iand(flags, 128).ne.0) w%out_energy  = 1
    w%out_proj    = 0; if(iand(flags, 256).ne.0) w%out_proj    = 1
    w%out_magnets = 0; if(iand(flags, 512).ne.0) w%out_magnets = 1
    w%out_gauge_field = 0; if(iand(flags, 1024).ne.0 .and. with_gauge_field) w%out_gauge_field = 1

    !%Variable TDDipoleLmax
    !%Type integer
    !%Default 1
    !%Section Time Dependent::TD Output
    !%Description
    !% Maximum multi-pole of the density output to the file @code{td.general/multipoles} 
    !% during a time-dependent simulation. Must be 0 &lt; <tt>TDDipoleLmax &lt; 5</tt>.
    !%End
    call loct_parse_int(check_inp('TDDipoleLmax'), 1, w%lmax)
    if (w%lmax < 0 .or. w%lmax > 4) then
      write(message(1), '(a,i6,a)') "Input: '", w%lmax, "' is not a valid TDDipoleLmax"
      message(2) = '(0 <= TDDipoleLmax <= 4 )'
      call write_fatal(2)
    end if

    ! Compatibility test
    if( (w%out_acc.ne.0) .and. ions_move ) then
      message(1) = 'Error. If harmonic spectrum is to be calculated'
      message(2) = 'Atoms should not be allowed to move'
      call write_fatal(2)
    end if

    call geometry_min_distance(geo, rmin)
    call loct_parse_float(check_inp('LocalMagneticMomentsSphereRadius'), rmin*M_HALF/units_inp%length%factor, w%lmm_r)
    w%lmm_r = w%lmm_r * units_inp%length%factor

    if( (w%out_proj.ne.0)  .or.  (w%out_populations.ne.0) ) then
      nullify(w%gs_st)
      ALLOCATE(w%gs_st, 1)
      call states_copy(w%gs_st, st)
      ! WARNING: should be first deallocate, then nullify?
!!$      nullify(w%gs_st%zpsi, w%gs_st%node, w%gs_st%occ, w%gs_st%eigenval, w%gs_st%mag)
      nullify(w%gs_st%zpsi, w%gs_st%node, w%gs_st%occ, w%gs_st%eigenval)
      call restart_look (trim(tmpdir)//'restart_gs', gr%m, i, i, w%gs_st%nst, ierr)

      w%gs_st%st_start = 1
      if(w%out_populations == 0) then ! do only this when not calculating populations
        ! We will store the ground-state Kohn-Sham system by all processors.
        !%Variable TDProjStateStart
        !%Type integer
        !%Default 1
        !%Section Time Dependent::TD Output
        !%Description
        !% Only output projections to states above TDProjStateStart. Usually one is only interested
        !% in particle-hole projections around the HOMO, so there is no need to calculate (and store)
        !% the projections of all static onto all TD states. This sets a lower limit. The upper limit
        !% is set by the number of states in the propagation and the number of uncoccupied states
        !% available
        !%End
        call loct_parse_int(check_inp('TDProjStateStart'), w%gs_st%st_start, w%gs_st%st_start)
      end if
      w%gs_st%st_end   = w%gs_st%nst

      ! allocate memory
      ALLOCATE(w%gs_st%occ(w%gs_st%nst, w%gs_st%d%nik), w%gs_st%nst*w%gs_st%d%nik)
      ALLOCATE(w%gs_st%eigenval(w%gs_st%nst, w%gs_st%d%nik), w%gs_st%nst*w%gs_st%d%nik)
      ALLOCATE(w%gs_st%momentum(3, w%gs_st%nst, w%gs_st%d%nik), 3*w%gs_st%nst*w%gs_st%d%nik)
      ALLOCATE(w%gs_st%node(w%gs_st%nst), w%gs_st%nst)
      if(w%gs_st%d%ispin == SPINORS) then
        ALLOCATE(w%gs_st%spin(3, w%gs_st%nst, w%gs_st%d%nik), w%gs_st%nst*w%gs_st%d%nik*3)
      end if
      call states_allocate_wfns(w%gs_st, gr%m, M_CMPLX)
      w%gs_st%node(:)  = 0
      call restart_read(trim(tmpdir)//'restart_gs', w%gs_st, gr, geo, ierr)
      if(ierr.ne.0.and.ierr.ne.(w%gs_st%st_end-w%gs_st%st_start+1)*w%gs_st%d%nik*w%gs_st%d%dim) then
        message(1) = "Could not load "//trim(tmpdir)//"restart_gs"
        call write_fatal(1)
      end if
    end if

    ! Build the excited states...
    if( w%out_populations.ne.0) then
      !%Variable TDExcitedStatesToProject
      !%Type block
      !%Section Time Dependent::TD Output
      !%Description
      !% [WARNING: This is a *very* experimental feature] The population of the excited states
      !% (as defined by <Phi_I|Phi(t)> where |Phi(t)> is the many-body time dependent state at
      !% time t, and |Phi_I> is the excited state of interest) can be approximated -- not clear 
      !% how well--  by substituting those real many-body states by the time-dependent Kohn-Sham
      !% determinant and by some modification of the Kohn-Sham ground state determinant (e.g.,
      !% a simple HOMO-LUMO substitution, or the Casida ansatz for excited statesi in linear
      !% response theory. If you set TDOuput to contain, you may ask for these approximated
      !% populations for a number of excited states, which will be described in the files specified
      !% in this block: each line should be the name of a file that contains one excited state.
      !%
      !% FIXME: description of the format of the files.
      !%End
      if(loct_parse_block('TDExcitedStatesToProject', blk) == 0) then
        w%n_excited_states = loct_parse_block_n(blk)
        ALLOCATE(w%excited_st(w%n_excited_states), w%n_excited_states)
        do i = 1, w%n_excited_states
          call loct_parse_block_string(blk, i-1, 0, filename)
          call excited_states_init(w%excited_st(i), w%gs_st, trim(filename)) 
        end do
      else
        w%n_excited_states = 0
        nullify(w%excited_st)
      end if
    end if

    if (iter == 0) then
      first = 0
    else
      first = iter + 1
    end if

    if(mpi_grp_is_root(mpi_world)) then
      if(w%out_multip.ne.0)  call write_iter_init(w%out_multip,  first, dt/units_out%time%factor, &
        trim(io_workpath("td.general/multipoles")))
      if(w%out_angular.ne.0) call write_iter_init(w%out_angular, first, dt/units_out%time%factor, &
        trim(io_workpath("td.general/angular")))
      if(w%out_spin.ne.0)    call write_iter_init(w%out_spin,    first, dt/units_out%time%factor, &
        trim(io_workpath("td.general/spin")))
      if(w%out_magnets.ne.0) call write_iter_init(w%out_magnets, first, dt/units_out%time%factor, &
        trim(io_workpath("td.general/magnetic_moments")))
      if(w%out_coords.ne.0)  call write_iter_init(w%out_coords,  first, dt/units_out%time%factor, &
        trim(io_workpath("td.general/coordinates")))
      if(w%out_populations.ne.0) call write_iter_init(w%out_populations,     first, dt/units_out%time%factor, &
        trim(io_workpath("td.general/populations")))
      if(w%out_acc.ne.0)     call write_iter_init(w%out_acc,     first, dt/units_out%time%factor, &
        trim(io_workpath("td.general/acceleration")))
      if(w%out_laser.ne.0)   call write_iter_init(w%out_laser,   first, dt/units_out%time%factor, &
        trim(io_workpath("td.general/laser")))
      if(w%out_energy.ne.0)  call write_iter_init(w%out_energy,  first, dt/units_out%time%factor, &
        trim(io_workpath("td.general/energy")))
      if(w%out_proj.ne.0)    call write_iter_init(w%out_proj,    first, dt/units_out%time%factor, &
        trim(io_workpath("td.general/projections")))
      if(w%out_gauge_field.ne.0)    call write_iter_init(w%out_gauge_field,    first, dt/units_out%time%factor, &
        trim(io_workpath("td.general/A_gauge")))
    end if

    call io_mkdir('td.general')

    call pop_sub()
  end subroutine td_write_init


  ! ---------------------------------------------------------
  subroutine td_write_end(w)
    type(td_write_t) :: w
    integer :: i
    call push_sub('td_write.td_write_end')

    if(mpi_grp_is_root(mpi_world)) then
      if(w%out_multip.ne.0)  call write_iter_end(w%out_multip)
      if(w%out_angular.ne.0) call write_iter_end(w%out_angular)
      if(w%out_spin.ne.0)    call write_iter_end(w%out_spin)
      if(w%out_magnets.ne.0) call write_iter_end(w%out_magnets)
      if(w%out_coords.ne.0)  call write_iter_end(w%out_coords)
      if(w%out_populations.ne.0)     call write_iter_end(w%out_populations)
      if(w%out_acc.ne.0)     call write_iter_end(w%out_acc)
      if(w%out_laser.ne.0)   call write_iter_end(w%out_laser)
      if(w%out_energy.ne.0)  call write_iter_end(w%out_energy)
      if(w%out_proj.ne.0)    call write_iter_end(w%out_proj)
      if(w%out_gauge_field.ne.0)    call write_iter_end(w%out_gauge_field)
    end if
    if( w%out_populations.ne.0 ) then
      do i = 1, w%n_excited_states
        call excited_states_kill(w%excited_st(i))
      end do
    end if
    if( (w%out_populations.ne.0) .or. (w%out_proj.ne.0) ) then
      call states_end(w%gs_st)
    end if

    call pop_sub()
  end subroutine td_write_end


  ! ---------------------------------------------------------
  subroutine td_write_iter(w, gr, st, h, geo, kick, dt, i)
    type(td_write_t),       intent(in) :: w
    type(grid_t),        intent(inout) :: gr
    type(states_t),      intent(inout) :: st
    type(hamiltonian_t), intent(inout) :: h
    type(geometry_t),    intent(inout) :: geo
    type(kick_t),           intent(in) :: kick
    FLOAT,                  intent(in) :: dt
    integer,                intent(in) :: i

    call push_sub('td_write.td_write_iter')

    if(w%out_multip.ne.0)   call td_write_multipole(w%out_multip, gr, geo, st, w%lmax, kick, i)
    if(w%out_angular.ne.0)  call td_write_angular(w%out_angular, gr, st, kick, i)
    if(w%out_spin.ne.0)     call td_write_spin(w%out_spin, gr, st, i)
    if(w%out_magnets.ne.0)  call td_write_local_magnetic_moments(w%out_magnets, gr, st, geo, w%lmm_r, i)
    if(w%out_proj.ne.0)     call td_write_proj(w%out_proj, gr, geo, st, w%gs_st, kick, i)
    if(w%out_coords.ne.0)   call td_write_coordinates(w%out_coords, gr, geo, i)
    if(w%out_populations.ne.0) &
      call td_write_populations(w%out_populations, gr%m, st, w%gs_st, w%n_excited_states, w%excited_st, dt, i)
    if(w%out_acc.ne.0)      call td_write_acc(w%out_acc, gr, geo, st, h, dt, i)
    if(w%out_laser.ne.0)    call td_write_laser(w%out_laser, gr, h, dt, i)
    if(w%out_energy.ne.0)   call td_write_energy(w%out_energy, h, i, geo%kinetic_energy)
    if(w%out_gauge_field.ne.0)   call td_write_gauge_field(w%out_gauge_field, h, gr, i)

    call pop_sub()
  end subroutine td_write_iter


  ! ---------------------------------------------------------
  subroutine td_write_data(w, gr, st, h, outp, geo, dt_, iter)
    type(td_write_t),    intent(in)    :: w
    type(grid_t),        intent(inout) :: gr
    type(states_t),      intent(inout) :: st
    type(hamiltonian_t), intent(in)    :: h
    type(output_t),      intent(in)    :: outp
    type(geometry_t),    intent(in)    :: geo
    FLOAT, intent(in) :: dt_
    integer, intent(in) :: iter

    FLOAT :: dt
    character(len=256) :: filename

    call push_sub('td.td_write_data')

    if(mpi_grp_is_root(mpi_world)) then
      if(w%out_multip.ne.0)  call write_iter_flush(w%out_multip)
      if(w%out_angular.ne.0) call write_iter_flush(w%out_angular)
      if(w%out_spin.ne.0)    call write_iter_flush(w%out_spin)
      if(w%out_magnets.ne.0) call write_iter_flush(w%out_magnets)
      if(w%out_coords.ne.0)  call write_iter_flush(w%out_coords)
      if(w%out_populations.ne.0)     call write_iter_flush(w%out_populations)
      if(w%out_acc.ne.0)     call write_iter_flush(w%out_acc)
      if(w%out_laser.ne.0)   call write_iter_flush(w%out_laser)
      if(w%out_energy.ne.0)  call write_iter_flush(w%out_energy)
      if(w%out_proj.ne.0)    call write_iter_flush(w%out_proj)
    end if

    ! now write down the rest
    write(filename, '(a,i7.7)') "td.", iter  ! name of directory

    call states_output(st, gr, filename, outp)
    if(iand(outp%what, output_geometry).ne.0) &
      call atom_write_xyz(filename, "geometry", geo)
    call hamiltonian_output(h, gr%m, gr%sb, filename, outp)

    dt = dt_
!!$#if !defined(DISABLE_PES) && defined(HAVE_FFT)
!!$  call PES_output(td%PESv, gr%m, st, iter, outp%iter, dt)
!!$#endif

    call pop_sub()
  end subroutine td_write_data


  ! ---------------------------------------------------------
  subroutine td_write_spin(out_spin, gr, st, iter)
    C_POINTER,      intent(in) :: out_spin
    type(grid_t),   intent(inout) :: gr
    type(states_t), intent(in) :: st
    integer,        intent(in) :: iter

    character(len=130) :: aux
    FLOAT :: spin(3)

    call push_sub('td_write.td_write_spin')

    ! The expectation value of the spin operator is half the total magnetic moment
    ! This has to be calculated by all nodes
    call magnetic_moment(gr%m, st, st%rho, spin)
    spin = M_HALF*spin

    if(mpi_grp_is_root(mpi_world)) then ! only first node outputs

      if(iter ==0) then
        call td_write_print_header_init(out_spin)

        !second line -> columns name
        call write_iter_header_start(out_spin)
        if (st%d%ispin == SPINORS) then
          write(aux, '(a2,18x)') 'Sx'
          call write_iter_header(out_spin, aux)
          write(aux, '(a2,18x)') 'Sy'
          call write_iter_header(out_spin, aux)
        end if
        write(aux, '(a2,18x)') 'Sz'
        call write_iter_header(out_spin, aux)
        call write_iter_nl(out_spin)

        call td_write_print_header_end(out_spin)
      end if

      call write_iter_start(out_spin)
      select case (st%d%ispin)
      case (SPIN_POLARIZED)
        call write_iter_double(out_spin, spin(3), 1)
      case (SPINORS)
        call write_iter_double(out_spin, spin(1:3), 3)
      end select
      call write_iter_nl(out_spin)

    end if

    call pop_sub()
  end subroutine td_write_spin


  ! ---------------------------------------------------------
  subroutine td_write_local_magnetic_moments(out_magnets, gr, st, geo, lmm_r, iter)
    C_POINTER,        intent(in) :: out_magnets
    type(grid_t),     intent(inout) :: gr
    type(states_t),   intent(in) :: st
    type(geometry_t), intent(in) :: geo
    FLOAT,            intent(in) :: lmm_r
    integer,          intent(in) :: iter

    integer :: ia
    character(len=50) :: aux
    FLOAT, allocatable :: lmm(:,:)

    call push_sub('td_write.td_write_local_magnetic_moments')

    !get the atoms magnetization. This has to be calculated by all nodes
    ALLOCATE(lmm(3, geo%natoms), 3*geo%natoms)
    call magnetic_local_moments(gr%m, st, geo, st%rho, lmm_r, lmm)

    if(mpi_grp_is_root(mpi_world)) then ! only first node outputs

      if(iter ==0) then
        call td_write_print_header_init(out_magnets)

        !second line -> columns name
        call write_iter_header_start(out_magnets)
        do ia = 1, geo%natoms
          if (st%d%ispin == SPINORS) then
            write(aux, '(a2,i2.2,16x)') 'mx', ia
            call write_iter_header(out_magnets, aux)
            write(aux, '(a2,i2.2,16x)') 'my', ia
            call write_iter_header(out_magnets, aux)
          end if
          write(aux, '(a2,i2.2,16x)') 'mz', ia
          call write_iter_header(out_magnets, aux)
        end do
        call write_iter_nl(out_magnets)

        call td_write_print_header_end(out_magnets)
      end if

      call write_iter_start(out_magnets)
      do ia = 1, geo%natoms
        select case (st%d%ispin)
        case (SPIN_POLARIZED)
          call write_iter_double(out_magnets, lmm(3, ia), 1)
        case (SPINORS)
          call write_iter_double(out_magnets, lmm(1:3, ia), 3)
        end select
      end do
      call write_iter_nl(out_magnets)
      deallocate(lmm)
    end if

    call pop_sub()
  end subroutine td_write_local_magnetic_moments


  ! ---------------------------------------------------------
  subroutine td_write_kick_info(out, st, kick, lmax)
    C_POINTER,         intent(in) :: out
    type(states_t),    intent(in) :: st
    type(kick_t),      intent(in) :: kick
    integer, optional, intent(in) :: lmax

    character(len=120) :: aux

    write(aux, '(a15,i2)')      '# nspin        ', st%d%nspin
    call write_iter_string(out, aux)
    call write_iter_nl(out)

    if(present(lmax)) then
      write(aux, '(a15,i2)')      '# lmax         ', lmax
      call write_iter_string(out, aux)
      call write_iter_nl(out)
    end if

    write(aux, '(a15,3f18.12)') '# pol(1)       ', kick%pol(1:3, 1)
    call write_iter_string(out, aux)
    call write_iter_nl(out)

    write(aux, '(a15,3f18.12)') '# pol(2)       ', kick%pol(1:3, 2)
    call write_iter_string(out, aux)
    call write_iter_nl(out)

    write(aux, '(a15,3f18.12)') '# pol(3)       ', kick%pol(1:3, 3)
    call write_iter_string(out, aux)
    call write_iter_nl(out)

    write(aux, '(a15,i2)')      '# direction    ', kick%pol_dir
    call write_iter_string(out, aux)
    call write_iter_nl(out)

    write(aux, '(a15,i2)')      '# kick mode    ', kick%delta_strength_mode
    call write_iter_string(out, aux)
    call write_iter_nl(out)
    
    write(aux, '(a15,f18.12)')  '# kick strength', kick%delta_strength
    call write_iter_string(out, aux)
    call write_iter_nl(out)

    write(aux, '(a15,i2)')      '# Equiv. axis  ', kick%pol_equiv_axis
    call write_iter_string(out, aux)
    call write_iter_nl(out)

    write(aux, '(a15,3f18.12)') '# wprime       ', kick%wprime(1:3)
    call write_iter_string(out, aux)
    call write_iter_nl(out)

  end subroutine td_write_kick_info


  ! ---------------------------------------------------------
  subroutine td_write_angular(out_angular, gr, st, kick, iter)
    C_POINTER,      intent(in) :: out_angular
    type(grid_t),   intent(inout) :: gr
    type(states_t), intent(inout) :: st
    type(kick_t),   intent(in) :: kick
    integer,        intent(in) :: iter

    integer :: ik, ist
    character(len=130) :: aux
    FLOAT :: angular(MAX_DIM), lsquare
    FLOAT, allocatable :: ang(:, :, :), ang2(:, :)

    call push_sub('td_write.td_write_angular')

    ALLOCATE(ang (st%nst, st%d%nik, 3), st%nst*st%d%nik*3)
    ALLOCATE(ang2(st%nst, st%d%nik), st%nst*st%d%nik)
    do ik = 1, st%d%nik
      do ist = st%st_start, st%st_end
        call zstates_angular_momentum(gr, st%zpsi(:, :, ist, ik), ang(ist, ik, :), ang2(ist, ik))
      end do
    end do
    angular(1) =  states_eigenvalues_sum(st, ang(1:st%nst, 1:st%d%nik, 1))
    angular(2) =  states_eigenvalues_sum(st, ang(1:st%nst, 1:st%d%nik, 2))
    angular(3) =  states_eigenvalues_sum(st, ang(1:st%nst, 1:st%d%nik, 3))
    lsquare    =  states_eigenvalues_sum(st, ang2(1:st%nst, 1:st%d%nik))

    if(mpi_grp_is_root(mpi_world)) then ! Only first node outputs

      if(iter ==0) then
        call td_write_print_header_init(out_angular)
        call td_write_kick_info(out_angular, st, kick)

        !second line -> columns name
        call write_iter_header_start(out_angular)
        write(aux, '(a4,18x)') '<Lx>'
        call write_iter_header(out_angular, aux)
        write(aux, '(a4,18x)') '<Ly>'
        call write_iter_header(out_angular, aux)
        write(aux, '(a4,18x)') '<Lz>'
        call write_iter_header(out_angular, aux)
        write(aux, '(a4,18x)') '<L2>'
        call write_iter_header(out_angular, aux)
        call write_iter_nl(out_angular)

        !third line -> should hold the units. Now unused (assumes atomic units)
        call write_iter_string(out_angular, '#[Iter n.]')
        call write_iter_header(out_angular, '[a.u]')
        call write_iter_nl(out_angular)

        call td_write_print_header_end(out_angular)
      end if

      call write_iter_start(out_angular)
      call write_iter_double(out_angular, angular(1:3), 3)
      call write_iter_double(out_angular, lsquare, 1)
      call write_iter_nl(out_angular)

    end if

    deallocate(ang, ang2)
    call pop_sub()
  end subroutine td_write_angular


  ! ---------------------------------------------------------
  subroutine td_write_multipole(out_multip, gr, geo, st, lmax, kick, iter)
    C_POINTER,        intent(in) :: out_multip
    type(grid_t),     intent(in) :: gr
    type(geometry_t), intent(in) :: geo
    type(states_t),   intent(in) :: st
    integer,          intent(in) :: lmax
    type(kick_t),     intent(in) :: kick
    integer,          intent(in) :: iter

    integer :: is, l, m, add_lm
    character(len=120) :: aux
    FLOAT, allocatable :: nuclear_dipole(:), multipole(:,:)

    call push_sub('td_write.td_write_multipole')

    if(mpi_grp_is_root(mpi_world).and.iter == 0) then
      call td_write_print_header_init(out_multip)
      call td_write_kick_info(out_multip, st, kick, lmax)

      call write_iter_header_start(out_multip)

      do is = 1, st%d%nspin
        write(aux,'(a18,i1,a1)') 'Electronic charge(', is,')'; call write_iter_header(out_multip, aux)
        if(lmax>0) then
          write(aux, '(a3,a1,i1,a1)') '<x>', '(', is,')'; call write_iter_header(out_multip, aux)
          write(aux, '(a3,a1,i1,a1)') '<y>', '(', is,')'; call write_iter_header(out_multip, aux)
          write(aux, '(a3,a1,i1,a1)') '<z>', '(', is,')'; call write_iter_header(out_multip, aux)
        end if
        do l = 2, lmax
          do m = -l, l
            write(aux, '(a2,i2,a4,i2,a2,i1,a1)') 'l=', l, ', m=', m, ' (', is,')'
            call write_iter_header(out_multip, aux)
          end do
        end do
      end do
      call write_iter_nl(out_multip)

      ! units
      call write_iter_string(out_multip, '#[Iter n.]')
      call write_iter_header(out_multip, '[' // trim(units_out%time%abbrev) // ']')

      do is = 1, st%d%nspin
        do l = 0, lmax
          do m = -l, l
            select case(l)
            case(0)
              call write_iter_header(out_multip, 'Electrons')
            case(1)
              call write_iter_header(out_multip, '[' // trim(units_out%length%abbrev) // ']')
            case default
              write(aux, '(a,a2,i1)') trim(units_out%length%abbrev), "**", l
              call write_iter_header(out_multip, '[' // trim(aux) // ']')
            end select
          end do
        end do
      end do
      call write_iter_nl(out_multip)

      call td_write_print_header_end(out_multip)
    end if

    ALLOCATE(nuclear_dipole(1:3), 3)
    ALLOCATE(multipole((lmax + 1)**2, st%d%nspin), (lmax + 1)**2*st%d%nspin)
    do is = 1, st%d%nspin
      call df_multipoles(gr%m, st%rho(:,is), lmax, multipole(:,is))
    end do
    call geometry_dipole(geo, nuclear_dipole)
    do is = 1, st%d%nspin
      multipole(2:4, is) = nuclear_dipole(1:3) - multipole(2:4, is)
    end do

    if(mpi_grp_is_root(mpi_world)) then
      call write_iter_start(out_multip)
      do is = 1, st%d%nspin
        add_lm = 1
        do l = 0, lmax
          do m = -l, l
            call write_iter_double(out_multip, multipole(add_lm, is)/units_out%length%factor**l, 1)
            add_lm = add_lm + 1
          end do
        end do
      end do
      call write_iter_nl(out_multip)
    end if

    deallocate(nuclear_dipole, multipole)
    call pop_sub()
  end subroutine td_write_multipole


  ! ---------------------------------------------------------
  subroutine td_write_coordinates(out_coords, gr, geo, iter)
    C_POINTER,        intent(in) :: out_coords
    type(grid_t),     intent(in) :: gr
    type(geometry_t), intent(in) :: geo
    integer,          intent(in) :: iter

    integer :: i, j
    character(len=50) :: aux

    call push_sub('td_write.td_write_coordinates')

    if(.not.mpi_grp_is_root(mpi_world)) return ! only first node outputs

    if(iter == 0) then
      call td_write_print_header_init(out_coords)

      ! first line: column names
      call write_iter_header_start(out_coords)

      do i = 1, geo%natoms
        do j = 1, NDIM
          write(aux, '(a2,i3,a1,i3,a1)') 'x(', i, ',', j, ')'
          call write_iter_header(out_coords, aux)
        end do
      end do
      do i = 1, geo%natoms
        do j = 1, NDIM
          write(aux, '(a2,i3,a1,i3,a1)') 'v(', i, ',',j,')'
          call write_iter_header(out_coords, aux)
        end do
      end do
      do i = 1, geo%natoms
        do j = 1, NDIM
          write(aux, '(a2,i3,a1,i3,a1)') 'f(', i, ',',j,')'
          call write_iter_header(out_coords, aux)
        end do
      end do
      call write_iter_nl(out_coords)

      ! second line: units
      call write_iter_string(out_coords, '#[Iter n.]')
      call write_iter_header(out_coords, '[' // trim(units_out%time%abbrev) // ']')
      call write_iter_string(out_coords, &
        'Positions in '   // trim(units_out%length%abbrev)   //   &
        ', Velocities in '// trim(units_out%velocity%abbrev) //   &
        ', Forces in '    // trim(units_out%force%abbrev))
      call write_iter_nl(out_coords)

      call td_write_print_header_end(out_coords)
    end if

    call write_iter_start(out_coords)

    do i = 1, geo%natoms
      call write_iter_double(out_coords, geo%atom(i)%x(1:NDIM)/units_out%length%factor,   NDIM)
    end do
    do i = 1, geo%natoms
      call write_iter_double(out_coords, geo%atom(i)%v(1:NDIM)/units_out%velocity%factor, NDIM)
    end do
    do i = 1, geo%natoms
      call write_iter_double(out_coords, geo%atom(i)%f(1:NDIM)/units_out%force%factor,    NDIM)
    end do
    call write_iter_nl(out_coords)

    call pop_sub()
  end subroutine td_write_coordinates


  ! ---------------------------------------------------------
  subroutine td_write_populations(out_populations, m, st, gs_st, n_excited_states, excited_st, dt, iter)
    C_POINTER,              intent(in) :: out_populations
    type(mesh_t),           intent(in) :: m
    type(states_t),         intent(in) :: st
    type(states_t),         intent(in) :: gs_st
    integer,                intent(in) :: n_excited_states
    type(excited_states_t), intent(in) :: excited_st(:)
    FLOAT,                  intent(in) :: dt
    integer,                intent(in) :: iter
 
    integer :: j, ik
    character(len=6) :: excited_name
    CMPLX :: gsp
    CMPLX, allocatable :: excited_state_p(:)
    CMPLX, allocatable :: dotprodmatrix(:, :, :)


    call push_sub('td_write.td_write_populations')

    ALLOCATE(dotprodmatrix(gs_st%nst, st%nst, st%d%nik), gs_st%nst*st%nst*st%d%nik)
    do ik = 1, st%d%nik
      call zcalculate_matrix(m, ik, gs_st, st, dotprodmatrix(:, :, ik))
    end do

    ! all processors calculate the projection
    gsp = zstates_mpdotp(m, gs_st, st, dotprodmatrix)

    if(n_excited_states > 0) then
      ALLOCATE(excited_state_p(n_excited_states), n_excited_states)
      do j = 1, n_excited_states
        excited_state_p(j) = zstates_mpdotp(m, excited_st(j), st, dotprodmatrix)
      end do
    end if

    if(mpi_grp_is_root(mpi_world)) then
      if(iter == 0) then
        call td_write_print_header_init(out_populations)

        ! first line -> column names
        call write_iter_header_start(out_populations)
        call write_iter_header(out_populations, 'Re<Phi_gs|Phi(t)>')
        call write_iter_header(out_populations, 'Im<Phi_gs|Phi(t)>')
        do j = 1, n_excited_states
          write(excited_name,'(a2,i3,a1)') 'P(',j,')'
          call write_iter_header(out_populations, 'Re<'//excited_name//'|Phi(t)>')
          call write_iter_header(out_populations, 'Im<'//excited_name//'|Phi(t)>')
        end do
        call write_iter_nl(out_populations)

        ! second line -> units
        call write_iter_string(out_populations, '#[Iter n.]')
        call write_iter_header(out_populations, '[' // trim(units_out%time%abbrev) // ']')
        call write_iter_nl(out_populations)

        call td_write_print_header_end(out_populations)
      end if

      ! can not call write_iter_start, for the step is not 1
      call write_iter_int(out_populations, iter, 1)
      call write_iter_double(out_populations, iter*dt/units_out%time%factor,  1)
      call write_iter_double(out_populations, real(gsp),  1)
      call write_iter_double(out_populations, aimag(gsp), 1)
      do j = 1, n_excited_states
        call write_iter_double(out_populations, real(excited_state_p(j)),  1)
        call write_iter_double(out_populations, aimag(excited_state_p(j)), 1)
      end do
      call write_iter_nl(out_populations)
    end if

    if(n_excited_states > 0) then
      deallocate(excited_state_p)
    end if
    deallocate(dotprodmatrix)
    call pop_sub()
  end subroutine td_write_populations



  ! ---------------------------------------------------------
  subroutine td_write_acc(out_acc, gr, geo, st, h, dt, iter)
    C_POINTER,           intent(in)    :: out_acc
    type(grid_t),        intent(inout) :: gr
    type(geometry_t),    intent(inout) :: geo
    type(states_t),      intent(inout) :: st
    type(hamiltonian_t), intent(inout) :: h
    FLOAT,               intent(in)    :: dt
    integer,             intent(in)    :: iter

    integer :: i
    character(len=7) :: aux
    FLOAT :: acc(MAX_DIM)

    if(.not.mpi_grp_is_root(mpi_world)) return ! only first node outputs

    if(iter == 0) then
      call td_write_print_header_init(out_acc)

      ! first line -> column names
      call write_iter_header_start(out_acc)
      do i = 1, NDIM
        write(aux, '(a4,i1,a1)') 'Acc(', i, ')'
        call write_iter_header(out_acc, aux)
      end do
      call write_iter_nl(out_acc)

      ! second line: units
      call write_iter_string(out_acc, '#[Iter n.]')
      call write_iter_header(out_acc, '[' // trim(units_out%time%abbrev) // ']')
      do i = 1, NDIM
        call write_iter_header(out_acc, '[' // trim(units_out%acceleration%abbrev) // ']')
      end do
      call write_iter_nl(out_acc)
      call td_write_print_header_end(out_acc)
    end if

    call td_calc_tacc(gr, geo, st, h, acc, dt*i)

    call write_iter_start(out_acc)
    call write_iter_double(out_acc, acc/units_out%acceleration%factor, NDIM)
    call write_iter_nl(out_acc)

  end subroutine td_write_acc


  ! ---------------------------------------------------------
  subroutine td_write_laser(out_laser, gr, h, dt, iter)
    C_POINTER,           intent(in) :: out_laser
    type(grid_t),        intent(in) :: gr
    type(hamiltonian_t), intent(in) :: h
    FLOAT,               intent(in) :: dt
    integer,             intent(in) :: iter

    integer :: i
    FLOAT :: field(MAX_DIM)
    character(len=80) :: aux

    if(.not.mpi_grp_is_root(mpi_world)) return ! only first node outputs

    ! TODO -> confirm these stupid units, especially for the vector field
    if(iter == 0) then
      call td_write_print_header_init(out_laser)

      ! first line
      write(aux, '(a7,e20.12,3a)') '# dt = ', dt/units_out%time%factor, &
        " [", trim(units_out%time%abbrev), "]"
      call write_iter_string(out_laser, aux)
      call write_iter_nl(out_laser)

      ! second line -> column names
      call write_iter_header_start(out_laser)
      do i = 1, NDIM
        write(aux, '(a,i1,a)') 'E(', i, ')'
        call write_iter_header(out_laser, aux)
      end do
      do i = 1, NDIM
        write(aux, '(a,i1,a)') 'A(', i, ')'
        call write_iter_header(out_laser, aux)
      end do
      call write_iter_nl(out_laser)

      ! third line -> units
      call write_iter_string(out_laser, '#[Iter n.]')
      call write_iter_header(out_laser, '[' // trim(units_out%time%abbrev) // ']')

      aux = '[' // trim(units_out%energy%abbrev) // ' / ' // trim(units_inp%length%abbrev) // ']'
      do i = 1, NDIM
        call write_iter_header(out_laser, aux)
      end do

      aux = '[1/' // trim(units_inp%length%abbrev) // ']'
      do i = 1, NDIM
        call write_iter_header(out_laser, aux)
      end do
      call write_iter_nl(out_laser)
      call td_write_print_header_end(out_laser)
    end if

    call write_iter_start(out_laser)

    field = M_ZERO

    call laser_field(gr%sb, h%ep%no_lasers, h%ep%lasers, iter*dt, field)
    field = field * units_inp%length%factor / units_inp%energy%factor
    call write_iter_double(out_laser, field, NDIM)

    call laser_vector_field(gr%sb, h%ep%no_lasers, h%ep%lasers, iter*dt, field)
    field = field  * units_inp%length%factor
    call write_iter_double(out_laser, field, NDIM)

    call write_iter_nl(out_laser)

  end subroutine td_write_laser


  ! ---------------------------------------------------------
  subroutine td_write_energy(out_energy, h, iter, ke)
    C_POINTER,           intent(in) :: out_energy
    type(hamiltonian_t), intent(in) :: h
    integer,             intent(in) :: iter
    FLOAT,               intent(in) :: ke

    integer :: i

    if(.not.mpi_grp_is_root(mpi_world)) return ! only first node outputs

    if(iter == 0) then
      call td_write_print_header_init(out_energy)

      ! first line -> column names
      call write_iter_header_start(out_energy)
      call write_iter_header(out_energy, 'Total')
      call write_iter_header(out_energy, 'Kinetic (ions)')
      call write_iter_header(out_energy, 'Ion-Ion')
      call write_iter_header(out_energy, 'Electronic')
      call write_iter_header(out_energy, 'Eigenvalues')
      call write_iter_header(out_energy, 'Hartree')
      call write_iter_header(out_energy, 'Int[n v_xc]')
      call write_iter_header(out_energy, 'Exchange')
      call write_iter_header(out_energy, 'Correlation')
      call write_iter_nl(out_energy)

      ! second line: units
      call write_iter_string(out_energy, '#[Iter n.]')
      call write_iter_header(out_energy, '[' // trim(units_out%time%abbrev) // ']')
      do i = 1, 7
        call write_iter_header(out_energy, '[' // trim(units_out%energy%abbrev) // ']')
      end do
      call write_iter_nl(out_energy)
      call td_write_print_header_end(out_energy)
    end if

    call write_iter_start(out_energy)
    call write_iter_double(out_energy, (h%etot+ke)/units_out%energy%factor, 1)
    call write_iter_double(out_energy, ke/units_out%energy%factor, 1)
    call write_iter_double(out_energy, h%eii /units_out%energy%factor, 1)
    call write_iter_double(out_energy, (h%etot-h%eii)/units_out%energy%factor, 1)
    call write_iter_double(out_energy, h%eeigen /units_out%energy%factor, 1)
    call write_iter_double(out_energy, h%ehartree /units_out%energy%factor, 1)
    call write_iter_double(out_energy, h%epot /units_out%energy%factor, 1)
    call write_iter_double(out_energy, h%ex  /units_out%energy%factor, 1)
    call write_iter_double(out_energy, h%ec  /units_out%energy%factor, 1)
    call write_iter_nl(out_energy)


  end subroutine td_write_energy

  ! ---------------------------------------------------------
  subroutine td_write_gauge_field(out_gauge, h, gr, iter)
    C_POINTER,           intent(in) :: out_gauge
    type(hamiltonian_t), intent(in) :: h
    type(grid_t),        intent(in) :: gr
    integer,             intent(in) :: iter
    
    integer :: j
    character(len=50) :: aux

    
    call push_sub('td_write.td_write_out_gauge')
    
    if(.not.mpi_grp_is_root(mpi_world)) return ! only first node outputs

    if(iter == 0) then
      call td_write_print_header_init(out_gauge)

      ! first line: column names
      call write_iter_header_start(out_gauge)

      do j = 1, NDIM
        write(aux, '(a2,i3,a1)') 'A(', j, ')'
        call write_iter_header(out_gauge, aux)
      end do
      do j = 1, NDIM
        write(aux, '(a6,i3,a1)') 'dA/dt(', j, ')'
        call write_iter_header(out_gauge, aux)
      end do
      do j = 1, NDIM
        write(aux, '(a2,i3,a1)') 'd^2A/dt^2(', j, ')'
        call write_iter_header(out_gauge, aux)
      end do
      call write_iter_nl(out_gauge)

      ! second line: units
      !call write_iter_string(out_gauge, '#[Iter n.]')
      !call write_iter_header(out_gauge, '[' // trim(units_out%time%abbrev) // ']')
      !call write_iter_string(out_gauge, &
      !  'A Vector potential in '   // trim(units_out%length%abbrev) &
      !  'A dot in '                // trim(units_out%length%abbrev) &
      !  'A dot dot in '            // trim(units_out%length%abbrev)
      !call write_iter_nl(out_gauge)

      call td_write_print_header_end(out_gauge)
    end if

    call write_iter_start(out_gauge)

    ! TODO: put the appropriate units here 
    call write_iter_double(out_gauge, h%ep%A_gauge(1:NDIM),   NDIM)
    call write_iter_double(out_gauge, h%ep%A_gauge_dot(1:NDIM), NDIM)
    call write_iter_double(out_gauge, h%ep%A_gauge_ddot(1:NDIM),    NDIM)
    call write_iter_nl(out_gauge)
    call pop_sub()
    
  end subroutine td_write_gauge_field

  ! ---------------------------------------------------------
  subroutine td_write_proj(out_proj, gr, geo, st, gs_st, kick, iter)
    C_POINTER,        intent(in) :: out_proj
    type(grid_t),     intent(in) :: gr
    type(geometry_t), intent(in) :: geo
    type(states_t),   intent(in) :: st
    type(states_t),   intent(in) :: gs_st
    type(kick_t),     intent(in) :: kick
    integer,          intent(in) :: iter

    CMPLX, allocatable :: projections(:,:,:)
    character(len=80) :: aux
    integer :: ik, ist, uist, idir

    call push_sub('td_write.td_write_proj')

    if(iter == 0) then
      if(mpi_grp_is_root(mpi_world)) then
        call td_write_print_header_init(out_proj)
        call td_write_kick_info(out_proj, st, kick)

        call write_iter_string(out_proj, "#%")
        call write_iter_nl(out_proj)
 
        write(aux, '(a,i8)') "# nik  ", st%d%nik
        call write_iter_string(out_proj, aux)
        call write_iter_nl(out_proj)

        write(aux, '(a,2i8)') "#  st  ", gs_st%st_start, st%nst
        call write_iter_string(out_proj, aux)
        call write_iter_nl(out_proj)

        write(aux, '(a,2i8)') "# ust  ", gs_st%st_start, gs_st%st_end
        call write_iter_string(out_proj, aux)
        call write_iter_nl(out_proj)

        do ik = 1, st%d%nik
          call write_iter_string(out_proj, "# w(ik)*occ(ist,ik)  ")
          do ist = gs_st%st_start, st%nst
            call write_iter_double(out_proj, st%d%kweights(ik)*st%occ(ist, ik), 1)
          end do
          call write_iter_nl(out_proj)
        end do

        call write_iter_header_start(out_proj)
        do ik = 1, st%d%nik
          do ist = gs_st%st_start, st%nst
            do uist = gs_st%st_start, gs_st%st_end
              write(aux, '(i4,a,i4)') ist, ' -> ', uist
              call write_iter_header(out_proj, 'Re {'//trim(aux)//'}')
              call write_iter_header(out_proj, 'Im {'//trim(aux)//'}')
            end do
          end do
        end do
        call write_iter_nl(out_proj)

      end if

      ALLOCATE(projections(gs_st%st_start:st%nst, gs_st%st_start:gs_st%st_end, st%d%nik), st%nst*gs_st%nst*st%d%nik)
      do idir = 1, 3
        projections(:,:,:) = M_Z0
        call dipole_matrix_elements(idir)

        if(mpi_grp_is_root(mpi_world)) then
          write(aux, '(a,i1,a)') "<i|x_", idir, "|a>"
          call write_iter_string(out_proj, "# ------")
          call write_iter_header(out_proj, aux)
          do ik = 1, st%d%nik
            do ist = gs_st%st_start, st%nst
              do uist = gs_st%st_start, gs_st%st_end
                call write_iter_double(out_proj,  real(projections(ist, uist, ik)), 1)
                call write_iter_double(out_proj, aimag(projections(ist, uist, ik)), 1)
              end do
            end do
          end do
          call write_iter_nl(out_proj)
          
        end if
      end do
      deallocate(projections)

      if(mpi_grp_is_root(mpi_world)) then
        call td_write_print_header_end(out_proj)
      end if

    end if

    ALLOCATE(projections(gs_st%st_start:st%nst, gs_st%st_start:gs_st%st_end, st%d%nik), st%nst*gs_st%nst*st%d%nik)
    projections(:,:,:) = M_Z0
    call calc_projections()

    if(mpi_grp_is_root(mpi_world)) then
      call write_iter_start(out_proj)
      do ik = 1, st%d%nik
        do ist = gs_st%st_start, st%nst
          do uist = gs_st%st_start, gs_st%st_end
            call write_iter_double(out_proj,  real(projections(ist, uist, ik)), 1)
            call write_iter_double(out_proj, aimag(projections(ist, uist, ik)), 1)
          end do
        end do
      end do
      call write_iter_nl(out_proj)
    end if

    deallocate(projections)
    call pop_sub()

  contains
    ! ---------------------------------------------------------
    ! This subroutine calculates:
    ! p(uist, ist, ik) = < phi0(uist, k) | phi(ist, ik) (t) >
    ! ---------------------------------------------------------
    subroutine calc_projections()
      integer :: uist, ist, ik
#if defined(HAVE_MPI)
      integer :: k
#endif

      do ik = 1, st%d%nik
        do ist = max(gs_st%st_start, st%st_start), st%st_end
          do uist = gs_st%st_start, gs_st%st_end
            projections(ist, uist, ik) = &
              zstates_dotp(gr%m, st%d%dim, st%zpsi(:, :, ist, ik), gs_st%zpsi(:, :, uist, ik))
          end do
        end do
      end do
      
      call distribute_projections()

    end subroutine calc_projections


    ! ---------------------------------------------------------
    subroutine dipole_matrix_elements(dir)
      integer, intent(in) :: dir

      integer :: uist, ist, ik, idim
      FLOAT   :: n_dip(MAX_DIM)
      CMPLX, allocatable :: xpsi(:,:)
#if defined(HAVE_MPI)
      integer :: k
#endif

      call geometry_dipole(geo, n_dip)

      ALLOCATE(xpsi(NP, st%d%dim), NP*st%d%dim)
      
      do ik = 1, st%d%nik
        do ist = max(gs_st%st_start, st%st_start), st%st_end
          do uist = gs_st%st_start, gs_st%st_end
            
            do idim = 1, st%d%dim
              xpsi(1:NP, idim) = gr%m%x(1:NP, dir) * gs_st%zpsi(1:NP, idim, uist, ik)
            end do

            projections(ist, uist, ik) = n_dip(dir) - &
              zstates_dotp(gr%m, st%d%dim, st%zpsi(:, :, ist, ik), xpsi(:, :))

          end do
        end do
      end do
      
      deallocate(xpsi)

      call distribute_projections()

    end subroutine dipole_matrix_elements

    subroutine distribute_projections
#if defined(HAVE_MPI)
      integer :: k, ik, ist, uist

      if(.not.st%parallel_in_states) return

      do ik = 1, st%d%nik
        do ist = gs_st%st_start, st%nst
          k = st%node(ist)
          do uist = gs_st%st_start, gs_st%st_end
            call MPI_Bcast(projections(ist, uist, ik), 1, MPI_CMPLX, k, st%mpi_grp%comm, mpi_err)
          end do
        end do
      end do

#endif
    end subroutine distribute_projections

  end subroutine td_write_proj


  ! ---------------------------------------------------------
  subroutine td_write_print_header_init(out)
    C_POINTER, intent(in) :: out

    call write_iter_clear(out)
    call write_iter_string(out,'################################################################################')
    call write_iter_nl(out)
    call write_iter_string(out,'# HEADER')
    call write_iter_nl(out)

  end subroutine td_write_print_header_init


  ! ---------------------------------------------------------
  subroutine td_write_print_header_end(out)
    C_POINTER, intent(in) :: out

    call write_iter_string(out,'################################################################################')
    call write_iter_nl(out)

  end subroutine td_write_print_header_end


#include "td_calc.F90"

end module td_write_m

!! Local Variables:
!! mode: f90
!! coding: utf-8
!! End:
