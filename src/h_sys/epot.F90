!! Copyright (C) 2002-2006 M. Marques, A. Castro, A. Rubio, G. Bertsch
!!
!! This program is free software; you can redistribute it and/or modify
!! it under the terms of the GNU General Public License as published by
!! the Free Software Foundation; either version 2, or (at your option)
!! any later version.
!!
!! This program is distributed in the hope that it will be useful,
!! but WITHOUT ANY WARRANTY; without even the implied warranty of
!! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!! GNU General Public License for more details.
!!
!! You should have received a copy of the GNU General Public License
!! along with this program; if not, write to the Free Software
!! Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
!! 02111-1307, USA.
!!
!! $Id$

#include "global.h"

module external_pot_m
  use datasets_m
  use derivatives_m
  use double_grid_m
  use functions_m
  use global_m
  use grid_m
  use io_m
  use lalg_basic_m
  use loct_parser_m
  use loct_gsl_spline_m
  use magnetic_m
  use mesh_function_m
  use mesh_m
  use messages_m
  use multicomm_m
  use simul_box_m
  use units_m
  use logrid_m
  use poisson_cutoffs_m
  use ps_m
  use specie_m
  use specie_pot_m
  use solids_m
  use geometry_m
  use states_m
  use submesh_m
  use lasers_m
  use profiling_m
  use mpi_m
  use mpi_debug_m
  use varinfo_m
  use poisson_m
  use projector_m

  implicit none

  private
  public ::                    &
    epot_t,                    &
    epot_init,                 &
    epot_end,                  &
    epot_generate,             &
    epot_generate_gauge_field, &
    epot_forces,               &
    dconmut_vnl_r,             &
    zconmut_vnl_r,             &
    epot_local_potential


  type epot_t
    ! Classic charges:
    integer :: classic_pot        ! How to include the classic charges
    FLOAT, pointer :: vclassic(:) ! We use it to store the potential of the classic charges

    ! Ions
    FLOAT,       pointer :: vpsl(:)       ! the local part of the pseudopotentials
    integer :: nvnl                       ! number of nonlocal operators
    type(projector_t), pointer :: p(:)    ! non-local projectors
    integer, pointer :: atomproj(:,:)     ! the range of projectors
                                          ! corresponding to an atom
    ! External e-m fields
    integer :: no_lasers                   ! number of laser pulses used
    type(laser_t), pointer :: lasers(:)    ! lasers stuff
    FLOAT, pointer :: E_field(:)           ! static electric field
    FLOAT, pointer :: v_static(:)          ! static scalar potential
    FLOAT, pointer :: B_field(:)           ! static magnetic field
    FLOAT, pointer :: A_static(:,:)        ! static vector potential
    FLOAT, pointer :: A_gauge(:)           ! gauge vector potential
    FLOAT, pointer :: A_gauge_dot(:)       ! dA_gauge/dt
    FLOAT, pointer :: A_gauge_ddot(:)      ! d^2A_gauge/dt^2
    logical :: with_gauge_field            ! true if A_gauge(:) is used

    integer :: reltype            ! type of relativistic correction to use

    ! The gyromagnetic ratio (-2.0 for the electron, but different if we treat
    ! *effective* electrons in a quantum dot. It affects the spin Zeeman term.
    FLOAT :: gyromagnetic_ratio
    
    FLOAT :: eii
    FLOAT, pointer :: fii(:, :)

  end type epot_t

  integer, public, parameter :: &
    NOREL      = 0,             &
    SPIN_ORBIT = 1,             &
    APP_ZORA   = 2,             &
    ZORA       = 3

contains

  ! ---------------------------------------------------------
  subroutine epot_init(ep, gr, geo, ispin)
    type(epot_t),     intent(out)   :: ep
    type(grid_t),     intent(in)    :: gr
    type(geometry_t), intent(inout) :: geo
    integer,          intent(in)    :: ispin

    integer :: i
    type(block_t) :: blk
    FLOAT, allocatable :: x(:)
    logical :: filter

    call push_sub('epot.epot_init')

    !%Variable FilterPotentials
    !%Type integer
    !%Default no
    !%Section Hamiltonian
    !%Description
    !% If set to yes, octopus filters the pseudopotentials so that they no
    !% longer contain Fourier components larger than the mesh itself. This is
    !% very useful to decrease the egg-box effect, and so should be used in
    !% all instances where atoms move.
    !%Option yes 1
    !% Turn on filtering of the pseudopotentials
    !%Option no 0
    !% Turn off filtering of the pseudopotentials
    !%End
    call loct_parse_logical(check_inp('FilterPotentials'), .false., filter)

    if(filter) then
      message(1) = 'Info: filtering the potentials.'
      call write_info(1)
    end if
    
    do i = 1, geo%nspecies
      call specie_pot_init(geo%specie(i), gr, filter)
    end do

    ! Local part of the pseudopotentials
    ALLOCATE(ep%vpsl(NP), NP)
    !$omp parallel workshare
    ep%vpsl(1:NP) = M_ZERO
    !$omp end parallel workshare

    ep%classic_pot = 0
    if(geo%ncatoms > 0) then

      !%Variable ClassicPotential
      !%Type integer
      !%Default 0
      !%Section Hamiltonian
      !%Description
      !% If <tt>true</tt>, add to the external potential the potential generated by 
      !% the point charges read from the PDB input (see <tt>PBDCoordinates</tt>).
      !%End
      call loct_parse_int(check_inp('ClassicPotential'), 0, ep%classic_pot)
      if(ep%classic_pot > 0) then
        message(1) = 'Info: generating classic external potential'
        call write_info(1)

        ALLOCATE(ep%Vclassic(NP), NP)
        call epot_generate_classic(ep, gr%m, geo)
      end if
    end if

    ! lasers
    call laser_init(ep%no_lasers, ep%lasers, gr%m)

    ! No more "UserDefinedTDPotential" from this version on.
    call obsolete_variable('UserDefinedTDPotential', 'TDExternalFields')

    !%Variable StaticElectricField
    !%Type block
    !%Section Hamiltonian
    !%Description
    !% A static constant electrical field may be added to the usual Hamiltonian,
    !% by setting the block StaticElectricField.
    !% The three possible components of the block (which should only have one
    !% line) are the three components of the electrical field vector.
    !%End
    nullify(ep%E_field, ep%v_static)
    if(loct_parse_block(check_inp('StaticElectricField'), blk)==0) then
      ALLOCATE(ep%E_field(NDIM), NDIM)
      do i = 1, NDIM
        call loct_parse_block_float(blk, 0, i-1, ep%E_field(i))
      end do
      call loct_parse_block_end(blk)

      ep%E_field(:) = ep%E_field(:) * units_inp%energy%factor/units_inp%length%factor
      
      ! Compute the scalar potential
      ALLOCATE(ep%v_static(NP), NP)
      do i = 1, NP
        ep%v_static(i) = sum(gr%m%x(i,:)*ep%E_field(:))
      end do
    end if

    !%Variable StaticMagneticField
    !%Type block
    !%Section Hamiltonian
    !%Description
    !% A static constant magnetic field may be added to the usual Hamiltonian,
    !% by setting the block StaticMagneticField. 
    !% The three possible components of the block (which should only have one
    !% line) are the three components of the magnetic field vector. Note that
    !% if you are running the code in 1D mode this will not work, and if you
    !% are running the code in 2D mode the magnetic field will have to be in
    !% the z-direction, so that the first two columns should be zero.
    !%
    !% The magnetic field should always be entered in atomic units, regardless
    !% of the "Units" variable. Note that we use the "Gaussian" system
    !% meaning 1 au[B] = 1.7152553 * 10^7 gauss, which corresponds to
    !% 1.7152553 * 10^3 Tesla.
    !%End
    nullify(ep%B_field, ep%A_static)
    if(loct_parse_block(check_inp('StaticMagneticField'), blk)==0) then

      ALLOCATE(ep%B_field(3), 3)
      do i = 1, 3
        call loct_parse_block_float(blk, 0, i-1, ep%B_field(i))
      end do
      select case(calc_dim)
      case(1)
        call input_error('StaticMagneticField')
      case(2)
        if(ep%B_field(1)**2+ep%B_field(2)**2 > M_ZERO) call input_error('StaticMagneticField')
      end select
      call loct_parse_block_end(blk)

      ! Compute the vector potential
      ALLOCATE(ep%A_static(NP, NDIM), NP*NDIM)
      ALLOCATE(x(NDIM), NDIM)
      do i = 1, NP
        x(1:NDIM) = gr%m%x(i, 1:NDIM)
        select case (NDIM)
        case (2)
          ep%A_static(i, :) = (/x(2), -x(1)/)*ep%B_field(3)
        case (3)
          ep%A_static(i, :) = (/x(2)*ep%B_field(3) - x(3)*ep%B_field(2), &
            x(3)*ep%B_field(1) - x(1)*ep%B_field(3), x(1)*ep%B_field(2) - x(2)*ep%B_field(1)/)
        end select
      end do
      deallocate(x)
      ep%A_static = -M_HALF/P_c*ep%A_static

    end if
    
    !%Variable GaugeVectorField
    !%Type block
    !%Section Hamiltonian
    !%Description
    !% The gauge vector field is used to include a uniform (but time dependent)
    !% external electric field in a time dependent run for a periodic system
    !% By default this field is kept null.
    !%End
    ! Read the initial gauge vector field
    ep%with_gauge_field = .false.
    nullify(ep%A_gauge, ep%A_gauge_dot, ep%A_gauge_ddot)
    if(simul_box_is_periodic(gr%sb)) then
      if(loct_parse_block(check_inp('GaugeVectorField'), blk) == 0) then
        ep%with_gauge_field = .true.
        ALLOCATE(ep%A_gauge(NDIM), NDIM)
        ALLOCATE(ep%A_gauge_dot(NDIM), NDIM)
        ALLOCATE(ep%A_gauge_ddot(NDIM), NDIM)
        ep%A_gauge = M_ZERO
	ep%A_gauge_dot = M_ZERO
	ep%A_gauge_ddot = M_ZERO
	do i = 1, NDIM
          call loct_parse_block_float(blk, 0, i-1, ep%A_gauge(i))
	end do
	call loct_parse_block_end(blk)
      end if
    end if
    
    !%Variable GyromagneticRatio
    !%Type float
    !%Default 2.0023193043768
    !%Section Hamiltonian
    !%Description
    !% The gyromagnetic ratio of the electron. This is of course a physical 
    !% constant, and the default value is the exact one that you should not 
    !% touch, unless : 
    !% 
    !% (i)  You want to disconnect the anomalous Zeeman term in the Hamiltonian 
    !% (then set it to zero, this number only affects this term);
    !% 
    !% (ii) You are using an effective Hamiltonian, as it is the case when
    !% you calculate a 2D electron gas, in which case you have an effective
    !% gyromagnetic factor that depends on the material.
    !%End
    call loct_parse_float(check_inp('GyromagneticRatio'), P_g, ep%gyromagnetic_ratio)

    !%Variable RelativisticCorrection
    !%Type integer
    !%Default non_relativistic
    !%Section Hamiltonian
    !%Description
    !% The default value means that <i>no</i> relativistic correction is used. To
    !% include spin-orbit coupling turn <tt>RelativisticCorrection</tt> to <tt>spin_orbit</tt> 
    !% (this will only work if <tt>SpinComponents</tt> has been set to <tt>non_collinear</tt>, which ensures
    !% the use of spinors).
    !%Option non_relativistic 0
    !% No relativistic corrections.
    !%Option spin_orbit 1
    !% Spin-Orbit.
    !%Option app_zora 2
    !% Approximated ZORA (Not implemented)
    !%Option zora 3
    !% ZORA (Not implemented)
    !%End
    call loct_parse_int(check_inp('RelativisticCorrection'), NOREL, ep%reltype)
    if(.not.varinfo_valid_option('RelativisticCorrection', ep%reltype)) call input_error('RelativisticCorrection')
    if (ispin /= SPINORS .and. ep%reltype == SPIN_ORBIT) then
      message(1) = "The Spin-orbit term can only be applied when using Spinors."
      call write_fatal(1)
    end if
    ! This is temporary...
    if(ep%reltype > SPIN_ORBIT) then
      message(1) = 'Error: ZORA corrections not implemented.'
      call write_fatal(1)
    end if
    call messages_print_var_option(stdout, "RelativisticCorrection", ep%reltype)
    
    ! The projectors
    ep%nvnl = geometry_nvnl(geo)
    
    nullify(ep%p)
    
    if(ep%nvnl > 0) then
      ALLOCATE(ep%p(ep%nvnl), ep%nvnl)

      do i = 1, ep%nvnl
        call projector_null(ep%p(i))
      end do

    end if
    
    ALLOCATE(ep%atomproj(1:2, geo%natoms), 2*geo%natoms)
    
    ep%atomproj(1, :) = 0
    ep%atomproj(2, :) = -1

    ALLOCATE(ep%fii(1:MAX_DIM, 1:geo%natoms), MAX_DIM*geo%natoms)

    call pop_sub()
  end subroutine epot_init


  ! ---------------------------------------------------------
  subroutine epot_end(ep, gr, geo)
    type(epot_t),      intent(inout) :: ep
    type(grid_t),      intent(in)    :: gr
    type(geometry_t),  intent(inout) :: geo

    integer :: i, iproj

    call push_sub('epot.epot_end')

    deallocate(ep%fii)

    do i = 1, geo%nspecies
      call specie_pot_end(geo%specie(i), gr)
    end do

    if(associated(ep%vpsl)) then
      deallocate(ep%vpsl)
      nullify(ep%vpsl)
    end if

    if(ep%classic_pot > 0) then
      ep%classic_pot = 0
      ! sanity check
      ASSERT(associated(ep%Vclassic)) 
      deallocate(ep%Vclassic)         ! and clean up
      nullify(ep%Vclassic)
    end if

    ! the external laser
    call laser_end(ep%no_lasers, ep%lasers)

    ! the macroscopic fields
    if(associated(ep%E_field))  deallocate(ep%E_field)
    if(associated(ep%v_static)) deallocate(ep%v_static)
    if(associated(ep%B_field))  deallocate(ep%B_field)
    if(associated(ep%A_static)) deallocate(ep%A_static)
    if(associated(ep%A_gauge)) deallocate(ep%A_gauge)
    if(associated(ep%A_gauge_dot)) deallocate(ep%A_gauge_dot)
    if(associated(ep%A_gauge_ddot)) deallocate(ep%A_gauge_ddot)

    if(ep%nvnl>0) then
      do iproj = 1, ep%nvnl
        call projector_end(ep%p(iproj))
      end do

      ASSERT(associated(ep%p))
      deallocate(ep%p)
    end if

    deallocate(ep%atomproj)

    call pop_sub()

  end subroutine epot_end

  ! ---------------------------------------------------------
  subroutine epot_generate_gauge_field(ep, gr, st)
    type(epot_t),      intent(inout) :: ep
    type(grid_t),      intent(inout) :: gr
    type(states_t),    intent(inout) :: st
    
    integer :: ispin
    FLOAT :: n_el, omega2

    call push_sub('epot.epot_generate_gauge_field')
    
    ASSERT(st%wfs_type == M_CMPLX)
    
    ! Integrate the charge density
    n_el = M_ZERO
    do ispin = 1, st%d%spin_channels
      n_el = n_el + dmf_integrate(gr%m, st%rho(1:NP,ispin))
    end do
    
    omega2 = M_FOUR*M_PI*P_c*n_el/gr%sb%rcell_volume
    !call calc_paramagnetic_current(gr, st, jp)
    
    ! DEBUG
    ! Harmonic oscillator
    ep%A_gauge_ddot(1:NDIM) = -omega2*ep%A_gauge(1:NDIM)
    !write(*,'(a,3f12.6)')'OUT: A = ',ep%A_gauge(1:NDIM)
    !write(*,'(a,3f12.6)')'OUT: dA/dt = ',ep%A_gauge_dot(1:NDIM)
    !write(*,'(a,3f12.6)')'OUT: d^2A/dt^2 = ',ep%A_gauge_ddot(1:NDIM)
    ! END DEBUG
       
    call pop_sub()
  
  end subroutine epot_generate_gauge_field
  
  ! ---------------------------------------------------------
  subroutine epot_generate(ep, gr, geo, mc, st, time)
    type(epot_t),      intent(inout) :: ep
    type(grid_t), target,  intent(inout) :: gr
    type(geometry_t),  intent(inout) :: geo
    type(multicomm_t), intent(in)    :: mc
    type(states_t),    intent(inout) :: st
    FLOAT,   optional, intent(in)    :: time

    FLOAT   :: time_
    integer :: ia, l, lm, iproj
    type(atom_t),   pointer :: atm

    type(mesh_t),      pointer :: m
    type(simul_box_t), pointer :: sb
    type(submesh_t)  :: nl_sphere
    type(profile_t), save :: epot_generate_prof

#ifdef HAVE_MPI
    FLOAT,    allocatable :: vpsltmp(:)
    type(profile_t), save :: epot_reduce
#endif

    call profiling_in(epot_generate_prof, "EPOT_GENERATE")
    call push_sub('epot.epot_generate')

    sb  => gr%sb
    m   => gr%m

    time_ = M_ZERO
    if (present(time)) time_ = time

    ! Local.
    ep%vpsl = M_ZERO
    do ia = geo%atoms_start, geo%atoms_end
      call epot_local_potential(ep, gr, geo, geo%atom(ia), ep%vpsl, time_, st%rho_core)
    end do

#ifdef HAVE_MPI
    call profiling_in(epot_reduce, "EPOT_REDUCE")
    if(geo%parallel_in_atoms) then
      ALLOCATE(vpsltmp(1:NP), NP)
      call MPI_Allreduce(ep%vpsl, vpsltmp, NP, MPI_FLOAT, MPI_SUM, geo%mpi_grp%comm, mpi_err)
      call lalg_copy(NP, vpsltmp, ep%vpsl)
      deallocate(vpsltmp)
    end if
    call profiling_out(epot_reduce)
#endif

    ! we assume that we need to recalculate the ion_ion energy
    call ion_ion_interaction(ep, gr, sb, geo)

    if(ep%nvnl > 0) then
      ! Local.
      ! the pseudo potential part.
      iproj = 1
      do ia = 1, geo%natoms
        atm => geo%atom(ia)

        if(.not. specie_is_ps(atm%spec)) cycle

        ep%atomproj(1, ia) = iproj

        call submesh_init_sphere(nl_sphere, sb, m, atm%x, atm%spec%ps%rc_max + m%h(1))

        do l = 0, atm%spec%ps%l_max
          if(atm%spec%ps%l_loc == l) cycle
          do lm = -l, l

            call projector_end(ep%p(iproj))
            call submesh_copy(nl_sphere, ep%p(iproj)%sphere)
            call projector_init(ep%p(iproj), atm, ep%reltype, l, lm)

            if(simul_box_is_periodic(sb)) &
              call projector_init_phases(ep%p(iproj), gr%m, st%d%nik, st%d%kpoints)

            ep%p(iproj)%iatom = ia
            iproj = iproj + 1
          end do
        end do

        call submesh_end(nl_sphere)

        ep%atomproj(2, ia) = iproj - 1

      end do
    end if

    do iproj = 1, ep%nvnl
      call projector_build(ep%p(iproj), gr, geo%atom(ep%p(iproj)%iatom))
    end do

    if (ep%classic_pot > 0) then
      ep%vpsl(1:m%np) = ep%vpsl(1:m%np) + ep%vclassic(1:m%np)
    end if

    call pop_sub()
    call profiling_out(epot_generate_prof)

  end subroutine epot_generate

  subroutine epot_local_potential(ep, gr, geo, a, vpsl, time, rho_core)
    type(epot_t),             intent(in)    :: ep
    type(grid_t),             intent(inout) :: gr
    type(geometry_t),         intent(in)    :: geo
    type(atom_t),             intent(inout) :: a
    FLOAT,                    intent(inout) :: vpsl(:)
    FLOAT,                    intent(in)    :: time
    FLOAT,          optional, pointer       :: rho_core(:)

    integer :: i
    FLOAT :: x(MAX_DIM), radius
    FLOAT, allocatable  :: rho(:), vl(:)
    type(submesh_t)  :: sphere
    type(profile_t), save :: prof
    
    call push_sub('epot.epot_local_potential')
    call profiling_in(prof, "EPOT_LOCAL")

    ALLOCATE(vl(1:NP_PART), NP_PART)
#ifdef USE_OMP
    !$omp parallel workshare
    vl(1:NP) = M_ZERO
    !$omp end parallel workshare
#endif

    !Local potential, we can get it by solving the poisson equation
    !(for all electron species or pseudopotentials in periodic
    !systems) or by applying it directly to the grid

    if(a%spec%has_density .or. (specie_is_ps(a%spec) .and. simul_box_is_periodic(gr%sb))) then

      ALLOCATE(rho(1:NP), NP)

      !this has to be optimized so the poisson solution is made once
      !for all species, perhaps even include it in the hartree term
      call specie_get_density(a%spec, a%x, gr, geo, rho)

      vl(1:NP) = M_ZERO   ! vl has to be initialized before entering routine
      ! and our best guess for the potential is zero
      call dpoisson_solve(gr, vl, rho)

      deallocate(rho)

    else

      !Local potential
      call specie_get_local(a%spec, gr, a%x(1:NDIM), vl, time)

    end if

    !$omp parallel workshare
    vpsl(1:NP) = vpsl(1:NP) + vl(1:NP)
    !$omp end parallel workshare

    !the localized part
    if(specie_is_ps(a%spec)) then

      radius = double_grid_get_rmax(gr%dgrid, a%spec, gr%m) + gr%m%h(1)

      call submesh_init_sphere(sphere, gr%sb, gr%m, a%x, radius)
      call double_grid_apply_local(gr%dgrid, a%spec, gr%m, sphere, a%x, vl(1:sphere%ns))

      vpsl(sphere%jxyz(1:sphere%ns)) = vpsl(sphere%jxyz(1:sphere%ns)) + vl(1:sphere%ns)
      call submesh_end(sphere)

    end if

    deallocate(vl)

    !Non-local core corrections
    if(present(rho_core) .and. a%spec%nlcc .and. specie_is_ps(a%spec)) then
      do i = 1, NP
        x(1:NDIM) = gr%m%x(i, 1:NDIM) - a%x(1:NDIM)
        rho_core(i) = rho_core(i) + specie_get_nlcc(a%spec, x)
      end do
    end if

    call profiling_out(prof)
    call pop_sub()
  end subroutine epot_local_potential


  ! ---------------------------------------------------------
  subroutine epot_generate_classic(ep, m, geo)
    type(epot_t),     intent(inout) :: ep
    type(mesh_t),     intent(in)    :: m
    type(geometry_t), intent(in)    :: geo

    integer i, ia
    FLOAT :: r, rc

    call push_sub('epot.epot_generate_classic')

    ep%Vclassic = M_ZERO
    do ia = 1, geo%ncatoms
      do i = 1, m%np
        call mesh_r(m, i, r, a=geo%catom(ia)%x)
        select case(ep%classic_pot)
        case(1) ! point charge
          if(r < r_small) r = r_small
          ep%Vclassic(i) = ep%Vclassic(i) - geo%catom(ia)%charge/r
        case(2) ! gaussion smeared charge
          select case(geo%catom(ia)%label(1:1)) ! covalent radii
          case('H')
            rc = CNST(0.4)*P_Ang
          case('C')
            rc = CNST(0.8)*P_Ang
          case default
            rc = CNST(0.7)*P_Ang
          end select
          if(abs(r - rc) < r_small) r = rc + sign(r_small, r-rc)
          ep%Vclassic(i) = ep%Vclassic(i) - geo%catom(ia)%charge*(r**4 - rc**4)/(r**5 - rc**5)
        end select
      end do
    end do

    call pop_sub()
  end subroutine epot_generate_classic


  ! ---------------------------------------------------------
  subroutine epot_forces(gr, geo, ep, st, t)
    type(grid_t),     intent(inout) :: gr
    type(geometry_t), intent(inout)  :: geo
    type(epot_t),     intent(in)     :: ep
    type(states_t),   intent(inout)     :: st
    FLOAT,     optional, intent(in)    :: t

    integer :: i, j
    FLOAT :: x(MAX_DIM), time
    
    type(profile_t), save :: forces_prof

    call profiling_in(forces_prof, "FORCES")
    call push_sub('epot.epot_forces')

    time = M_ZERO
    if(present(t)) time = t

    ! the ion-ion term is already calculated
    do i = 1, geo%natoms
      geo%atom(i)%f(1:MAX_DIM) = ep%fii(1:MAX_DIM, i)
    end do
    
    if (wfs_are_real(st) ) then 
      call dcalc_forces_from_potential(gr, geo, ep, st, time)
    else
      call zcalc_forces_from_potential(gr, geo, ep, st, time)
    end if
    
    !TODO: forces due to the magnetic fields (static and time-dependent)
    if(present(t)) then
      do j = 1, ep%no_lasers
        select case(ep%lasers(j)%field)
        case(E_FIELD_ELECTRIC)
          call laser_field(gr%sb, ep%lasers(j), x, t)
          do i = 1, geo%natoms
            geo%atom(i)%f(1:NDIM) = geo%atom(i)%f(1:NDIM) + geo%atom(i)%spec%z_val*x(1:NDIM)
          end do
        case(E_FIELD_MAGNETIC, E_FIELD_VECTOR_POTENTIAL, E_FIELD_SCALAR_POTENTIAL)
          write(message(1),'(a)') 'The forces are currently not properly calculated if time-dependent'
          write(message(2),'(a)') 'magnetic fields are present.'
          call write_fatal(2)
        end select
      end do
    end if

    if(associated(ep%E_field)) then
      do i = 1, geo%natoms
        geo%atom(i)%f(1:NDIM) = geo%atom(i)%f(1:NDIM) + geo%atom(i)%spec%Z_val * ep%E_field(1:NDIM)
      end do
    end if
    
    call pop_sub()
    call profiling_out(forces_prof)

  end subroutine epot_forces

  ! ---------------------------------------------------------
  subroutine ion_ion_interaction(ep, gr, sb, geo)
    type(epot_t),              intent(inout) :: ep
    type(grid_t),              intent(inout) :: gr
    type(simul_box_t),         intent(in)    :: sb
    type(geometry_t),  target, intent(in)    :: geo

    type(specie_t), pointer :: s
    FLOAT :: r, rc, xi(1:MAX_DIM), dd, zi, zj
    FLOAT, allocatable :: vns(:), vpslc(:), xx(:, :), vxx(:), gv(:, :), gxx(:, :)
    integer :: iatom, jatom, icopy, idir
    type(periodic_copy_t) :: pc

    type(profile_t), save :: ion_ion_prof

    call profiling_in(ion_ion_prof, "ION_ION_INTERACTION")

    ep%eii = M_ZERO
    ep%fii = M_ZERO

    ! see
    ! http://www.tddft.org/programs/octopus/wiki/index.php/Developers:Ion-Ion_interaction
    ! for details about this routine.

    ! Note that a possible jellium-jellium interaction (the case where more
    ! than one jellium species is present) is not properly calculated.
    ! But if only one jellium sphere is present, it correctly calculates its
    ! electrostatic energy. I do not know right now if there is a closed
    ! analytical expression for the electrostatic energy of a system of two
    ! uniformly charged spheres.

    ! interaction inside the cell, calculated directly
    do iatom = 1, geo%natoms
      s => geo%atom(iatom)%spec
      zi = geo%atom(iatom)%spec%z_val

      if(s%type .eq. SPEC_JELLI) then
        ep%eii = ep%eii + (M_THREE/M_FIVE)*s%z_val**2/s%jradius
      end if

      do jatom = 1, geo%natoms

        if(iatom == jatom) cycle

        zj = geo%atom(jatom)%spec%z_val
        r = sqrt(sum((geo%atom(iatom)%x - geo%atom(jatom)%x)**2))

        !the force
        dd = zi*zj/r**3
        ep%fii(1:MAX_DIM, iatom) = ep%fii(1:MAX_DIM, iatom) + dd*(geo%atom(iatom)%x(1:MAX_DIM) - geo%atom(jatom)%x(1:MAX_DIM))

        !energy
        if(jatom > iatom) cycle
        ep%eii = ep%eii + zi*zj/r
        
      end do !jatom
      
    end do !iatom

    ! if the system is periodic we have to add the energy of the
    ! interaction with the copies
    if(simul_box_is_periodic(sb)) then

      ! the short range part is calculated directly
      do iatom = 1, geo%natoms
        s => geo%atom(iatom)%spec
        if (.not. specie_is_ps(s)) cycle

        rc = loct_spline_cutoff_radius(s%ps%vion, s%ps%projectors_sphere_threshold)
        rc = max(rc, loct_spline_cutoff_radius(s%ps%dvion, s%ps%projectors_sphere_threshold))

        call periodic_copy_init(pc, sb, geo%atom(iatom)%x, rc)

        do icopy = 1, periodic_copy_num(pc)

          xi = periodic_copy_position(pc, sb, icopy)

          ! do not consider atoms inside the cell
          if ( maxval(abs(xi(1:MAX_DIM) - geo%atom(iatom)%x(1:MAX_DIM))) < M_TEN*M_EPSILON ) cycle

          do jatom = 1, geo%natoms
            zj = -geo%atom(jatom)%spec%z_val
            r = sqrt( sum( (xi - geo%atom(jatom)%x)**2 ) )
            ! energy
            ep%eii = ep%eii + M_HALF*zj*loct_splint(s%ps%vion, r)
            ! force
            ep%fii(1:MAX_DIM, jatom) = ep%fii(1:MAX_DIM, jatom) + &
              M_HALF*zj*loct_splint(s%ps%dvion, r)/r*(geo%atom(jatom)%x(1:MAX_DIM) - xi(1:MAX_DIM))
          end do
          
        end do
        
        call periodic_copy_end(pc)
        
      end do

      ! And the long range part, using the potential that was already
      ! calculated via poisson equation

      ALLOCATE(vns(1:NP), NP)
      ALLOCATE(vpslc(1:NP_PART), NP_PART)
      ALLOCATE(gv(1:NP_PART, 1:MAX_DIM), NP_PART*MAX_DIM)
      ALLOCATE(xx(1:geo%natoms, 1:MAX_DIM), geo%natoms*MAX_DIM)
      ALLOCATE(vxx(1:geo%natoms), geo%natoms)
      ALLOCATE(gxx(1:geo%natoms, 1:MAX_DIM), geo%natoms*MAX_DIM)

      vpslc(1:NP) = ep%vpsl(1:NP)

      ! Remove the potential generated by atoms _in_ the cell, to only
      ! leave the potential due to the periodic copies.
      do iatom = 1, geo%natoms
        vns = M_ZERO
        call specie_get_local(geo%atom(iatom)%spec, gr, geo%atom(iatom)%x, vns)
        call lalg_axpy(NP, -M_ONE, vns, vpslc)
        xx(iatom, 1:MAX_DIM) = geo%atom(iatom)%x(1:MAX_DIM)
      end do
      
      call df_gradient(gr%sb, gr%f_der, vpslc, gv)

      ! interpolate in the atomic positions, boundary conditions must
      ! be updated properly before
      call dmf_interpolate_points(gr%m, vpslc, geo%natoms, xx, vxx)

      gxx = M_ZERO
      do idir = 1, sb%dim
        call dset_bc(gr%f_der%der_discr, gv(:, idir))
        call dmf_interpolate_points(gr%m, gv(:, idir), geo%natoms, xx, gxx(:, idir))
      end do

      ! Now calculate the interaction
      do iatom = 1, geo%natoms
        zi = -geo%atom(iatom)%spec%z_val
        ! energy
        ep%eii = ep%eii + M_HALF*zi*vxx(iatom)
        ! force
        ep%fii(1:MAX_DIM, iatom) = ep%fii(1:MAX_DIM, iatom) + M_HALF*zi*gxx(iatom, 1:MAX_DIM)
      end do

      deallocate(vns, vpslc, xx, vxx, gv, gxx)

    end if

    call profiling_out(ion_ion_prof)
  end subroutine ion_ion_interaction

#include "undef.F90"
#include "real.F90"
#include "epot_inc.F90"

#include "undef.F90"
#include "complex.F90"
#include "epot_inc.F90"

end module external_pot_m



!! Local Variables:
!! mode: f90
!! coding: utf-8
!! End:
