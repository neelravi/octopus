!! Copyright (C) 2004 Xavier Andrade, M. Marques
!!
!! This program is free software; you can redistribute it and/or modify
!! it under the terms of the GNU General Public License as published by
!! the Free Software Foundation; either version 2, or (at your option)
!! any later version.
!!
!! This program is distributed in the hope that it will be useful,
!! but WITHOUT ANY WARRANTY; without even the implied warranty of
!! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!! GNU General Public License for more details.
!!
!! You should have received a copy of the GNU General Public License
!! along with this program; if not, write to the Free Software
!! Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
!! 02111-1307, USA.
!!
!! $Id$


! ---------------------------------------------------------
! This subroutine calculates the solution of (H + omega) x = y
! ---------------------------------------------------------
subroutine X(solve_HXeY) (this, hm, gr, st, ist, ik, x, y, omega, occ_response)
  type(linear_solver_t), target, intent(inout) :: this
  type(hamiltonian_t),   target, intent(inout) :: hm
  type(grid_t),          target, intent(inout) :: gr
  type(states_t),        target, intent(in)    :: st
  integer,                       intent(in)    :: ist
  integer,                       intent(in)    :: ik
  R_TYPE,                        intent(inout) :: x(:,:)   ! x(gr%mesh%np, d%dim)
  R_TYPE,                        intent(in)    :: y(:,:)   ! y(gr%mesh%np, d%dim)
  R_TYPE,                        intent(in)    :: omega
  logical, optional,             intent(in)    :: occ_response

  logical :: occ_response_

  call push_sub('linear_solver_inc.Xsolve_HXeY')
  call profiling_in(prof, "LINEAR_SOLVER")

  occ_response_ = .true.
  if(present(occ_response)) occ_response_ = occ_response

  select case(this%solver)

  case(LS_CG)
    call X(ls_solver_cg)       (this, hm, gr, st, ist, ik, x, y, omega)

  case(LS_BICGSTAB)
    call X(ls_solver_bicgstab) (this, hm, gr, st, ist, ik, x, y, omega, occ_response_)

  case(LS_MULTIGRID)
    call X(ls_solver_multigrid)(this, hm, gr, st, ist, ik, x, y, omega)

  case(LS_QMR)
    args%ls       => this
    args%hm       => hm
    args%gr       => gr 
    args%st       => st
    args%ist      = ist
    args%ik       = ik
    args%X(omega) = omega

    this%iter = this%max_iter
    
    call X(qmr_sym)(gr%mesh%np, x(:, 1), y(:, 1), X(ls_solver_operator_na), X(ls_dotu_qmr), X(ls_nrm2_qmr), X(ls_preconditioner), &
         this%iter, residue = this%abs_psi, threshold = this%tol, showprogress = .false.)

  case(LS_SOS)
    call X(ls_solver_sos)(this, hm, gr, st, ist, ik, x, y, omega)

  case default 
    write(message(1), '(a,i2)') "Unknown linear-response solver", this%solver
    call write_fatal(1)

  end select

  call profiling_out(prof)
  call pop_sub()

end subroutine X(solve_HXeY)

FLOAT function X(ls_nrm2_qmr)(x)
  R_TYPE, intent(in) :: x(:)
  
  X(ls_nrm2_qmr) = X(mf_nrm2)(args%gr%mesh, x)
  
end function X(ls_nrm2_qmr)

R_TYPE function X(ls_dotu_qmr)(x,y)
  R_TYPE, intent(in) :: x(:)
  R_TYPE, intent(in) :: y(:)
  
  X(ls_dotu_qmr) = X(mf_dotp)(args%gr%mesh, x, y, dotu = .true.)
  
end function X(ls_dotu_qmr)

! ---------------------------------------------------------
!Conjugate gradients
subroutine X(ls_solver_cg) (ls, hm, gr, st, ist, ik, x, y, omega)
  type(linear_solver_t), intent(inout) :: ls
  type(hamiltonian_t),   intent(inout) :: hm
  type(grid_t),          intent(inout) :: gr
  type(states_t),        intent(in)    :: st
  integer,               intent(in)    :: ist
  integer,               intent(in)    :: ik
  R_TYPE,                intent(inout) :: x(:,:)   ! x(gr%mesh%np, st%d%dim)
  R_TYPE,                intent(in)    :: y(:,:)   ! y(gr%mesh%np, st%d%dim)
  R_TYPE,                intent(in)    :: omega

  R_TYPE, allocatable :: r(:,:), p(:,:), Hp(:,:)
  R_TYPE  :: alpha, beta, gamma
  integer :: iter, idim
  logical :: conv_last, conv

  call push_sub('linear_solver_inc.Xls_solver_cg')

  ALLOCATE( r(gr%mesh%np, st%d%dim),      gr%mesh%np      * st%d%dim)
  ALLOCATE( p(gr%mesh%np_part, st%d%dim), gr%mesh%np_part * st%d%dim)
  ALLOCATE(Hp(gr%mesh%np, st%d%dim),      gr%mesh%np      * st%d%dim)

  ! Initial residue
  call X(ls_solver_operator)(hm, gr, st, ist, ik, omega, x, Hp)
  r(1:gr%mesh%np, 1:st%d%dim) = y(1:gr%mesh%np, 1:st%d%dim) - Hp(1:gr%mesh%np, 1:st%d%dim)
  
  ! Initial search direction
  p(1:gr%mesh%np, 1:st%d%dim) = r(1:gr%mesh%np, 1:st%d%dim)
  p((gr%mesh%np+1):gr%mesh%np_part,1:st%d%dim) = M_ZERO
  
  conv_last = .false.
  gamma     = M_ONE
  do iter = 1, ls%max_iter
    gamma = X(mf_dotp)(gr%mesh, st%d%dim, r, r)

    conv = ( abs(gamma) < ls%tol**2)
    if(conv.and.conv_last) exit
    conv_last = conv
    
    call X(ls_solver_operator)(hm, gr, st, ist, ik, omega, p, Hp)

    alpha = gamma/X(mf_dotp) (gr%mesh, st%d%dim, p, Hp)

    do idim = 1, st%d%dim
      !r = r - alpha*Hp
      call lalg_axpy(gr%mesh%np, -alpha, Hp(:, idim), r(:, idim))
      !x = x + alpha*p
      call lalg_axpy(gr%mesh%np,  alpha,  p(:, idim), x(:, idim))
    end do


    beta = X(mf_dotp)(gr%mesh, st%d%dim, r, r)/gamma

    p(1:gr%mesh%np, 1:st%d%dim) = r(1:gr%mesh%np, 1:st%d%dim) + beta*p(1:gr%mesh%np, 1:st%d%dim)

  end do
    
  ls%iter = iter
  ls%abs_psi = sqrt(abs(gamma))

  deallocate(r, p, Hp)

  call pop_sub()
end subroutine X(ls_solver_cg)

! ---------------------------------------------------------
!BICONJUGATE GRADIENTS STABILIZED
!see http://math.nist.gov/iml++/bicgstab.h.txt
subroutine X(ls_solver_bicgstab) (ls, hm, gr, st, ist, ik, x, y, omega, occ_response)
  type(linear_solver_t),          intent(inout) :: ls
  type(hamiltonian_t), intent(inout) :: hm
  type(grid_t),        intent(inout) :: gr
  type(states_t),      intent(in)    :: st
  integer,             intent(in)    :: ist
  integer,             intent(in)    :: ik
  R_TYPE,              intent(inout) :: x(:,:)   ! x(gr%mesh%np, st%d%dim)
  R_TYPE,              intent(in)    :: y(:,:)   ! y(gr%mesh%np, st%d%dim)
  R_TYPE,              intent(in)    :: omega
  logical,             intent(in)    :: occ_response

  R_TYPE, allocatable :: r(:,:), Hp(:,:), rs(:,:), Hs(:,:), p(:,:), s(:,:)
  R_TYPE, pointer :: phat(:,:), shat(:,:)
  R_TYPE  :: alpha, beta, w, rho_1, rho_2
  logical :: conv_last, conv
  integer :: iter, idim, ip
  FLOAT :: gamma
  
  call push_sub('linear_solver_inc.Xls_solver_bicgstab')

  ALLOCATE( r(gr%mesh%np, st%d%dim),      gr%mesh%np     *st%d%dim)
  ALLOCATE( p(gr%mesh%np_part, st%d%dim), gr%mesh%np_part*st%d%dim)
  ALLOCATE(rs(gr%mesh%np, st%d%dim),      gr%mesh%np     *st%d%dim)
  ALLOCATE( s(gr%mesh%np_part, st%d%dim), gr%mesh%np_part*st%d%dim)
  ALLOCATE(Hp(gr%mesh%np, st%d%dim),      gr%mesh%np     *st%d%dim)
  ALLOCATE(Hs(gr%mesh%np, st%d%dim),      gr%mesh%np     *st%d%dim)

  ! this will store the preconditioned functions
  ALLOCATE(phat(gr%mesh%np_part, st%d%dim), gr%mesh%np_part * st%d%dim)
  ALLOCATE(shat(gr%mesh%np_part, st%d%dim), gr%mesh%np_part * st%d%dim)

  ! Initial residue
  call X(ls_solver_operator) (hm, gr, st, ist, ik, omega, x, Hp)

  forall(idim = 1:st%d%dim, ip = 1:gr%mesh%np) r(ip, idim) = y(ip, idim) - Hp(ip, idim)

  !re-orthogonalize r, this helps considerably with convergence
  if (occ_response) then
    alpha = X(mf_dotp)(gr%mesh, st%d%dim, st%X(psi)(:, :, ist, ik), r)
    do idim = 1, st%d%dim
      call lalg_axpy(gr%mesh%np, -alpha, st%X(psi)(:, idim, ist, ik), r(:, idim))
    end do
  else
    ! project RHS onto the unoccupied states
    call X(lr_orth_vector)(gr%mesh, st, r, ist, ik)
  endif
          
  do idim = 1, st%d%dim
    call lalg_copy(gr%mesh%np, r(:, idim), rs(:, idim))
  end do

  gamma = X(mf_nrm2)(gr%mesh, st%d%dim, r)

  conv_last = .false.
  do iter = 1, ls%max_iter

    rho_1 = X(mf_dotp) (gr%mesh, st%d%dim, rs, r)

    if( abs(rho_1) < M_EPSILON ) exit

    if( iter == 1 ) then
      do idim = 1, st%d%dim
        call lalg_copy(gr%mesh%np, r(:, idim), p(:, idim))
      end do
    else
      beta = rho_1/rho_2*alpha/w
      forall(idim = 1:st%d%dim, ip = 1:gr%mesh%np) p(ip, idim) = r(ip, idim) + beta*(p(ip, idim) - w*Hp(ip, idim))
    end if

    ! preconditioning 
    call X(preconditioner_apply)(ls%pre, gr, hm, p, phat, omega)
    call X(ls_solver_operator)(hm, gr, st, ist, ik, omega, phat, Hp)
    
    alpha = rho_1/X(mf_dotp)(gr%mesh, st%d%dim, rs, Hp)

    forall(idim = 1:st%d%dim, ip = 1:gr%mesh%np) s(ip, idim) = r(ip, idim) - alpha*Hp(ip, idim)

    gamma = X(mf_nrm2) (gr%mesh, st%d%dim, s)

    if( gamma < ls%tol ) then
      do idim = 1, st%d%dim 
        call lalg_axpy(gr%mesh%np, alpha, phat(:, idim), x(:, idim))
      end do
      exit
    end if

    call X(preconditioner_apply)(ls%pre, gr, hm, s, shat, omega)
    call X(ls_solver_operator)(hm, gr, st, ist, ik, omega, shat, Hs)

    w = X(mf_dotp)(gr%mesh, st%d%dim, Hs, s)/X(mf_dotp) (gr%mesh, st%d%dim, Hs, Hs)

    forall(idim = 1:st%d%dim, ip = 1:gr%mesh%np)
      x(ip, idim) = x(ip, idim) + alpha*phat(ip, idim) + w*shat(ip, idim)
      r(ip, idim) = s(ip, idim) - w*Hs(ip, idim)
    end forall

    rho_2 = rho_1

    gamma = X(mf_nrm2)(gr%mesh, st%d%dim, r)
    conv = (gamma < ls%tol)

    if( conv .and. conv_last ) then 
      exit
    end if
    conv_last = conv

    if( abs(w) < M_EPSILON ) exit

  end do

  ls%iter = iter
  ls%abs_psi = gamma

  deallocate(r, p, Hp, s, rs, Hs)
  deallocate(phat, shat)

  call pop_sub()
end subroutine X(ls_solver_bicgstab)


! ---------------------------------------------------------
subroutine X(ls_solver_multigrid) (ls, hm, gr, st, ist, ik, x, y, omega)
  type(linear_solver_t), intent(inout) :: ls
  type(hamiltonian_t),   intent(inout) :: hm
  type(grid_t),          intent(inout) :: gr
  type(states_t),        intent(in)    :: st
  integer,               intent(in)    :: ist
  integer,               intent(in)    :: ik
  R_TYPE,                intent(inout) :: x(:,:)   ! x(gr%mesh%np, st%d%dim)
  R_TYPE,                intent(in)    :: y(:,:)   ! y(gr%mesh%np, st%d%dim)
  R_TYPE,                intent(in)    :: omega

  R_TYPE, allocatable :: diag(:,:), hx(:,:), res(:,:)
  integer :: iter

  call push_sub('linear_solver_inc.Xls_solver_multigrid')

  ALLOCATE(diag(gr%mesh%np, st%d%dim), gr%mesh%np * st%d%dim)
  ALLOCATE(hx(gr%mesh%np, st%d%dim), gr%mesh%np * st%d%dim)
  ALLOCATE(res(gr%mesh%np, st%d%dim), gr%mesh%np * st%d%dim)

  call X(hamiltonian_diagonal)(hm, gr, diag, ik)
  diag(1:gr%mesh%np, 1:st%d%dim) = diag(1:gr%mesh%np, 1:st%d%dim) + omega

  do iter = 1, ls%max_iter

    call smoothing(3)

    call smoothing(3)

    !calculate the residue
    call X(ls_solver_operator)(hm, gr, st, ist, ik, omega, x, hx)
    res(1:gr%mesh%np, 1:st%d%dim) = hx(1:gr%mesh%np, 1:st%d%dim) - y(1:gr%mesh%np, 1:st%d%dim)
    ls%abs_psi = X(mf_nrm2)(gr%mesh, st%d%dim, res)

    if(ls%abs_psi < ls%tol) exit

    if(in_debug_mode) then 
      write(message(1), *)  "Multigrid: iter ", iter,  ls%abs_psi, abs(X(mf_dotp)(gr%mesh, st%d%dim, st%X(psi)(:, :, ist, ik), x))
      call write_info(1)
    end if

  end do

  ls%iter = iter

  call pop_sub()

contains 

  subroutine smoothing(steps)
    integer, intent(in) :: steps

    integer :: ii, ip, idim
    R_TYPE  :: rr

    do ii = 1, steps

      call X(ls_solver_operator)(hm, gr, st, ist, ik, omega, x, hx)

      do idim = 1, st%d%dim
        do ip = 1, gr%mesh%np
          rr = hx(ip, idim) - y(ip, idim)
          x(ip, idim) = x(ip, idim) - CNST(0.666666) * rr / diag(ip, idim)
        end do
      end do

    end do

    call X(lr_orth_vector)(gr%mesh, st, x, ist, ik)

  end subroutine smoothing

end subroutine X(ls_solver_multigrid)


! ---------------------------------------------------------
! This routine applies the operator hx = [H (+ Q) + omega] x
subroutine X(ls_solver_operator) (hm, gr, st, ist, ik, omega, x, hx)
  type(hamiltonian_t),   intent(inout) :: hm
  type(grid_t),          intent(inout) :: gr
  type(states_t),        intent(in)    :: st
  integer,               intent(in)    :: ist
  integer,               intent(in)    :: ik
  R_TYPE,                intent(inout) :: x(:,:)   !  x(gr%mesh%np, st%d%dim)
  R_TYPE,                intent(out)   :: Hx(:,:)  ! Hx(gr%mesh%np, st%d%dim)
  R_TYPE,                intent(in)    :: omega

  integer :: idim, jst
  FLOAT   :: alpha_j, proj, dsmear

  call push_sub('linear_solver_inc.Xls_solver_operator')

  call X(hamiltonian_apply)(hm, gr, x, Hx, ist, ik)

  !Hx = Hx + omega*x
  do idim = 1, st%d%dim
    call lalg_axpy(gr%mesh%np, omega, x(:, idim), Hx(:, idim))
  end do

  if(st%smear%fixed_occ .or. st%smear%method == SMEAR_SEMICONDUCTOR) then
    call pop_sub()
    return
  end if

  ! This is the Q term in Eq. (11) of PRB 51, 6773 (1995)
  ASSERT(.not.st%parallel_in_states)

  dsmear = max(CNST(1e-14), st%smear%dsmear)
  do jst = 1, st%nst
    alpha_j = max(st%smear%e_fermi + M_THREE * dsmear - st%eigenval(jst, ik), M_ZERO)
    if(alpha_j == M_ZERO) cycle
      
    proj = X(mf_dotp) (gr%mesh, st%d%dim, st%X(psi)(:, :, jst, ik), x)
    do idim = 1, st%d%dim
      call lalg_axpy(gr%mesh%np, R_TOTYPE(alpha_j * proj), st%X(psi)(:, idim, jst, ik), Hx(:, idim))
    end do

  end do

  call pop_sub()

end subroutine X(ls_solver_operator)


! ---------------------------------------------------------
subroutine X(ls_solver_operator_na) (x, hx)
  R_TYPE,                intent(in)    :: x(:)   !  x(gr%mesh%np, st%d%dim)
  R_TYPE,                intent(out)   :: Hx(:)  ! Hx(gr%mesh%np, st%d%dim)

  R_TYPE, allocatable :: tmpx(:, :)
  R_TYPE, allocatable :: tmpy(:, :)

  ALLOCATE(tmpx(args%gr%mesh%np_part, 1), args%gr%mesh%np_part)
  ALLOCATE(tmpy(args%gr%mesh%np, 1), args%gr%mesh%np)

  call lalg_copy(args%gr%mesh%np, x, tmpx(:, 1))
  call X(ls_solver_operator)(args%hm, args%gr, args%st, args%ist, args%ik, args%X(omega), tmpx, tmpy)
  call lalg_copy(args%gr%mesh%np, tmpy(:, 1), hx)

  deallocate(tmpx, tmpy)

end subroutine X(ls_solver_operator_na)


! ---------------------------------------------------------
subroutine X(ls_preconditioner) (x, hx)
  R_TYPE,                intent(in)    :: x(:)   !  x(gr%mesh%np, st%d%dim)
  R_TYPE,                intent(out)   :: hx(:)  ! Hx(gr%mesh%np, st%d%dim)

  R_TYPE, allocatable :: tmpx(:, :)
  R_TYPE, allocatable :: tmpy(:, :)

  call push_sub('linear_solver_inc.Xls_preconditioner')

  ALLOCATE(tmpx(args%gr%mesh%np_part, 1), args%gr%mesh%np_part)
  ALLOCATE(tmpy(args%gr%mesh%np_part, 1), args%gr%mesh%np_part)

  call lalg_copy(args%gr%mesh%np, x, tmpx(:, 1))
  call X(preconditioner_apply)(args%ls%pre, args%gr, args%hm, tmpx, tmpy, args%X(omega))
  call lalg_copy(args%gr%mesh%np, tmpy(:, 1), hx)

  deallocate(tmpx, tmpy)
  call pop_sub()

end subroutine X(ls_preconditioner)

! ---------------------------------------------------------
subroutine X(ls_solver_sos) (ls, hm, gr, st, ist, ik, x, y, omega)
  type(linear_solver_t),          intent(inout) :: ls
  type(hamiltonian_t),            intent(inout) :: hm
  type(grid_t),                   intent(inout) :: gr
  type(states_t),                 intent(in)    :: st
  integer,                        intent(in)    :: ist
  integer,                        intent(in)    :: ik
  R_TYPE,                         intent(inout) :: x(:,:)   ! x(gr%mesh%np, st%d%dim)
  R_TYPE,                         intent(in)    :: y(:,:)   ! y(gr%mesh%np, st%d%dim)
  R_TYPE,                         intent(in)    :: omega

  integer :: jst, idim
  R_TYPE  :: aa
  FLOAT   :: alpha_j, dsmear
  R_TYPE, allocatable  :: rr(:, :)

  call push_sub('linear_solver_inc.Xls_solver_sos')

  x(1:gr%mesh%np, 1:st%d%dim) = M_ZERO
  
  dsmear = max(CNST(1e-14), st%smear%dsmear)
  do jst = 1, st%nst
    alpha_j = max(st%smear%e_fermi + M_THREE*dsmear - st%eigenval(jst, ik), M_ZERO)

    aa = X(mf_dotp)(gr%mesh, st%d%dim, st%X(psi)(:, :, jst, ik), y)
    aa = aa/(st%eigenval(jst, ik) - st%eigenval(ist, ik) + alpha_j + omega)

    do idim = 1, st%d%dim
      call lalg_axpy(gr%mesh%np, aa, st%X(psi)(:, idim, jst, ik), x(:, idim))
    end do
  end do

  ! calculate the residual
  ALLOCATE(rr(1:gr%mesh%np, 1:st%d%dim), gr%mesh%np*st%d%dim)
  call X(ls_solver_operator)(hm, gr, st, ist, ik, omega, x, rr)

  do idim = 1, st%d%dim
    call lalg_axpy(gr%mesh%np, -M_ONE, y(:, idim), rr(:, idim))
  end do
  
  ls%abs_psi = X(mf_nrm2)(gr%mesh, st%d%dim, rr)
  ls%iter = 1

  deallocate(rr)
  call pop_sub()

end subroutine X(ls_solver_sos)

!! Local Variables:
!! mode: f90
!! coding: utf-8
!! End:
