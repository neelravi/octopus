!! Copyright (C) 2002-2006 M. Marques, A. Castro, A. Rubio, G. Bertsch
!!
!! This program is free software; you can redistribute it and/or modify
!! it under the terms of the GNU General Public License as published by
!! the Free Software Foundation; either version 2, or (at your option)
!! any later version.
!!
!! This program is distributed in the hope that it will be useful,
!! but WITHOUT ANY WARRANTY; without even the implied warranty of
!! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!! GNU General Public License for more details.
!!
!! You should have received a copy of the GNU General Public License
!! along with this program; if not, write to the Free Software
!! Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
!! 02110-1301, USA.
!!
!! $Id$

#include "global.h"
#define MIN_DIM 3

module index_m
  use global_m
  use hypercube_m
  use messages_m
  use simul_box_m

  implicit none

  private
  public ::                &
    index_t,               &
    index_from_coords,     &
    index_from_coords_vec, &
    index_to_coords

  type index_t
    type(hypercube_t)          :: hypercube
    logical                    :: is_hypercube     !< true if the box shape is an hypercube
    integer                    :: dim              !< the dimension
    integer                    :: nr(2, MAX_DIM)   !< dimensions of the box where the points are contained
    integer                    :: ll(MAX_DIM)      !< literally nr(2,:) - nr(1,:) + 1 - 2*enlarge(:)
    integer, pointer           :: lxyz(:,:)        !< return x, y and z for each point
    integer, pointer           :: lxyz_inv(:,:,:)  !< return points # for each xyz
    integer                    :: enlarge(MAX_DIM) !< number of points to add for boundary conditions
    integer(8)                 :: checksum
  end type index_t

contains

  !> This function takes care of the boundary conditions for a given
  !! vector of integer coordinates it returns the true _global_ index
  !! of the point.
  integer function index_from_coords(idx, ix) result(index)
    type(index_t), intent(in)    :: idx
    integer,       intent(in)    :: ix(:)

    integer :: ix2(MAX_DIM), idir

    PUSH_SUB(index_from_coords)

    forall (idir = 1:idx%dim) ix2(idir) = ix(idir)
    forall (idir = idx%dim + 1:MAX_DIM) ix2(idir) = 0

    if(.not. idx%is_hypercube) then
      index = idx%lxyz_inv(ix2(1), ix2(2), ix2(3))
    else
      call hypercube_x_to_i(idx%hypercube, idx%dim, idx%nr, idx%enlarge(1), ix, index)
    end if
    
    PUSH_SUB(index_from_coords)
  end function index_from_coords

  subroutine index_from_coords_vec(idx, npoints, ix, index)
    type(index_t), intent(in)    :: idx
    integer,       intent(in)    :: npoints
    integer,       intent(in)    :: ix(:, :)
    integer,       intent(out)   :: index(:)

    integer :: ix2(MAX_DIM), idir, ip

    PUSH_SUB(index_from_coords_vec)
    ix2 = 0

    if(.not. idx%is_hypercube) then
      do ip = 1, npoints
        forall (idir = 1:idx%dim) ix2(idir) = ix(idir, ip)
        index(ip) = idx%lxyz_inv(ix2(1), ix2(2), ix2(3))
      end do
    else
      do ip = 1, npoints
        call hypercube_x_to_i(idx%hypercube, idx%dim, idx%nr, idx%enlarge(1), ix, index(ip))
      end do
    end if
    
    POP_SUB(index_from_coords_vec)
  end subroutine index_from_coords_vec

  !> Given a _global_ point index, this function returns the set of
  !! integer coordinates of the point.
  pure subroutine index_to_coords(idx, ip, ix)
    type(index_t), intent(in)    :: idx
    integer,       intent(in)    :: ip
    integer,       intent(out)   :: ix(:)

    integer :: idir 

    ! We set all ix to zero first (otherwise the non-existent dimensions would be 
    ! undefined on exit).
    ix = 0
    if(.not. idx%is_hypercube) then
      forall (idir = 1:idx%dim) ix(idir) = idx%lxyz(ip, idir)
    else
      call hypercube_i_to_x(idx%hypercube, idx%dim, idx%nr, idx%enlarge(1), ip, ix)
    end if
  end subroutine index_to_coords

  !> This function returns .true. if the coordinates are inside the
  !! inner cube (without the enlargement).
  logical pure function coords_in_inner_cube(idx, ix) result(inside)
    type(index_t), intent(in)    :: idx
    integer,       intent(in)    :: ix(:)
    
    integer :: idir

    inside = .true.
    do idir = 1, idx%dim
      inside = inside &
           .and. (ix(idir) > idx%nr(1, idir) + idx%enlarge(idir)) &
           .and. (ix(idir) < idx%nr(2, idir) - idx%enlarge(idir))
    end do

  end function coords_in_inner_cube

end module index_m

!! Local Variables:
!! mode: f90
!! coding: utf-8
!! End:
