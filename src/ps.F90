!! Copyright (C) 2002-2006 M. Marques, A. Castro, A. Rubio, G. Bertsch
!!
!! This program is free software; you can redistribute it and/or modify
!! it under the terms of the GNU General Public License as published by
!! the Free Software Foundation; either version 2, or (at your option)
!! any later version.
!!
!! This program is distributed in the hope that it will be useful,
!! but WITHOUT ANY WARRANTY; without even the implied warranty of
!! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!! GNU General Public License for more details.
!!
!! You should have received a copy of the GNU General Public License
!! along with this program; if not, write to the Free Software
!! Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
!! 02111-1307, USA.
!!
!! -*- coding: utf-8 mode: f90 -*-
!! $Id$

#include "global.h"

module ps_m
  use global_m
  use messages_m
  use lib_oct_m
  use io_m
  use lib_oct_gsl_spline_m
  use logrid_m
  use atomic_m
  use ps_in_grid_m
  use ps_tm_m
  use ps_cpi_m
  use ps_hgh_m

  implicit none

  private
  public ::                     &
    ps_t,                       &
    ps_init,                    &
    ps_filter,                  &
    ps_getradius,               &
    ps_derivatives,             &
    ps_debug,                   &
    ps_end

  integer, parameter, public :: &
    PS_TYPE_TM2 = 100,          &
    PS_TYPE_HGH = 101,          &
    PS_TYPE_CPI = 102

  character(len=3), parameter  :: ps_name(PS_TYPE_TM2:PS_TYPE_CPI) = (/"tm2", "hgh", "cpi"/)

  type ps_t
    character(len=10) :: label
    integer           :: flavour

    type(loct_spline_t), pointer :: kb(:, :)     ! Kleynman-Bylander projectors
    type(loct_spline_t), pointer :: so_kb(:, :)
    type(loct_spline_t), pointer :: dkb(:, :)    ! derivatives of KB projectors
    type(loct_spline_t), pointer :: so_dkb(:, :)
    type(loct_spline_t), pointer :: Ur(:, :)     ! atomic wavefunctions
    type(loct_spline_t) :: vl                    ! local part
    type(loct_spline_t) :: vlocalized            ! The localized part of the local part :)
    type(loct_spline_t) :: vlocal_f              ! localized part of local potential
    ! in Fourier space (for periodic)
    type(loct_spline_t) :: dvl                   ! derivative of the local part
    type(loct_spline_t) :: core                  ! core charge

    type(logrid_t) :: g

    integer  :: ispin    ! Consider spin (ispin = 2) or not (ispin = 1)
    integer  :: kbc      ! Number of KB components (1 for TM ps, 3 for HGH)

    FLOAT    :: z, z_val

    integer  :: l_max    ! maximum value of l to take
    integer  :: l_loc    ! which component to take as local
    integer  :: so_l_max ! obvious meaning ;)

    type(valconf_t)  :: conf

    character(len=4) :: icore
    FLOAT :: rc_max
    FLOAT :: a_erf ! the a constant in erf(ar)/r

    FLOAT, pointer :: dknrm(:) ! KB norm
    FLOAT, pointer :: so_dknrm(:)
    FLOAT, pointer :: h(:,:,:), k(:, :, :)
  end type ps_t

  FLOAT, parameter :: eps = CNST(1.0e-8)

contains


  ! ---------------------------------------------------------
  subroutine ps_init(ps, label, flavour, z, lmax, lloc, ispin)
    type(ps_t),        intent(out) :: ps
    character(len=10), intent(in)  :: label
    integer,           intent(in)  :: flavour
    integer,           intent(in)  :: lmax, lloc, ispin
    FLOAT,             intent(in)  :: z

    type(ps_tm_t)  :: ps_tm  ! In case Troullier-Martins ps are used.
    type(ps_cpi_t) :: ps_cpi ! Fritz-haber pseudopotential
    type(hgh_t)    :: psp    ! In case Hartwigsen-Goedecker-Hutter ps are used.

    FLOAT :: r
    FLOAT, allocatable :: y(:)
    integer :: i

    call push_sub('ps.ps_init')

    ! Sets the flavour, label, and number of spin channels.
    ps%flavour = flavour
    ps%label   = label
    ps%ispin   = ispin

    ! Initialization and processing.
    ASSERT(flavour==PS_TYPE_TM2.or.flavour==PS_TYPE_HGH.or.flavour==PS_TYPE_CPI)

    select case(flavour)
    case(PS_TYPE_TM2)
      call ps_tm_init(ps_tm, trim(label), ispin)

      call valconf_copy(ps%conf, ps_tm%conf)
      ps%z      = z
      ps%conf%z = z     ! atomic number
      ps%kbc    = 1     ! only one projector per angular momentum
      ps%l_loc  = lloc  ! the local part of the pseudo

      ps%l_max  = min(ps_tm%ps_grid%no_l_channels - 1, lmax)   ! Maybe the file has not enough components.
      ps%conf%p = ps_tm%ps_grid%no_l_channels
      if(ps%l_max == 0) ps%l_loc = 0 ! Vanderbilt is not acceptable if ps%l_max == 0.
      if(ps_tm%ps_grid%so_no_l_channels == 0) then
        ps%so_l_max = -1
      else
        ps%so_l_max = min(ps_tm%ps_grid%no_l_channels, ps%l_max)
      end if

      call ps_tm_process(ps_tm, lmax, ps%l_loc)
      call logrid_copy(ps_tm%ps_grid%g, ps%g)

    case(PS_TYPE_CPI)
      call ps_cpi_init(ps_cpi, trim(label))

      call valconf_null(ps%conf)
      ps%conf%z      = z
      ps%conf%symbol = label(1:2)
      ps%conf%type   = 1
      ps%conf%p      = ps_cpi%ps_grid%no_l_channels

      ps%z      = z
      ps%kbc    = 1     ! only one projector epr angular momentum
      ps%l_loc  = lloc  ! the local part of the pseudo

      ps%l_max  = min(ps_cpi%ps_grid%no_l_channels - 1, lmax)   ! Maybe the file has not enough components.
      if(ps%l_max == 0) ps%l_loc = 0 ! Vanderbilt is not acceptable if ps%l_max == 0.
      ps%so_l_max = -1

      call ps_cpi_process(ps_cpi, lmax, ps%l_loc)
      call logrid_copy(ps_cpi%ps_grid%g, ps%g)

    case(PS_TYPE_HGH)
      call hgh_init(psp, trim(label))
      call valconf_copy(ps%conf, psp%conf)

      ps%z        = z
      ps%kbc      = 3
      ps%l_loc    = -1
      ps%l_max    = psp%l_max
      ps%so_l_max = ps%l_max

      call hgh_process(psp)
      call logrid_copy(psp%g, ps%g)
    end select

    ! We allocate all the stuff
    ALLOCATE(ps%kb   (0:ps%l_max, ps%kbc),             (ps%l_max+1)*ps%kbc)
    ALLOCATE(ps%dkb  (0:ps%l_max, ps%kbc),             (ps%l_max+1)*ps%kbc)
    ALLOCATE(ps%ur   (ps%conf%p, ps%ispin),            ps%conf%p*ps%ispin)
    ALLOCATE(ps%dknrm(0:ps%l_max),                     ps%l_max+1)
    ALLOCATE(ps%h    (0:ps%l_max, 1:ps%kbc, 1:ps%kbc), (ps%l_max+1)*ps%kbc*ps%kbc)
    ALLOCATE(ps%k    (0:ps%l_max, 1:ps%kbc, 1:ps%kbc), (ps%l_max+1)*ps%kbc*ps%kbc)

    call loct_spline_init(ps%kb)
    call loct_spline_init(ps%dkb)
    call loct_spline_init(ps%vl)
    call loct_spline_init(ps%vlocalized)
    call loct_spline_init(ps%dvl)
    call loct_spline_init(ps%core)
    call loct_spline_init(ps%vlocal_f)

    if(ps%so_l_max >= 0) then
      ALLOCATE(ps%so_kb   (1:ps%so_l_max, ps%kbc), ps%so_l_max*ps%kbc)
      ALLOCATE(ps%so_dkb  (1:ps%so_l_max, ps%kbc), ps%so_l_max*ps%kbc)
      ALLOCATE(ps%so_dknrm(1:ps%so_l_max),         ps%so_l_max)

      call loct_spline_init(ps%so_kb)
      call loct_spline_init(ps%so_dkb)
    end if

    ! Now we load the necessary information.
    select case(flavour)
    case(PS_TYPE_TM2)
      call ps_grid_load(ps, ps_tm%ps_grid)
      call ps_tm_end(ps_tm)
    case(PS_TYPE_CPI)
      call ps_grid_load(ps, ps_cpi%ps_grid)
      call ps_cpi_end(ps_cpi)
    case(PS_TYPE_HGH)
      call hgh_load(ps, psp)
      call hgh_end(psp)
    end select

    ! Get the localized part of the pseudopotential.
    ps%a_erf = CNST(2.0) ! This is hard-coded to a reasonable value.
    ALLOCATE(y(ps%g%nrval), ps%g%nrval)
    y(1) = loct_splint(ps%vl, M_ZERO) + ps%z_val*(M_TWO/sqrt(M_PI))*ps%a_erf
    do i = 2, ps%g%nrval
      r = ps%g%rofi(i)
      y(i) = loct_splint(ps%vl, r) + ps%z_val*loct_erf(ps%a_erf*r)/r
    end do
    call loct_spline_fit(ps%g%nrval, ps%g%rofi, y, ps%vlocalized)

    ! And take the Fourier transform
    call loct_spline_3dft(ps%vlocalized, ps%vlocal_f, CNST(50.0))
    call loct_spline_times(CNST(1.0)/(M_FOUR*M_PI), ps%vlocal_f)

    deallocate(y)
    call pop_sub()
  end subroutine ps_init


  ! ---------------------------------------------------------
  subroutine ps_getradius(ps)
    type(ps_t), intent(inout) :: ps

    integer :: l, j, i
    FLOAT   :: r, dx, y
    FLOAT, parameter :: threshold = CNST(1.0e-3)

    call push_sub('ps.ps_getradius')

    ps%rc_max = CNST(0.0)
    dx = CNST(0.01)

    do l = 0, ps%l_max
      do j = 1, ps%kbc
        do i = 2000, 1, -1
          r = dx*(i-1)
          y = loct_splint(ps%kb(l, j), r)
          if(abs(y) > threshold) exit
        end do
        ps%rc_max = max(ps%rc_max, r)
      end do
    end do

    do l = 0, ps%so_l_max
      do j = 1, ps%kbc
        do i = 2000, 1, -1
          r = dx*(i-1)
          y = loct_splint(ps%so_kb(l, j), r)
          if(abs(y) > threshold) exit
        end do
        ps%rc_max = max(ps%rc_max, r)
      end do
    end do

    call pop_sub()
  end subroutine ps_getradius


  ! ---------------------------------------------------------
  subroutine ps_derivatives(ps)
    type(ps_t), intent(inout) :: ps
    integer :: l, j

    call push_sub('ps.ps_derivatives')

    do l = 0, ps%l_max
      do j = 1, ps%kbc
        call loct_spline_der(ps%kb(l, j), ps%dkb(l, j))
      end do
    end do
    do l = 0, ps%so_l_max
      do j = 1, ps%kbc
        call loct_spline_der(ps%so_kb(l, j), ps%so_dkb(l, j))
      end do
    end do
    call loct_spline_der(ps%vl, ps%dvl)

    call pop_sub()
  end subroutine ps_derivatives


  ! ---------------------------------------------------------
  subroutine ps_filter(ps, gmax, alpha, beta, rcut, beta2)
    type(ps_t), intent(inout) :: ps
    FLOAT, intent(in) :: gmax
    FLOAT, intent(in) :: alpha, beta, rcut, beta2
    integer :: i, l, k
    FLOAT :: r
    FLOAT, allocatable :: y(:)

    call push_sub('ps.ps_filter')

    call loct_spline_filter(ps%vlocalized, fs = (/ alpha*gmax, CNST(100.0) /) )
    call loct_spline_end(ps%vl)
    ALLOCATE(y(ps%g%nrval), ps%g%nrval)
    y(1) = loct_splint(ps%vlocalized, CNST(0.0)) - ps%z_val*(M_TWO/sqrt(M_PI))*ps%a_erf
    do i = 2, ps%g%nrval
      r = ps%g%rofi(i)
      y(i) = loct_splint(ps%vlocalized, r) - ps%z_val*loct_erf(ps%a_erf*r)/r
    end do
    call loct_spline_fit(ps%g%nrval, ps%g%rofi, y, ps%vl)

    do l = 0, ps%l_max
      do k = 1, ps%kbc
        call loct_spline_filter(ps%kb(l, k), l, fs = (/ alpha*gmax, beta /), &
          rs = (/ rcut, beta2 /))
      end do
    end do

    if(trim(ps%icore).ne.'nc') call loct_spline_filter(ps%core, fs = (/ alpha*gmax, CNST(100.0) /) )

    deallocate(y)
    call pop_sub()
  end subroutine ps_filter


  ! ---------------------------------------------------------
  subroutine ps_debug(ps, dir)
    type(ps_t), intent(in) :: ps
    character(len=*), intent(in) :: dir

    ! We will plot also some Fourier transforms.
    type(loct_spline_t), allocatable :: fw(:, :)
    FLOAT, parameter :: gmax = CNST(40.0)

    character(len=30) :: dirname
    integer  :: info_unit                            ! A text file with some basic data.
    integer  :: local_unit, dlocal_unit, localw_unit ! The local part, derivative, and FT.
    integer  :: nl_unit, dnl_unit, nlw_unit          ! Nonlocal part
    integer  :: wave_unit                            ! pseudowavefunctions
    integer  :: so_unit, dso_unit, sow_unit          ! The spin-orbit non-local terms.
    integer  :: j, k, l

    call push_sub('ps.ps_debug')

    ! Opens the files.
    dirname = trim(dir)//'/ps.'//trim(ps%label)
    call io_mkdir(dirname)
    info_unit   = io_open(trim(dirname)//'/info', action='write')
    local_unit  = io_open(trim(dirname)//'/local', action='write')
    dlocal_unit = io_open(trim(dirname)//'/local_derivative', action='write')
    localw_unit = io_open(trim(dirname)//'/local_ft', action='write')
    nl_unit     = io_open(trim(dirname)//'/nonlocal', action='write')
    dnl_unit    = io_open(trim(dirname)//'/nonlocal_derivative', action='write')
    nlw_unit    = io_open(trim(dirname)//'/nonlocal_ft', action='write')
    so_unit     = io_open(trim(dirname)//'/so', action='write')
    dso_unit    = io_open(trim(dirname)//'/so_derivative', action='write')
    sow_unit    = io_open(trim(dirname)//'/so_ft', action='write')
    wave_unit   = io_open(trim(dirname)//'/wavefunctions', action='write')

    ! Writes down the info.
    write(info_unit,'(a,/)')      ps%label
    write(info_unit,'(a,a,/)')    'Flavour : ', ps_name(ps%flavour)
    write(info_unit,'(a,f6.3)')   'z       : ', ps%z
    write(info_unit,'(a,f6.3,/)') 'zval    : ', ps%z_val
    write(info_unit,'(a,i4)')     'lmax    : ', ps%l_max
    write(info_unit,'(a,i4)')     'lloc    : ', ps%l_loc
    write(info_unit,'(a,i4)')     'so_lmax : ', ps%so_l_max
    write(info_unit,'(a,i4,/)')   'kbc     : ', ps%kbc
    write(info_unit,'(a,f9.5,/)') 'rcmax   : ', ps%rc_max
    write(info_unit,'(/,a,/)')    'h matrix:'
    do l = 0, ps%l_max
      do k = 1, ps%kbc
        write(info_unit,'(3f9.5)') (ps%h(l, k, j), j = 1, ps%kbc)
      end do
      write(info_unit, '(a)')
    end do
    write(info_unit,'(/,a,/)')    'k matrix:'
    do l = 0, ps%l_max
      do k = 1, ps%kbc
        write(info_unit,'(3f9.5)') (ps%k(l, k, j), j = 1, ps%kbc)
      end do
      write(info_unit, '(a)')
    end do

    ! Local part.
    call loct_spline_print(ps%vl, local_unit)
    call loct_spline_print(ps%dvl, dlocal_unit)
    ALLOCATE(fw(1, 1), 1*1)
    call loct_spline_init(fw(1, 1))
    call loct_spline_3dft(ps%vlocalized, fw(1, 1), gmax = gmax)
    call loct_spline_print(fw(1, 1), localw_unit)
    call loct_spline_end(fw(1, 1))
    deallocate(fw)

    ! Kleinman-Bylander projectors
    call loct_spline_print(ps%kb, nl_unit)
    call loct_spline_print(ps%dkb, dnl_unit)
    ALLOCATE(fw(0:ps%l_max, 1:ps%kbc), (ps%l_max+1)*ps%kbc)
    call loct_spline_init(fw)
    do k = 0, ps%l_max
      do j = 1, ps%kbc
        call loct_spline_3dft(ps%kb(k, j), fw(k, j), gmax = gmax)
      end do
    end do
    call loct_spline_print(fw, nlw_unit)
    call loct_spline_end(fw)
    deallocate(fw)

    ! Spin-Orbit projectors
    if(ps%so_l_max > 0) then
      call loct_spline_print(ps%so_kb, so_unit)
      call loct_spline_print(ps%so_dkb, dso_unit)
      ALLOCATE(fw(ps%so_l_max, ps%kbc), ps%so_l_max*ps%kbc)
      call loct_spline_init(fw)
      do k = 1, ps%so_l_max
        do j = 1, ps%kbc
          call loct_spline_3dft(ps%so_kb(k, j), fw(k, j), gmax = gmax)
        end do
      end do
      call loct_spline_print(fw, sow_unit)
      call loct_spline_end(fw)
      deallocate(fw)
    end if

    ! Pseudo-wavefunctions
    call loct_spline_print(ps%ur, wave_unit)

    ! Closes files and exits
    call io_close(local_unit); call io_close(dlocal_unit); call io_close(localw_unit)
    call io_close(nl_unit)   ; call io_close(dnl_unit)   ; call io_close(nlw_unit)
    call io_close(so_unit)   ; call io_close(dso_unit)   ; call io_close(sow_unit)
    call io_close(info_unit) ; call io_close(wave_unit)

    call pop_sub()
  end subroutine ps_debug


  ! ---------------------------------------------------------
  subroutine ps_end(ps)
    type(ps_t), intent(inout) :: ps

    call push_sub('ps.ps_end')

    if(.not. associated(ps%kb)) return

    call loct_spline_end(ps%kb)
    call loct_spline_end(ps%dkb)
    call loct_spline_end(ps%ur)
    if(ps%so_l_max>=0) then
      call loct_spline_end(ps%so_kb)
      call loct_spline_end(ps%so_dkb)
    end if

    call loct_spline_end(ps%vl)
    call loct_spline_end(ps%dvl)
    call loct_spline_end(ps%core)
    call loct_spline_end(ps%vlocal_f)

    deallocate(ps%kb, ps%dkb, ps%ur, ps%dknrm, ps%h, ps%k)
    if(ps%so_l_max >=0) deallocate(ps%so_kb, ps%so_dkb)

    call pop_sub()
  end subroutine ps_end


  ! ---------------------------------------------------------
  subroutine hgh_load(ps, psp)
    type(ps_t),  intent(inout) :: ps
    type(hgh_t), intent(inout) :: psp

    integer :: l, ll
    FLOAT :: x

    call push_sub('ps.hgh_load')

    ! Fixes some components of ps, read in psf
    ps%z_val = psp%z_val
    ps%icore = 'nc'
    if(ps%l_max>=0) then
      ps%rc_max = CNST(1.1) * maxval(psp%kbr(0:ps%l_max)) ! Increase a little.
    else
      ps%rc_max = M_ZERO
    end if
    ps%h(0:ps%l_max, 1:ps%kbc, 1:ps%kbc) = psp%h(0:ps%l_max, 1:ps%kbc, 1:ps%kbc)
    ps%k(0:ps%l_max, 1:ps%kbc, 1:ps%kbc) = psp%k(0:ps%l_max, 1:ps%kbc, 1:ps%kbc)

    ! Fixes the occupations
    if(ps%ispin == 2) then
      do l = 1, ps%conf%p
        ll = ps%conf%l(l)
        x = ps%conf%occ(l, 1)
        ps%conf%occ(l, 1) = min(x, real(2*ll+1, PRECISION))
        ps%conf%occ(l, 2) = x - ps%conf%occ(l, 1)
      end do
    end if

    ! now we fit the splines
    call get_splines()
    if(ps%so_l_max >= 0) ps%so_dknrm = ps%dknrm

    call pop_sub()

  contains
    ! ---------------------------------------------------------
    subroutine get_splines()
      integer :: l, is, nrc, j
      FLOAT, allocatable :: hato(:), derhato(:)

      call push_sub('ps.get_splines_hgh')

      ALLOCATE(   hato(psp%g%nrval), psp%g%nrval)
      ALLOCATE(derhato(psp%g%nrval), psp%g%nrval)

      ! Interpolate the KB-projection functions
      do l = 0, psp%l_max
        do j = 1, 3
          hato = M_ZERO
          nrc = nint(log(psp%kbr(l)/psp%g%b + M_ONE)/psp%g%a) + 1
          hato(1:nrc) = psp%kb(1:nrc, l, j)
          call loct_spline_fit(psp%g%nrval, psp%g%rofi, hato, ps%kb(l, j))
          call loct_spline_fit(psp%g%nrval, psp%g%rofi, hato, ps%so_kb(l, j))
        end do
      end do

      ! Now the part corresponding to the local pseudopotential
      ! where the asymptotic part is substracted
      call loct_spline_fit(psp%g%nrval, psp%g%rofi, psp%vlocal, ps%vl)

      ! Define the table for the pseudo-wavefunction components (using splines)
      ! with a correct normalization function
      do is = 1, ps%ispin
        do l = 1, ps%conf%p
          hato(2:psp%g%nrval) = psp%rphi(2:psp%g%nrval, l)/psp%g%rofi(2:psp%g%nrval)
          hato(1) = hato(2)
          call loct_spline_fit(psp%g%nrval, psp%g%rofi, hato, ps%Ur(l, is))
        end do
      end do
      
      call pop_sub()
    end subroutine get_splines
  end subroutine hgh_load


  ! ---------------------------------------------------------
  subroutine ps_grid_load(ps, ps_grid)
    type(ps_t),         intent(out) :: ps
    type(ps_in_grid_t), intent(in)  :: ps_grid

    call push_sub('ps.ps_grid_load')

    ! Fixes some components of ps, read in ps_grid
    ps%z_val = ps_grid%zval

    ps%icore = 'nc'
    if(ps_grid%core_corrections) ps%icore=''

    ps%h(0:ps%l_max, 1, 1) = ps_grid%dkbcos(1:ps%l_max+1)
    ps%dknrm(0:ps%l_max)   = ps_grid%dknorm(1:ps%l_max+1)

    if(ps%so_l_max > 0) then
      ps%k(1:ps%so_l_max, 1, 1)  = ps_grid%so_dkbcos(1:ps%so_l_max)
      ps%so_dknrm(1:ps%so_l_max) = ps_grid%so_dknorm(1:ps%so_l_max)
    end if

    ! Increasing radius a little, just in case.
    ! I have hard-coded a larger increase of the cutoff for the filtering.
    ps%rc_max = maxval(ps_grid%kb_radius(1:ps%l_max+1)) * CNST(1.5)

    ! now we fit the splines
    call get_splines(ps_grid%g)

    ! Passes from Rydbergs to Hartrees.
    ps%h(0:ps%l_max,:,:)    = ps%h(0:ps%l_max,:,:)    / M_TWO
    ps%dknrm(0:ps%l_max)    = ps%dknrm(0:ps%l_max)    * M_TWO
    if(ps%so_l_max >= 0) then
      ps%k(0:ps%l_max,:,:)    = ps%k(0:ps%l_max,:,:)    / M_TWO
      ps%so_dknrm(0:ps%l_max) = ps%so_dknrm(0:ps%l_max) * M_TWO
    end if

    call pop_sub()

  contains

    subroutine get_splines(g)
      type(logrid_t), intent(in) :: g

      FLOAT, allocatable :: hato(:)
      integer :: is, l, ir, nrc

      ALLOCATE(hato(g%nrval), g%nrval)

      ! the wave-functions
      do is = 1, ps%ispin
        do l = 1, ps_grid%no_l_channels
          hato(2:) = ps_grid%rphi(2:, l, 1+is)/g%rofi(2:)
          hato(1)  = linear_extrapolate(g%rofi(1), g%rofi(2), g%rofi(3), &
            hato(2), hato(3))

          call loct_spline_fit(g%nrval, g%rofi, hato, ps%ur(l, is))

        end do
      end do

      ! the Kleinman-Bylander projectors
      do l = 1, ps%l_max+1
        nrc = logrid_index(g, ps_grid%kb_radius(l)) + 1
        hato(1:nrc)         = ps_grid%KB(1:nrc, l)
        hato(nrc+1:g%nrval) = M_ZERO

        call loct_spline_fit(g%nrval, g%rofi, hato, ps%kb(l-1, 1))
      end do

      do l = 1, ps%so_l_max
        nrc = logrid_index(g, ps_grid%so_kb_radius(l)) + 1
        hato(1:nrc)         = ps_grid%so_KB(1:nrc, l)
        hato(nrc+1:g%nrval) = M_ZERO

        call loct_spline_fit(g%nrval, g%rofi, hato, ps%so_kb(l, 1))
      end do

      ! Now the part corresponding to the local pseudopotential
      ! where the asymptotic part is substracted
      hato(:) = ps_grid%vlocal(:)/M_TWO
      call loct_spline_fit(g%nrval, g%rofi, hato, ps%vl)
      
      if(ps_grid%core_corrections) then
        ! find cutoff radius
        hato(2:) = ps_grid%chcore(2:)/(M_FOUR*M_PI*g%rofi(2:)**2)

        do ir = g%nrval-1, 2, -1
          if(hato(ir) > eps) then
            nrc = ir + 1
            exit
          end if
        end do

        hato(nrc:g%nrval) = M_ZERO
        hato(1) = linear_extrapolate(g%rofi(1), g%rofi(2), g%rofi(3), &
          hato(2), hato(3))

        call loct_spline_fit(g%nrval, g%rofi, hato, ps%core)
      end if

      deallocate(hato)
    end subroutine get_splines
  end subroutine ps_grid_load

end module ps_m
