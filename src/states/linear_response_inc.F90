!! Copyright (C) 2004 E.S. Kadantsev, M. Marques
!!
!! This program is free software; you can redistribute it and/or modify
!! it under the terms of the GNU General Public License as published by
!! the Free Software Foundation; either version 2, or (at your option)
!! any later version.
!!
!! This program is distributed in the hope that it will be useful,
!! but WITHOUT ANY WARRANTY; without even the implied warranty of
!! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!! GNU General Public License for more details.
!!
!! You should have received a copy of the GNU General Public License
!! along with this program; if not, write to the Free Software
!! Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
!! 02111-1307, USA.
!!
!! $Id$


! ---------------------------------------------------------
! Orthogonalizes v against all the occupied states
! For details on the metallic part, take a look at
! de Gironcoli, PRB 51, 6773 (1995)
! ---------------------------------------------------------
subroutine X(lr_orth_vector) (m, st, v, ist, ik)
  type(mesh_t),        intent(in)    :: m
  type(states_t),      intent(in)    :: st
  R_TYPE,              intent(inout) :: v(:,:)
  integer,             intent(in)    :: ist, ik

  integer :: jst
  FLOAT :: xx, theta_ij, theta_ji, alpha_j, delta_e, dsmear
  FLOAT, allocatable :: theta_Fi(:), beta_ij(:)

  call push_sub('linear_response_inc.Xlr_orth_vector')

  dsmear = max(CNST(1e-14), st%smear%dsmear)

  ALLOCATE(theta_Fi(st%nst), st%nst)
  do jst = 1, st%nst
    ! epsilon has to be added or we have problem with semiconducting smearing
    xx = (st%smear%e_fermi - st%eigenval(jst, ik) + CNST(1e-14))/dsmear
    theta_Fi(jst) = smear_step_function(st%smear, xx)
  end do

  ALLOCATE(beta_ij(st%nst), st%nst)

  if(st%smear%fixed_occ .or. st%smear%method == SMEAR_SEMICONDUCTOR) then
    beta_ij = Theta_Fi

  else
    beta_ij = M_ZERO
    do jst = 1, st%nst
      xx = (st%eigenval(ist, ik) - st%eigenval(jst, ik))/dsmear
      theta_ij = smear_step_function(st%smear,  xx)
      theta_ji = smear_step_function(st%smear, -xx)
      
      beta_ij(jst) = theta_Fi(ist)*Theta_ij + Theta_Fi(jst)*Theta_ji
        
      alpha_j = max(st%smear%e_fermi + M_THREE*dsmear - st%eigenval(jst, ik), M_ZERO)
      delta_e = st%eigenval(ist, ik) - st%eigenval(jst, ik)
      
      if(abs(delta_e) >= CNST(1e-5)) then
        beta_ij(jst) = beta_ij(jst) + alpha_j*Theta_ji*(Theta_Fi(ist) - Theta_Fi(jst))/delta_e
      else
        xx = (st%smear%e_fermi - st%eigenval(ist, ik) + CNST(1e-14))/dsmear
        beta_ij(jst) = beta_ij(jst) + alpha_j*Theta_ji*  &
          (-smear_delta_function(st%smear,  xx)/dsmear)
      end if
    end do
  end if

  call X(states_gram_schmidt)(m, st%nst, st%d%dim, st%X(psi)(:, :, :, ik), v(:, :), &
    Theta_Fi=Theta_Fi(ist), beta_ij=beta_ij)

  deallocate(beta_ij)
  deallocate(Theta_Fi)

  call pop_sub()

end subroutine X(lr_orth_vector)


! --------------------------------------------------------------------
subroutine X(lr_build_dl_rho) (m, st, lr, nsigma)
  type(mesh_t),   intent(in)    :: m
  type(states_t), intent(in)    :: st
  type(lr_t),     intent(inout) :: lr(:)
  integer,        intent(in)    :: nsigma

  integer :: i, ist, ik, ik2, sp
  CMPLX   :: c
  R_TYPE  :: d

  call push_sub('linear_response_inc.Xlr_build_dl_rho')

  ! initialize density
  do i = 1, nsigma
    lr(i)%X(dl_rho)(:, :) = M_ZERO
  end do

  sp = 1
  if(st%d%ispin == SPIN_POLARIZED) sp = 2

  ! calculate density
  do ik = 1, st%d%nik, sp
    do ist  = st%st_start, st%st_end
      do i = 1, m%np

        do ik2 = ik, ik+sp-1 ! this loop takes care of the SPIN_POLARIZED case
          d = st%d%kweights(ik2) * st%smear%el_per_state

          if(nsigma == 1) then  ! either omega purely real or purely imaginary
            d = d * st%X(psi)(i, 1, ist, ik2)*R_CONJ(lr(1)%X(dl_psi)(i, 1, ist, ik2))
            lr(1)%X(dl_rho)(i, 1) = lr(1)%X(dl_rho)(i, 1) + d + R_CONJ(d)
          else
            c = d * (                                                             &
              R_CONJ(st%X(psi)(i, 1, ist, ik2))*lr(1)%X(dl_psi)(i, 1, ist, ik2) + &
              st%X(psi)(i, 1, ist, ik2)*R_CONJ(lr(2)%X(dl_psi)(i, 1, ist, ik2)))
            lr(1)%X(dl_rho)(i, 1) = lr(1)%X(dl_rho)(i, 1) + c
            lr(2)%X(dl_rho)(i, 1) = lr(2)%X(dl_rho)(i, 1) + R_CONJ(c)
          end if
        end do

        if(st%d%ispin == SPINORS) then
          message(1) = "Not yet implemented - please fix me"
          call write_fatal(1)
        end if

      end do
    end do
  end do

  call pop_sub()
end subroutine X(lr_build_dl_rho)


! ---------------------------------------------------------
! orthogonalizes response of \alpha KS orbital to all occupied
! \alpha KS orbitals
! ---------------------------------------------------------
subroutine X(lr_orth_response)(m, st, lr)
  type(mesh_t),   intent(in)    :: m
  type(states_t), intent(in)    :: st
  type(lr_t),     intent(inout) :: lr
  
  integer :: ist, ik
  call push_sub('linear_response_inc.Xlr_orth_response')
  
  do ik = 1, st%d%nik
    do ist = 1, st%nst
      call X(lr_orth_vector) (m, st, lr%X(dl_psi)(:,:, ist, ik), ist, ik)
    end do
  end do
  
  call pop_sub()
end subroutine X(lr_orth_response)


!! Local Variables:
!! mode: f90
!! coding: utf-8
!! End:
